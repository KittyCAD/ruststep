#![allow(dead_code)]
use crate::{as_holder, derive_more::*, primitive::*, Holder, TableInit};
use std::collections::HashMap;
static COMPLETE: ::phf::Map<&'static str, &'static [&'static str]> = ::phf::phf_map! { "ABSORBED_DOSE_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "ABSORBED_DOSE_UNIT" => & ["elements" ,] , "ABSTRACT_VARIABLE" => & ["name" , "description" , "definition" , "used_representation" , "items" , "context_of_items" ,] , "ACCELERATION_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "ACCELERATION_UNIT" => & ["elements" ,] , "ACTION" => & ["name" , "description" , "chosen_method" ,] , "ACTION_ASSIGNMENT" => & ["assigned_action" ,] , "ACTION_DIRECTIVE" => & ["name" , "description" , "analysis" , "comment" , "requests" ,] , "ACTION_METHOD" => & ["name" , "description" , "consequence" , "purpose" ,] , "ACTION_METHOD_ASSIGNMENT" => & ["assigned_action_method" , "role" ,] , "ACTION_METHOD_RELATIONSHIP" => & ["name" , "description" , "relating_method" , "related_method" ,] , "ACTION_METHOD_ROLE" => & ["name" , "description" ,] , "ACTION_PROPERTY" => & ["name" , "description" , "definition" ,] , "ACTION_PROPERTY_REPRESENTATION" => & ["name" , "description" , "property" , "representation" ,] , "ACTION_RELATIONSHIP" => & ["name" , "description" , "relating_action" , "related_action" ,] , "ACTION_REQUEST_ASSIGNMENT" => & ["assigned_action_request" ,] , "ACTION_REQUEST_SOLUTION" => & ["method" , "request" ,] , "ACTION_REQUEST_STATUS" => & ["status" , "assigned_request" ,] , "ACTION_STATUS" => & ["status" , "assigned_action" ,] , "ADDRESS" => & ["internal_location" , "street_number" , "street" , "postal_box" , "town" , "region" , "postal_code" , "country" , "facsimile_number" , "telephone_number" , "electronic_mail_address" , "telex_number" ,] , "ADVANCED_BREP_SHAPE_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "ADVANCED_FACE" => & ["name" , "bounds" , "face_geometry" , "same_sense" ,] , "ALTERNATE_PRODUCT_RELATIONSHIP" => & ["name" , "definition" , "alternate" , "base" , "basis" ,] , "AMOUNT_OF_SUBSTANCE_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "AMOUNT_OF_SUBSTANCE_UNIT" => & ["dimensions" ,] , "ANGLE_DIRECTION_REFERENCE" => & ["name" , "description" , "relating_representation_item" , "related_representation_item" ,] , "ANGULAR_DIMENSION" => & ["name" , "contents" ,] , "ANGULAR_LOCATION" => & ["name" , "description" , "relating_shape_aspect" , "related_shape_aspect" , "angle_selection" ,] , "ANGULAR_SIZE" => & ["applies_to" , "name" , "angle_selection" ,] , "ANGULARITY_TOLERANCE" => & ["name" , "description" , "magnitude" , "toleranced_shape_aspect" , "datum_system" ,] , "ANNOTATION_CURVE_OCCURRENCE" => & ["name" , "styles" , "item" ,] , "ANNOTATION_FILL_AREA" => & ["name" , "boundaries" ,] , "ANNOTATION_FILL_AREA_OCCURRENCE" => & ["name" , "styles" , "item" , "fill_style_target" ,] , "ANNOTATION_OCCURRENCE" => & ["name" , "styles" , "item" ,] , "ANNOTATION_OCCURRENCE_ASSOCIATIVITY" => & ["name" , "description" , "relating_annotation_occurrence" , "related_annotation_occurrence" ,] , "ANNOTATION_OCCURRENCE_RELATIONSHIP" => & ["name" , "description" , "relating_annotation_occurrence" , "related_annotation_occurrence" ,] , "ANNOTATION_PLANE" => & ["name" , "styles" , "item" , "elements" ,] , "ANNOTATION_SUBFIGURE_OCCURRENCE" => & ["name" , "styles" , "item" ,] , "ANNOTATION_SYMBOL" => & ["name" , "mapping_source" , "mapping_target" ,] , "ANNOTATION_SYMBOL_OCCURRENCE" => & ["name" , "styles" , "item" ,] , "ANNOTATION_TEXT" => & ["name" , "mapping_source" , "mapping_target" ,] , "ANNOTATION_TEXT_CHARACTER" => & ["name" , "mapping_source" , "mapping_target" , "alignment" ,] , "ANNOTATION_TEXT_OCCURRENCE" => & ["name" , "styles" , "item" ,] , "APEX" => & ["name" , "description" , "of_shape" , "product_definitional" ,] , "APPLICATION_CONTEXT" => & ["application" ,] , "APPLICATION_CONTEXT_ELEMENT" => & ["name" , "frame_of_reference" ,] , "APPLICATION_PROTOCOL_DEFINITION" => & ["status" , "application_interpreted_model_schema_name" , "application_protocol_year" , "application" ,] , "APPLIED_ACTION_ASSIGNMENT" => & ["assigned_action" , "items" ,] , "APPLIED_ACTION_METHOD_ASSIGNMENT" => & ["assigned_action_method" , "role" , "items" ,] , "APPLIED_ACTION_REQUEST_ASSIGNMENT" => & ["assigned_action_request" , "items" ,] , "APPLIED_APPROVAL_ASSIGNMENT" => & ["assigned_approval" , "items" ,] , "APPLIED_ATTRIBUTE_CLASSIFICATION_ASSIGNMENT" => & ["assigned_class" , "attribute_name" , "role" , "items" ,] , "APPLIED_CERTIFICATION_ASSIGNMENT" => & ["assigned_certification" , "items" ,] , "APPLIED_CLASSIFICATION_ASSIGNMENT" => & ["assigned_class" , "role" , "items" ,] , "APPLIED_CONTRACT_ASSIGNMENT" => & ["assigned_contract" , "items" ,] , "APPLIED_DATE_AND_TIME_ASSIGNMENT" => & ["assigned_date_and_time" , "role" , "items" ,] , "APPLIED_DATE_ASSIGNMENT" => & ["assigned_date" , "role" , "items" ,] , "APPLIED_DOCUMENT_REFERENCE" => & ["assigned_document" , "source" , "items" ,] , "APPLIED_DOCUMENT_USAGE_CONSTRAINT_ASSIGNMENT" => & ["assigned_document_usage" , "role" , "items" ,] , "APPLIED_EFFECTIVITY_ASSIGNMENT" => & ["assigned_effectivity" , "items" ,] , "APPLIED_EVENT_OCCURRENCE_ASSIGNMENT" => & ["assigned_event_occurrence" , "role" , "items" ,] , "APPLIED_EXTERNAL_IDENTIFICATION_ASSIGNMENT" => & ["assigned_id" , "role" , "source" , "items" ,] , "APPLIED_GROUP_ASSIGNMENT" => & ["assigned_group" , "items" ,] , "APPLIED_IDENTIFICATION_ASSIGNMENT" => & ["assigned_id" , "role" , "items" ,] , "APPLIED_NAME_ASSIGNMENT" => & ["assigned_name" , "item" ,] , "APPLIED_ORGANIZATION_ASSIGNMENT" => & ["assigned_organization" , "role" , "items" ,] , "APPLIED_ORGANIZATIONAL_PROJECT_ASSIGNMENT" => & ["assigned_organizational_project" , "role" , "items" ,] , "APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT" => & ["assigned_person_and_organization" , "role" , "items" ,] , "APPLIED_PRESENTED_ITEM" => & ["items" ,] , "APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT" => & ["assigned_security_classification" , "items" ,] , "APPLIED_TIME_INTERVAL_ASSIGNMENT" => & ["assigned_time_interval" , "role" , "items" ,] , "APPLIED_USAGE_RIGHT" => & ["assigned_action" , "items" ,] , "APPROVAL" => & ["status" , "level" ,] , "APPROVAL_ASSIGNMENT" => & ["assigned_approval" ,] , "APPROVAL_DATE_TIME" => & ["date_time" , "dated_approval" ,] , "APPROVAL_PERSON_ORGANIZATION" => & ["person_organization" , "authorized_approval" , "role" ,] , "APPROVAL_RELATIONSHIP" => & ["name" , "description" , "relating_approval" , "related_approval" ,] , "APPROVAL_ROLE" => & ["role" ,] , "APPROVAL_STATUS" => & ["name" ,] , "AREA_IN_SET" => & ["area" , "in_set" ,] , "AREA_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "AREA_UNIT" => & ["elements" ,] , "ASSEMBLY_COMPONENT_USAGE" => & ["id" , "name" , "description" , "relating_product_definition" , "related_product_definition" , "reference_designator" ,] , "ASSEMBLY_COMPONENT_USAGE_SUBSTITUTE" => & ["name" , "definition" , "base" , "substitute" ,] , "ASSIGNED_REQUIREMENT" => & ["assigned_group" , "items" ,] , "ATOMIC_FORMULA" => & ["name" , "item_element" ,] , "ATTRIBUTE_ASSERTION" => & ["name" , "description" , "definition" , "used_representation" , "items" , "context_of_items" ,] , "ATTRIBUTE_CLASSIFICATION_ASSIGNMENT" => & ["assigned_class" , "attribute_name" , "role" ,] , "ATTRIBUTE_LANGUAGE_ASSIGNMENT" => & ["assigned_class" , "attribute_name" , "role" , "items" ,] , "ATTRIBUTE_VALUE_ASSIGNMENT" => & ["attribute_name" , "attribute_value" , "role" ,] , "ATTRIBUTE_VALUE_ROLE" => & ["name" , "description" ,] , "AUXILIARY_GEOMETRIC_REPRESENTATION_ITEM" => & ["name" ,] , "AXIS1_PLACEMENT" => & ["name" , "location" , "axis" ,] , "AXIS2_PLACEMENT_2D" => & ["name" , "location" , "ref_direction" ,] , "AXIS2_PLACEMENT_3D" => & ["name" , "location" , "axis" , "ref_direction" ,] , "B_SPLINE_CURVE" => & ["name" , "degree" , "control_points_list" , "curve_form" , "closed_curve" , "self_intersect" ,] , "B_SPLINE_CURVE_WITH_KNOTS" => & ["name" , "degree" , "control_points_list" , "curve_form" , "closed_curve" , "self_intersect" , "knot_multiplicities" , "knots" , "knot_spec" ,] , "B_SPLINE_SURFACE" => & ["name" , "u_degree" , "v_degree" , "control_points_list" , "surface_form" , "u_closed" , "v_closed" , "self_intersect" ,] , "B_SPLINE_SURFACE_WITH_KNOTS" => & ["name" , "u_degree" , "v_degree" , "control_points_list" , "surface_form" , "u_closed" , "v_closed" , "self_intersect" , "u_multiplicities" , "v_multiplicities" , "u_knots" , "v_knots" , "knot_spec" ,] , "BACK_CHAINING_RULE" => & ["id" , "description" , "formation" , "frame_of_reference" ,] , "BACK_CHAINING_RULE_BODY" => & ["name" , "description" , "definition" , "used_representation" , "items" , "context_of_items" ,] , "BACKGROUND_COLOUR" => & ["presentation" ,] , "BEVELED_SHEET_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "BEZIER_CURVE" => & ["name" , "degree" , "control_points_list" , "curve_form" , "closed_curve" , "self_intersect" ,] , "BEZIER_SURFACE" => & ["name" , "u_degree" , "v_degree" , "control_points_list" , "surface_form" , "u_closed" , "v_closed" , "self_intersect" ,] , "BINARY_GENERIC_EXPRESSION" => & ["operands" ,] , "BINARY_NUMERIC_EXPRESSION" => & ["operands" ,] , "BINARY_REPRESENTATION_ITEM" => & ["name" , "binary_value" ,] , "BLOCK" => & ["name" , "position" , "x" , "y" , "z" ,] , "BOOLEAN_EXPRESSION" => & [] , "BOOLEAN_LITERAL" => & ["the_value" ,] , "BOOLEAN_REPRESENTATION_ITEM" => & ["name" , "the_value" ,] , "BOOLEAN_RESULT" => & ["name" , "operator" , "first_operand" , "second_operand" ,] , "BOUNDARY_CURVE" => & ["name" , "segments" , "self_intersect" ,] , "BOUNDED_CURVE" => & ["name" ,] , "BOUNDED_PCURVE" => & ["name" , "basis_surface" , "reference_to_curve" ,] , "BOUNDED_SURFACE" => & ["name" ,] , "BOUNDED_SURFACE_CURVE" => & ["name" , "curve_3d" , "associated_geometry" , "master_representation" ,] , "BOX_DOMAIN" => & ["corner" , "xlength" , "ylength" , "zlength" ,] , "BOXED_HALF_SPACE" => & ["name" , "base_surface" , "agreement_flag" , "enclosure" ,] , "BREAKDOWN_CONTEXT" => & ["id" , "name" , "description" , "relating_product_definition" , "related_product_definition" ,] , "BREAKDOWN_ELEMENT_GROUP_ASSIGNMENT" => & ["assigned_group" , "items" ,] , "BREAKDOWN_ELEMENT_REALIZATION" => & ["name" , "description" ,] , "BREAKDOWN_ELEMENT_USAGE" => & ["id" , "name" , "description" , "relating_product_definition" , "related_product_definition" ,] , "BREAKDOWN_OF" => & ["id" , "name" , "description" , "relating_product_definition" , "related_product_definition" ,] , "BREP_WITH_VOIDS" => & ["name" , "outer" , "voids" ,] , "BYTES_REPRESENTATION_ITEM" => & ["name" , "binary_value" ,] , "CALENDAR_DATE" => & ["year_component" , "day_component" , "month_component" ,] , "CAMERA_IMAGE" => & ["name" , "mapping_source" , "mapping_target" ,] , "CAMERA_IMAGE_3D_WITH_SCALE" => & ["name" , "mapping_source" , "mapping_target" ,] , "CAMERA_MODEL" => & ["name" ,] , "CAMERA_MODEL_D_3" => & ["name" , "view_reference_system" , "perspective_of_volume" ,] , "CAMERA_MODEL_D_3_MULTI_CLIPPING" => & ["name" , "view_reference_system" , "perspective_of_volume" , "shape_clipping" ,] , "CAMERA_MODEL_D_3_MULTI_CLIPPING_INTERSECTION" => & ["name" , "shape_clipping" ,] , "CAMERA_MODEL_D_3_MULTI_CLIPPING_UNION" => & ["name" , "shape_clipping" ,] , "CAMERA_MODEL_D_3_WITH_HLHSR" => & ["name" , "view_reference_system" , "perspective_of_volume" , "hidden_line_surface_removal" ,] , "CAMERA_MODEL_WITH_LIGHT_SOURCES" => & ["name" , "view_reference_system" , "perspective_of_volume" , "sources" ,] , "CAMERA_USAGE" => & ["mapping_origin" , "mapped_representation" ,] , "CAPACITANCE_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "CAPACITANCE_UNIT" => & ["elements" ,] , "CARTESIAN_POINT" => & ["name" , "coordinates" ,] , "CARTESIAN_TRANSFORMATION_OPERATOR" => & ["name" , "description" , "axis1" , "axis2" , "local_origin" , "scale" ,] , "CARTESIAN_TRANSFORMATION_OPERATOR_2D" => & ["name" , "description" , "axis1" , "axis2" , "local_origin" , "scale" ,] , "CARTESIAN_TRANSFORMATION_OPERATOR_3D" => & ["name" , "description" , "axis1" , "axis2" , "local_origin" , "scale" , "axis3" ,] , "CC_DESIGN_APPROVAL" => & ["assigned_approval" , "items" ,] , "CC_DESIGN_CERTIFICATION" => & ["assigned_certification" , "items" ,] , "CC_DESIGN_CONTRACT" => & ["assigned_contract" , "items" ,] , "CC_DESIGN_DATE_AND_TIME_ASSIGNMENT" => & ["assigned_date_and_time" , "role" , "items" ,] , "CC_DESIGN_PERSON_AND_ORGANIZATION_ASSIGNMENT" => & ["assigned_person_and_organization" , "role" , "items" ,] , "CC_DESIGN_SECURITY_CLASSIFICATION" => & ["assigned_security_classification" , "items" ,] , "CC_DESIGN_SPECIFICATION_REFERENCE" => & ["assigned_document" , "source" , "items" ,] , "CELSIUS_TEMPERATURE_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "CENTRE_OF_SYMMETRY" => & ["name" , "description" , "of_shape" , "product_definitional" ,] , "CERTIFICATION" => & ["name" , "purpose" , "kind" ,] , "CERTIFICATION_ASSIGNMENT" => & ["assigned_certification" ,] , "CERTIFICATION_TYPE" => & ["description" ,] , "CHANGE" => & ["assigned_action" , "items" ,] , "CHANGE_REQUEST" => & ["assigned_action_request" , "items" ,] , "CHARACTER_GLYPH_FONT_USAGE" => & ["character" , "font" ,] , "CHARACTER_GLYPH_STYLE_OUTLINE" => & ["outline_style" ,] , "CHARACTER_GLYPH_STYLE_STROKE" => & ["stroke_style" ,] , "CHARACTER_GLYPH_SYMBOL" => & ["name" , "items" , "context_of_items" , "character_box" , "baseline_ratio" ,] , "CHARACTER_GLYPH_SYMBOL_OUTLINE" => & ["name" , "items" , "context_of_items" , "character_box" , "baseline_ratio" , "outlines" ,] , "CHARACTER_GLYPH_SYMBOL_STROKE" => & ["name" , "items" , "context_of_items" , "character_box" , "baseline_ratio" , "strokes" ,] , "CHARACTERISTIC_DATA_COLUMN_HEADER" => & ["id" , "name" , "description" ,] , "CHARACTERISTIC_DATA_COLUMN_HEADER_LINK" => & ["name" , "description" , "relating_property" , "related_property" ,] , "CHARACTERISTIC_DATA_TABLE_HEADER" => & ["id" , "name" , "description" ,] , "CHARACTERISTIC_DATA_TABLE_HEADER_DECOMPOSITION" => & ["name" , "description" , "relating_property" , "related_property" ,] , "CHARACTERISTIC_TYPE" => & ["name" , "description" ,] , "CHARACTERIZED_CLASS" => & ["name" , "description" ,] , "CHARACTERIZED_OBJECT" => & ["name" , "description" ,] , "CIRCLE" => & ["name" , "position" , "radius" ,] , "CIRCULAR_RUNOUT_TOLERANCE" => & ["name" , "description" , "magnitude" , "toleranced_shape_aspect" , "datum_system" ,] , "CLASS" => & ["name" , "description" ,] , "CLASS_BY_EXTENSION" => & ["name" , "description" ,] , "CLASS_BY_INTENSION" => & ["name" , "description" ,] , "CLASS_SYSTEM" => & ["name" , "description" ,] , "CLASS_USAGE_EFFECTIVITY_CONTEXT_ASSIGNMENT" => & ["assigned_effectivity_assignment" , "role" , "items" ,] , "CLASSIFICATION_ASSIGNMENT" => & ["assigned_class" , "role" ,] , "CLASSIFICATION_ROLE" => & ["name" , "description" ,] , "CLOSED_SHELL" => & ["name" , "cfs_faces" ,] , "COAXIALITY_TOLERANCE" => & ["name" , "description" , "magnitude" , "toleranced_shape_aspect" , "datum_system" ,] , "COLOUR" => & [] , "COLOUR_RGB" => & ["name" , "red" , "green" , "blue" ,] , "COLOUR_SPECIFICATION" => & ["name" ,] , "COMMON_DATUM" => & ["name" , "description" , "of_shape" , "product_definitional" , "identification" ,] , "COMPARISON_EXPRESSION" => & ["operands" ,] , "COMPLEX_CLAUSE" => & ["name" , "item_element" ,] , "COMPLEX_CONJUNCTIVE_CLAUSE" => & ["name" , "item_element" ,] , "COMPLEX_DISJUNCTIVE_CLAUSE" => & ["name" , "item_element" ,] , "COMPLEX_SHELLED_SOLID" => & ["name" , "rationale" , "base_solid" , "deleted_face_set" , "thickness" , "thickened_face_list" , "thickness_list" ,] , "COMPOSITE_ASSEMBLY_DEFINITION" => & ["id" , "description" , "formation" , "frame_of_reference" ,] , "COMPOSITE_ASSEMBLY_SEQUENCE_DEFINITION" => & ["id" , "description" , "formation" , "frame_of_reference" ,] , "COMPOSITE_ASSEMBLY_TABLE" => & ["id" , "description" , "formation" , "frame_of_reference" ,] , "COMPOSITE_CURVE" => & ["name" , "segments" , "self_intersect" ,] , "COMPOSITE_CURVE_ON_SURFACE" => & ["name" , "segments" , "self_intersect" ,] , "COMPOSITE_CURVE_SEGMENT" => & ["transition" , "same_sense" , "parent_curve" ,] , "COMPOSITE_MATERIAL_DESIGNATION" => & ["name" , "definitions" ,] , "COMPOSITE_SHAPE_ASPECT" => & ["name" , "description" , "of_shape" , "product_definitional" ,] , "COMPOSITE_SHEET_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "COMPOSITE_TEXT" => & ["name" , "collected_text" ,] , "COMPOSITE_TEXT_WITH_ASSOCIATED_CURVES" => & ["name" , "collected_text" , "associated_curves" ,] , "COMPOSITE_TEXT_WITH_BLANKING_BOX" => & ["name" , "collected_text" , "blanking" ,] , "COMPOSITE_TEXT_WITH_DELINEATION" => & ["name" , "collected_text" , "delineation" ,] , "COMPOSITE_TEXT_WITH_EXTENT" => & ["name" , "collected_text" , "extent" ,] , "COMPOUND_REPRESENTATION_ITEM" => & ["name" , "item_element" ,] , "COMPOUND_SHAPE_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "CONCENTRICITY_TOLERANCE" => & ["name" , "description" , "magnitude" , "toleranced_shape_aspect" , "datum_system" ,] , "CONCEPT_FEATURE_OPERATOR" => & ["name" , "description" ,] , "CONCEPT_FEATURE_RELATIONSHIP" => & ["name" , "description" , "relating_product_concept_feature" , "related_product_concept_feature" ,] , "CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION" => & ["name" , "description" , "relating_product_concept_feature" , "related_product_concept_feature" , "conditional_operator" ,] , "CONDITIONAL_CONCEPT_FEATURE" => & ["id" , "name" , "description" , "condition" ,] , "CONDUCTANCE_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "CONDUCTANCE_UNIT" => & ["elements" ,] , "CONFIGURABLE_ITEM" => & ["id" , "name" , "description" , "item_concept" , "purpose" , "item_concept_feature" ,] , "CONFIGURATION_DESIGN" => & ["configuration" , "design" ,] , "CONFIGURATION_EFFECTIVITY" => & ["id" , "usage" , "configuration" ,] , "CONFIGURATION_ITEM" => & ["id" , "name" , "description" , "item_concept" , "purpose" ,] , "CONFIGURATION_ITEM_HIERARCHICAL_RELATIONSHIP" => & ["name" , "description" , "relating_configuration_item" , "related_configuration_item" ,] , "CONFIGURATION_ITEM_RELATIONSHIP" => & ["name" , "description" , "relating_configuration_item" , "related_configuration_item" ,] , "CONFIGURATION_ITEM_REVISION_SEQUENCE" => & ["name" , "description" , "relating_configuration_item" , "related_configuration_item" ,] , "CONFIGURED_EFFECTIVITY_ASSIGNMENT" => & ["assigned_effectivity" , "items" ,] , "CONFIGURED_EFFECTIVITY_CONTEXT_ASSIGNMENT" => & ["assigned_effectivity_assignment" , "role" , "items" ,] , "CONIC" => & ["name" , "position" ,] , "CONICAL_STEPPED_HOLE_TRANSITION" => & ["name" , "transition_number" , "cone_apex_angle" , "cone_base_radius" ,] , "CONICAL_SURFACE" => & ["name" , "position" , "radius" , "semi_angle" ,] , "CONNECTED_EDGE_SET" => & ["name" , "ces_edges" ,] , "CONNECTED_FACE_SET" => & ["name" , "cfs_faces" ,] , "CONNECTED_FACE_SUB_SET" => & ["name" , "cfs_faces" , "parent_face_set" ,] , "CONSTRUCTIVE_GEOMETRY_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "CONSTRUCTIVE_GEOMETRY_REPRESENTATION_RELATIONSHIP" => & ["name" , "description" , "rep_1" , "rep_2" ,] , "CONTACT_RATIO_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "CONTEXT_DEPENDENT_INVISIBILITY" => & ["invisible_items" , "presentation_context" ,] , "CONTEXT_DEPENDENT_OVER_RIDING_STYLED_ITEM" => & ["name" , "styles" , "item" , "over_ridden_style" , "style_context" ,] , "CONTEXT_DEPENDENT_SHAPE_REPRESENTATION" => & ["representation_relation" , "represented_product_relation" ,] , "CONTEXT_DEPENDENT_UNIT" => & ["dimensions" , "name" ,] , "CONTRACT" => & ["name" , "purpose" , "kind" ,] , "CONTRACT_ASSIGNMENT" => & ["assigned_contract" ,] , "CONTRACT_RELATIONSHIP" => & ["id" , "name" , "description" , "relating_contract" , "related_contract" ,] , "CONTRACT_TYPE" => & ["description" ,] , "CONVERSION_BASED_UNIT" => & ["dimensions" , "name" , "conversion_factor" ,] , "COORDINATED_UNIVERSAL_TIME_OFFSET" => & ["hour_offset" , "minute_offset" , "sense" ,] , "CSG_SHAPE_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "CSG_SOLID" => & ["name" , "tree_root_expression" ,] , "CURRENCY" => & ["dimensions" , "name" ,] , "CURRENCY_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "CURVE" => & ["name" ,] , "CURVE_BOUNDED_SURFACE" => & ["name" , "basis_surface" , "boundaries" , "implicit_outer" ,] , "CURVE_DIMENSION" => & ["name" , "contents" ,] , "CURVE_REPLICA" => & ["name" , "parent_curve" , "transformation" ,] , "CURVE_STYLE" => & ["name" , "curve_font" , "curve_width" , "curve_colour" ,] , "CURVE_STYLE_FONT" => & ["name" , "pattern_list" ,] , "CURVE_STYLE_FONT_AND_SCALING" => & ["name" , "curve_font" , "curve_font_scaling" ,] , "CURVE_STYLE_FONT_PATTERN" => & ["visible_segment_length" , "invisible_segment_length" ,] , "CURVE_STYLE_RENDERING" => & ["rendering_method" , "rendering_properties" ,] , "CURVE_SWEPT_SOLID_SHAPE_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "CYLINDRICAL_SURFACE" => & ["name" , "position" , "radius" ,] , "CYLINDRICITY_TOLERANCE" => & ["name" , "description" , "magnitude" , "toleranced_shape_aspect" ,] , "DATA_ENVIRONMENT" => & ["name" , "description" , "elements" ,] , "DATE" => & ["year_component" ,] , "DATE_AND_TIME" => & ["date_component" , "time_component" ,] , "DATE_AND_TIME_ASSIGNMENT" => & ["assigned_date_and_time" , "role" ,] , "DATE_ASSIGNMENT" => & ["assigned_date" , "role" ,] , "DATE_REPRESENTATION_ITEM" => & ["name" , "year_component" ,] , "DATE_ROLE" => & ["name" ,] , "DATE_TIME_REPRESENTATION_ITEM" => & ["name" , "date_component" , "time_component" ,] , "DATE_TIME_ROLE" => & ["name" ,] , "DATED_EFFECTIVITY" => & ["id" , "effectivity_end_date" , "effectivity_start_date" ,] , "DATUM" => & ["name" , "description" , "of_shape" , "product_definitional" , "identification" ,] , "DATUM_FEATURE" => & ["name" , "description" , "of_shape" , "product_definitional" ,] , "DATUM_FEATURE_CALLOUT" => & ["name" , "contents" ,] , "DATUM_REFERENCE" => & ["precedence" , "referenced_datum" ,] , "DATUM_TARGET" => & ["name" , "description" , "of_shape" , "product_definitional" , "target_id" ,] , "DATUM_TARGET_CALLOUT" => & ["name" , "contents" ,] , "DEFAULT_TOLERANCE_TABLE" => & ["name" , "items" , "context_of_items" ,] , "DEFAULT_TOLERANCE_TABLE_CELL" => & ["name" , "item_element" ,] , "DEFINED_SYMBOL" => & ["name" , "definition" , "target" ,] , "DEFINITIONAL_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "DEFINITIONAL_REPRESENTATION_RELATIONSHIP" => & ["name" , "description" , "rep_1" , "rep_2" ,] , "DEFINITIONAL_REPRESENTATION_RELATIONSHIP_WITH_SAME_CONTEXT" => & ["name" , "description" , "rep_1" , "rep_2" ,] , "DEGENERATE_PCURVE" => & ["name" , "basis_surface" , "reference_to_curve" ,] , "DEGENERATE_TOROIDAL_SURFACE" => & ["name" , "position" , "major_radius" , "minor_radius" , "select_outer" ,] , "DERIVED_SHAPE_ASPECT" => & ["name" , "description" , "of_shape" , "product_definitional" ,] , "DERIVED_UNIT" => & ["elements" ,] , "DERIVED_UNIT_ELEMENT" => & ["unit" , "exponent" ,] , "DESCRIPTION_ATTRIBUTE" => & ["attribute_value" , "described_item" ,] , "DESCRIPTIVE_REPRESENTATION_ITEM" => & ["name" , "description" ,] , "DESIGN_CONTEXT" => & ["name" , "frame_of_reference" , "life_cycle_stage" ,] , "DESIGN_MAKE_FROM_RELATIONSHIP" => & ["id" , "name" , "description" , "relating_product_definition" , "related_product_definition" ,] , "DIAMETER_DIMENSION" => & ["name" , "contents" ,] , "DIELECTRIC_CONSTANT_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "DIMENSION_CALLOUT" => & ["name" , "contents" ,] , "DIMENSION_CALLOUT_COMPONENT_RELATIONSHIP" => & ["name" , "description" , "relating_draughting_callout" , "related_draughting_callout" ,] , "DIMENSION_CALLOUT_RELATIONSHIP" => & ["name" , "description" , "relating_draughting_callout" , "related_draughting_callout" ,] , "DIMENSION_CURVE" => & ["name" , "styles" , "item" ,] , "DIMENSION_CURVE_DIRECTED_CALLOUT" => & ["name" , "contents" ,] , "DIMENSION_CURVE_TERMINATOR" => & ["name" , "styles" , "item" , "annotated_curve" , "role" ,] , "DIMENSION_CURVE_TERMINATOR_TO_PROJECTION_CURVE_ASSOCIATIVITY" => & ["name" , "description" , "relating_annotation_occurrence" , "related_annotation_occurrence" ,] , "DIMENSION_PAIR" => & ["name" , "description" , "relating_draughting_callout" , "related_draughting_callout" ,] , "DIMENSION_RELATED_TOLERANCE_ZONE_ELEMENT" => & ["related_dimension" , "related_element" ,] , "DIMENSION_TEXT_ASSOCIATIVITY" => & ["name" , "literal" , "placement" , "alignment" , "path" , "font" , "mapping_source" , "mapping_target" ,] , "DIMENSIONAL_CHARACTERISTIC_REPRESENTATION" => & ["dimension" , "representation" ,] , "DIMENSIONAL_EXPONENTS" => & ["length_exponent" , "mass_exponent" , "time_exponent" , "electric_current_exponent" , "thermodynamic_temperature_exponent" , "amount_of_substance_exponent" , "luminous_intensity_exponent" ,] , "DIMENSIONAL_LOCATION" => & ["name" , "description" , "relating_shape_aspect" , "related_shape_aspect" ,] , "DIMENSIONAL_LOCATION_WITH_PATH" => & ["name" , "description" , "relating_shape_aspect" , "related_shape_aspect" , "path" ,] , "DIMENSIONAL_SIZE" => & ["applies_to" , "name" ,] , "DIMENSIONAL_SIZE_WITH_PATH" => & ["applies_to" , "name" , "path" ,] , "DIRECTED_ACTION" => & ["name" , "description" , "chosen_method" , "directive" ,] , "DIRECTED_DIMENSIONAL_LOCATION" => & ["name" , "description" , "relating_shape_aspect" , "related_shape_aspect" ,] , "DIRECTION" => & ["name" , "direction_ratios" ,] , "DOCUMENT" => & ["id" , "name" , "description" , "kind" ,] , "DOCUMENT_FILE" => & ["id" , "name" , "description" , "kind" ,] , "DOCUMENT_IDENTIFIER" => & ["name" , "description" ,] , "DOCUMENT_IDENTIFIER_ASSIGNMENT" => & ["assigned_group" , "items" ,] , "DOCUMENT_PRODUCT_ASSOCIATION" => & ["name" , "description" , "relating_document" , "related_product" ,] , "DOCUMENT_PRODUCT_EQUIVALENCE" => & ["name" , "description" , "relating_document" , "related_product" ,] , "DOCUMENT_REFERENCE" => & ["assigned_document" , "source" ,] , "DOCUMENT_RELATIONSHIP" => & ["name" , "description" , "relating_document" , "related_document" ,] , "DOCUMENT_REPRESENTATION_TYPE" => & ["name" , "represented_document" ,] , "DOCUMENT_TYPE" => & ["product_data_type" ,] , "DOCUMENT_USAGE_CONSTRAINT" => & ["source" , "subject_element" , "subject_element_value" ,] , "DOCUMENT_USAGE_CONSTRAINT_ASSIGNMENT" => & ["assigned_document_usage" , "role" ,] , "DOCUMENT_USAGE_ROLE" => & ["name" , "description" ,] , "DOSE_EQUIVALENT_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "DOSE_EQUIVALENT_UNIT" => & ["elements" ,] , "DOUBLE_OFFSET_SHELLED_SOLID" => & ["name" , "rationale" , "base_solid" , "deleted_face_set" , "thickness" , "thickness2" ,] , "DRAPED_DEFINED_TRANSFORMATION" => & ["name" , "description" , "transform_item_1" , "transform_item_2" ,] , "DRAUGHTING_ANNOTATION_OCCURRENCE" => & ["name" , "styles" , "item" ,] , "DRAUGHTING_CALLOUT" => & ["name" , "contents" ,] , "DRAUGHTING_CALLOUT_RELATIONSHIP" => & ["name" , "description" , "relating_draughting_callout" , "related_draughting_callout" ,] , "DRAUGHTING_ELEMENTS" => & ["name" , "contents" ,] , "DRAUGHTING_MODEL" => & ["name" , "items" , "context_of_items" ,] , "DRAUGHTING_MODEL_ITEM_ASSOCIATION" => & ["name" , "description" , "definition" , "used_representation" , "identified_item" ,] , "DRAUGHTING_PRE_DEFINED_COLOUR" => & ["name" ,] , "DRAUGHTING_PRE_DEFINED_CURVE_FONT" => & ["name" ,] , "DRAUGHTING_PRE_DEFINED_TEXT_FONT" => & ["name" ,] , "DRAUGHTING_SUBFIGURE_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "DRAUGHTING_SYMBOL_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "DRAUGHTING_TEXT_LITERAL_WITH_DELINEATION" => & ["name" , "literal" , "placement" , "alignment" , "path" , "font" , "delineation" ,] , "DRAUGHTING_TITLE" => & ["items" , "language" , "contents" ,] , "DRAWING_DEFINITION" => & ["drawing_number" , "drawing_type" ,] , "DRAWING_REVISION" => & ["revision_identifier" , "drawing_identifier" , "intended_scale" ,] , "DRAWING_REVISION_SEQUENCE" => & ["predecessor" , "successor" ,] , "DRAWING_SHEET_REVISION" => & ["name" , "items" , "context_of_items" , "revision_identifier" ,] , "DRAWING_SHEET_REVISION_SEQUENCE" => & ["name" , "description" , "rep_1" , "rep_2" ,] , "DRAWING_SHEET_REVISION_USAGE" => & ["area" , "in_set" , "sheet_number" ,] , "EDGE" => & ["name" , "edge_start" , "edge_end" ,] , "EDGE_BASED_WIREFRAME_MODEL" => & ["name" , "ebwm_boundary" ,] , "EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "EDGE_BLENDED_SOLID" => & ["name" , "rationale" , "base_solid" , "blended_edges" ,] , "EDGE_CURVE" => & ["name" , "edge_start" , "edge_end" , "edge_geometry" , "same_sense" ,] , "EDGE_LOOP" => & ["name" , "edge_list" ,] , "EFFECTIVITY" => & ["id" ,] , "EFFECTIVITY_ASSIGNMENT" => & ["assigned_effectivity" ,] , "EFFECTIVITY_CONTEXT_ASSIGNMENT" => & ["assigned_effectivity_assignment" , "role" ,] , "EFFECTIVITY_CONTEXT_ROLE" => & ["name" , "description" ,] , "EFFECTIVITY_RELATIONSHIP" => & ["name" , "description" , "related_effectivity" , "relating_effectivity" ,] , "ELECTRIC_CHARGE_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "ELECTRIC_CHARGE_UNIT" => & ["elements" ,] , "ELECTRIC_CURRENT_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "ELECTRIC_CURRENT_UNIT" => & ["dimensions" ,] , "ELECTRIC_POTENTIAL_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "ELECTRIC_POTENTIAL_UNIT" => & ["elements" ,] , "ELEMENTARY_BREP_SHAPE_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "ELEMENTARY_SURFACE" => & ["name" , "position" ,] , "ELLIPSE" => & ["name" , "position" , "semi_axis_1" , "semi_axis_2" ,] , "ENERGY_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "ENERGY_UNIT" => & ["elements" ,] , "ENTITY_ASSERTION" => & ["name" , "description" , "definition" ,] , "ENUM_REFERENCE_PREFIX" => & ["name" , "description" ,] , "ENVIRONMENT" => & ["syntactic_representation" , "semantics" ,] , "EVALUATED_CHARACTERISTIC" => & ["name" , "items" , "context_of_items" , "description" , "rep_1" , "rep_2" ,] , "EVALUATED_DEGENERATE_PCURVE" => & ["name" , "basis_surface" , "reference_to_curve" , "equivalent_point" ,] , "EVALUATION_PRODUCT_DEFINITION" => & ["id" , "description" , "formation" , "frame_of_reference" ,] , "EVENT_OCCURRENCE" => & ["id" , "name" , "description" ,] , "EVENT_OCCURRENCE_ASSIGNMENT" => & ["assigned_event_occurrence" , "role" ,] , "EVENT_OCCURRENCE_RELATIONSHIP" => & ["name" , "description" , "relating_event" , "related_event" ,] , "EVENT_OCCURRENCE_ROLE" => & ["name" , "description" ,] , "EXCLUSIVE_PRODUCT_CONCEPT_FEATURE_CATEGORY" => & ["name" , "description" ,] , "EXECUTED_ACTION" => & ["name" , "description" , "chosen_method" ,] , "EXPANDED_UNCERTAINTY" => & ["measure_name" , "description" , "uncertainty_value" , "coverage_factor" ,] , "EXPLICIT_PROCEDURAL_GEOMETRIC_REPRESENTATION_ITEM_RELATIONSHIP" => & ["name" , "description" , "relating_representation_item" , "related_representation_item" ,] , "EXPLICIT_PROCEDURAL_REPRESENTATION_ITEM_RELATIONSHIP" => & ["name" , "description" , "relating_representation_item" , "related_representation_item" ,] , "EXPLICIT_PROCEDURAL_REPRESENTATION_RELATIONSHIP" => & ["name" , "description" , "rep_1" , "rep_2" ,] , "EXPLICIT_PROCEDURAL_SHAPE_REPRESENTATION_RELATIONSHIP" => & ["name" , "description" , "rep_1" , "rep_2" ,] , "EXPRESSION" => & [] , "EXPRESSION_CONVERSION_BASED_UNIT" => & ["dimensions" , "name" ,] , "EXTENSION" => & ["name" , "description" , "of_shape" , "product_definitional" ,] , "EXTENT" => & ["name" , "description" ,] , "EXTERNAL_CLASS_LIBRARY" => & ["source_id" ,] , "EXTERNAL_IDENTIFICATION_ASSIGNMENT" => & ["assigned_id" , "role" , "source" ,] , "EXTERNAL_SOURCE" => & ["source_id" ,] , "EXTERNAL_SOURCE_RELATIONSHIP" => & ["name" , "description" , "relating_source" , "related_source" ,] , "EXTERNALLY_DEFINED_CLASS" => & ["name" , "description" , "item_id" , "source" ,] , "EXTERNALLY_DEFINED_COLOUR" => & ["name" , "item_id" , "source" ,] , "EXTERNALLY_DEFINED_CONTEXT_DEPENDENT_UNIT" => & ["dimensions" , "name" , "item_id" , "source" ,] , "EXTERNALLY_DEFINED_CONVERSION_BASED_UNIT" => & ["dimensions" , "name" , "conversion_factor" , "item_id" , "source" ,] , "EXTERNALLY_DEFINED_CURRENCY" => & ["dimensions" , "name" , "item_id" , "source" ,] , "EXTERNALLY_DEFINED_CURVE_FONT" => & ["item_id" , "source" ,] , "EXTERNALLY_DEFINED_DIMENSION_DEFINITION" => & ["applies_to" , "name" , "item_id" , "source" ,] , "EXTERNALLY_DEFINED_GENERAL_PROPERTY" => & ["id" , "name" , "description" , "item_id" , "source" ,] , "EXTERNALLY_DEFINED_HATCH_STYLE" => & ["item_id" , "source" , "name" ,] , "EXTERNALLY_DEFINED_ITEM" => & ["item_id" , "source" ,] , "EXTERNALLY_DEFINED_ITEM_RELATIONSHIP" => & ["name" , "description" , "relating_item" , "related_item" ,] , "EXTERNALLY_DEFINED_MARKER" => & ["item_id" , "source" , "name" ,] , "EXTERNALLY_DEFINED_PICTURE_REPRESENTATION_ITEM" => & ["name" , "binary_value" ,] , "EXTERNALLY_DEFINED_REPRESENTATION_ITEM" => & ["name" , "item_id" , "source" ,] , "EXTERNALLY_DEFINED_STRING" => & ["name" , "item_id" , "source" ,] , "EXTERNALLY_DEFINED_SYMBOL" => & ["item_id" , "source" ,] , "EXTERNALLY_DEFINED_TERMINATOR_SYMBOL" => & ["item_id" , "source" ,] , "EXTERNALLY_DEFINED_TEXT_FONT" => & ["item_id" , "source" ,] , "EXTERNALLY_DEFINED_TILE" => & ["item_id" , "source" ,] , "EXTERNALLY_DEFINED_TILE_STYLE" => & ["item_id" , "source" , "name" ,] , "EXTRUDED_AREA_SOLID" => & ["name" , "swept_area" , "extruded_direction" , "depth" ,] , "EXTRUDED_FACE_SOLID" => & ["name" , "swept_face" , "extruded_direction" , "depth" ,] , "EXTRUDED_FACE_SOLID_WITH_DRAFT_ANGLE" => & ["name" , "swept_face" , "extruded_direction" , "depth" , "first_trim_condition" , "second_trim_condition" , "first_trim_intent" , "second_trim_intent" , "first_offset" , "second_offset" , "draft_angle" ,] , "EXTRUDED_FACE_SOLID_WITH_MULTIPLE_DRAFT_ANGLES" => & ["name" , "swept_face" , "extruded_direction" , "depth" , "first_trim_condition" , "second_trim_condition" , "first_trim_intent" , "second_trim_intent" , "first_offset" , "second_offset" , "drafted_edges" , "draft_angles" ,] , "EXTRUDED_FACE_SOLID_WITH_TRIM_CONDITIONS" => & ["name" , "swept_face" , "extruded_direction" , "depth" , "first_trim_condition" , "second_trim_condition" , "first_trim_intent" , "second_trim_intent" , "first_offset" , "second_offset" ,] , "FACE" => & ["name" , "bounds" ,] , "FACE_BASED_SURFACE_MODEL" => & ["name" , "fbsm_faces" ,] , "FACE_BOUND" => & ["name" , "bound" , "orientation" ,] , "FACE_OUTER_BOUND" => & ["name" , "bound" , "orientation" ,] , "FACE_SURFACE" => & ["name" , "bounds" , "face_geometry" , "same_sense" ,] , "FACETED_BREP" => & ["name" , "outer" ,] , "FACETED_BREP_SHAPE_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "FACT_TYPE" => & ["name" , "description" , "definition" ,] , "FILL_AREA_STYLE" => & ["name" , "fill_styles" ,] , "FILL_AREA_STYLE_COLOUR" => & ["name" , "fill_colour" ,] , "FILL_AREA_STYLE_HATCHING" => & ["name" , "hatch_line_appearance" , "start_of_next_hatch_line" , "point_of_reference_hatch_line" , "pattern_start" , "hatch_line_angle" ,] , "FILL_AREA_STYLE_TILE_COLOURED_REGION" => & ["name" , "closed_curve" , "region_colour" ,] , "FILL_AREA_STYLE_TILE_CURVE_WITH_STYLE" => & ["name" , "styled_curve" ,] , "FILL_AREA_STYLE_TILE_SYMBOL_WITH_STYLE" => & ["name" , "symbol" ,] , "FILL_AREA_STYLE_TILES" => & ["name" , "tiling_pattern" , "tiles" , "tiling_scale" ,] , "FLAT_PATTERN_PLY_REPRESENTATION_RELATIONSHIP" => & ["name" , "description" , "rep_1" , "rep_2" ,] , "FLATNESS_TOLERANCE" => & ["name" , "description" , "magnitude" , "toleranced_shape_aspect" ,] , "FORCE_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "FORCE_UNIT" => & ["elements" ,] , "FORWARD_CHAINING_RULE" => & ["id" , "description" , "formation" , "frame_of_reference" ,] , "FORWARD_CHAINING_RULE_PREMISE" => & ["name" , "description" , "definition" , "used_representation" , "items" , "context_of_items" ,] , "FOUNDED_ITEM" => & [] , "FREQUENCY_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "FREQUENCY_UNIT" => & ["elements" ,] , "FUNC" => & ["name" , "item_element" ,] , "FUNCTIONAL_BREAKDOWN_CONTEXT" => & ["id" , "name" , "description" , "relating_product_definition" , "related_product_definition" ,] , "FUNCTIONAL_ELEMENT_USAGE" => & ["id" , "name" , "description" , "relating_product_definition" , "related_product_definition" ,] , "FUNCTIONALLY_DEFINED_TRANSFORMATION" => & ["name" , "description" ,] , "GENERAL_MATERIAL_PROPERTY" => & ["id" , "name" , "description" ,] , "GENERAL_PROPERTY" => & ["id" , "name" , "description" ,] , "GENERAL_PROPERTY_ASSOCIATION" => & ["name" , "description" , "base_definition" , "derived_definition" ,] , "GENERAL_PROPERTY_RELATIONSHIP" => & ["name" , "description" , "relating_property" , "related_property" ,] , "GENERIC_CHARACTER_GLYPH_SYMBOL" => & ["name" , "items" , "context_of_items" ,] , "GENERIC_EXPRESSION" => & [] , "GENERIC_LITERAL" => & [] , "GENERIC_VARIABLE" => & [] , "GEOMETRIC_ALIGNMENT" => & ["name" , "description" , "of_shape" , "product_definitional" ,] , "GEOMETRIC_CURVE_SET" => & ["name" , "elements" ,] , "GEOMETRIC_INTERSECTION" => & ["name" , "description" , "of_shape" , "product_definitional" ,] , "GEOMETRIC_ITEM_SPECIFIC_USAGE" => & ["name" , "description" , "definition" , "used_representation" , "identified_item" ,] , "GEOMETRIC_MODEL_ELEMENT_RELATIONSHIP" => & ["name" , "description" , "relating_representation_item" , "related_representation_item" ,] , "GEOMETRIC_REPRESENTATION_CONTEXT" => & ["context_identifier" , "context_type" , "coordinate_space_dimension" ,] , "GEOMETRIC_REPRESENTATION_ITEM" => & ["name" ,] , "GEOMETRIC_SET" => & ["name" , "elements" ,] , "GEOMETRIC_TOLERANCE" => & ["name" , "description" , "magnitude" , "toleranced_shape_aspect" ,] , "GEOMETRIC_TOLERANCE_RELATIONSHIP" => & ["name" , "description" , "relating_geometric_tolerance" , "related_geometric_tolerance" ,] , "GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE" => & ["name" , "description" , "magnitude" , "toleranced_shape_aspect" , "datum_system" ,] , "GEOMETRIC_TOLERANCE_WITH_DEFINED_UNIT" => & ["name" , "description" , "magnitude" , "toleranced_shape_aspect" , "unit_size" ,] , "GEOMETRICAL_TOLERANCE_CALLOUT" => & ["name" , "contents" ,] , "GEOMETRICALLY_BOUNDED_2D_WIREFRAME_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "GLOBAL_ASSIGNMENT" => & ["name" , "description" , "relating_representation_item" , "related_representation_item" ,] , "GLOBAL_UNCERTAINTY_ASSIGNED_CONTEXT" => & ["context_identifier" , "context_type" , "uncertainty" ,] , "GLOBAL_UNIT_ASSIGNED_CONTEXT" => & ["context_identifier" , "context_type" , "units" ,] , "GROUND_FACT" => & ["name" , "item_element" ,] , "GROUP" => & ["name" , "description" ,] , "GROUP_ASSIGNMENT" => & ["assigned_group" ,] , "GROUP_RELATIONSHIP" => & ["name" , "description" , "relating_group" , "related_group" ,] , "HALF_SPACE_SOLID" => & ["name" , "base_surface" , "agreement_flag" ,] , "HARDNESS_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "HIDDEN_ELEMENT_OVER_RIDING_STYLED_ITEM" => & ["name" , "styles" , "item" , "over_ridden_style" , "style_context" ,] , "HYPERBOLA" => & ["name" , "position" , "semi_axis" , "semi_imag_axis" ,] , "ID_ATTRIBUTE" => & ["attribute_value" , "identified_item" ,] , "IDENTIFICATION_ASSIGNMENT" => & ["assigned_id" , "role" ,] , "IDENTIFICATION_ROLE" => & ["name" , "description" ,] , "ILLUMINANCE_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "ILLUMINANCE_UNIT" => & ["elements" ,] , "INCLUDED_TEXT_BLOCK" => & ["name" , "mapping_source" , "mapping_target" ,] , "INCLUSION_PRODUCT_CONCEPT_FEATURE" => & ["id" , "name" , "description" , "condition" ,] , "INDIRECTLY_SELECTED_ELEMENTS" => & ["name" , "picked_items" , "indirectly_picked_items" ,] , "INDIRECTLY_SELECTED_SHAPE_ELEMENTS" => & ["name" , "picked_items" , "indirectly_picked_items" ,] , "INDUCTANCE_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "INDUCTANCE_UNIT" => & ["elements" ,] , "INFORMATION_RIGHT" => & ["name" , "description" , "consequence" , "purpose" ,] , "INFORMATION_USAGE_RIGHT" => & ["name" , "description" , "consequence" , "purpose" ,] , "INSTANCE_USAGE_CONTEXT_ASSIGNMENT" => & ["name" , "frame_of_reference" , "life_cycle_stage" , "items" ,] , "INSTANCED_FEATURE" => & ["name" , "description" , "of_shape" , "product_definitional" ,] , "INT_LITERAL" => & ["the_value" ,] , "INTEGER_REPRESENTATION_ITEM" => & ["name" , "the_value" ,] , "INTERSECTION_CURVE" => & ["name" , "curve_3d" , "associated_geometry" , "master_representation" ,] , "INTERVAL_EXPRESSION" => & ["operands" ,] , "INVISIBILITY" => & ["invisible_items" ,] , "ISO_4217_CURRENCY" => & ["dimensions" , "name" ,] , "ITEM_DEFINED_TRANSFORMATION" => & ["name" , "description" , "transform_item_1" , "transform_item_2" ,] , "ITEM_IDENTIFIED_REPRESENTATION_USAGE" => & ["name" , "description" , "definition" , "used_representation" , "identified_item" ,] , "KNOWN_SOURCE" => & ["source_id" , "name" ,] , "LAID_DEFINED_TRANSFORMATION" => & ["name" , "description" , "transform_item_1" , "transform_item_2" ,] , "LAMINATE_TABLE" => & ["id" , "description" , "formation" , "frame_of_reference" ,] , "LANGUAGE" => & ["name" , "description" ,] , "LEADER_CURVE" => & ["name" , "styles" , "item" ,] , "LEADER_DIRECTED_CALLOUT" => & ["name" , "contents" ,] , "LEADER_DIRECTED_DIMENSION" => & ["name" , "contents" ,] , "LEADER_TERMINATOR" => & ["name" , "styles" , "item" , "annotated_curve" ,] , "LENGTH_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "LENGTH_UNIT" => & ["dimensions" ,] , "LIGHT_SOURCE" => & ["name" , "light_colour" ,] , "LIGHT_SOURCE_AMBIENT" => & ["name" , "light_colour" ,] , "LIGHT_SOURCE_DIRECTIONAL" => & ["name" , "light_colour" , "orientation" ,] , "LIGHT_SOURCE_POSITIONAL" => & ["name" , "light_colour" , "position" , "constant_attenuation" , "distance_attenuation" ,] , "LIGHT_SOURCE_SPOT" => & ["name" , "light_colour" , "position" , "orientation" , "concentration_exponent" , "constant_attenuation" , "distance_attenuation" , "spread_angle" ,] , "LIMITS_AND_FITS" => & ["form_variance" , "zone_variance" , "grade" , "source" ,] , "LINE" => & ["name" , "pnt" , "dir" ,] , "LINE_PROFILE_TOLERANCE" => & ["name" , "description" , "magnitude" , "toleranced_shape_aspect" ,] , "LINEAR_DIMENSION" => & ["name" , "contents" ,] , "LITERAL_CONJUNCTION" => & ["name" , "item_element" ,] , "LITERAL_DISJUNCTION" => & ["name" , "item_element" ,] , "LITERAL_NUMBER" => & ["the_value" ,] , "LOCAL_TIME" => & ["hour_component" , "minute_component" , "second_component" , "zone" ,] , "LOGICAL_LITERAL" => & ["lit_value" ,] , "LOGICAL_REPRESENTATION_ITEM" => & ["name" , "lit_value" ,] , "LOOP" => & ["name" ,] , "LOSS_TANGENT_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "LOT_EFFECTIVITY" => & ["id" , "effectivity_lot_id" , "effectivity_lot_size" ,] , "LUMINOUS_FLUX_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "LUMINOUS_FLUX_UNIT" => & ["dimensions" ,] , "LUMINOUS_INTENSITY_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "LUMINOUS_INTENSITY_UNIT" => & ["dimensions" ,] , "MAGNETIC_FLUX_DENSITY_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "MAGNETIC_FLUX_DENSITY_UNIT" => & ["elements" ,] , "MAGNETIC_FLUX_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "MAGNETIC_FLUX_UNIT" => & ["elements" ,] , "MAKE_FROM_USAGE_OPTION" => & ["id" , "name" , "description" , "relating_product_definition" , "related_product_definition" , "ranking" , "ranking_rationale" , "quantity" ,] , "MANIFOLD_SOLID_BREP" => & ["name" , "outer" ,] , "MANIFOLD_SUBSURFACE_SHAPE_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "MANIFOLD_SURFACE_SHAPE_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "MAPPED_ITEM" => & ["name" , "mapping_source" , "mapping_target" ,] , "MASS_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "MASS_UNIT" => & ["dimensions" ,] , "MATERIAL_DESIGNATION" => & ["name" , "definitions" ,] , "MATERIAL_DESIGNATION_CHARACTERIZATION" => & ["name" , "description" , "designation" , "property" ,] , "MATERIAL_PROPERTY" => & ["name" , "description" , "definition" ,] , "MATERIAL_PROPERTY_REPRESENTATION" => & ["definition" , "used_representation" , "dependent_environment" ,] , "MEASURE_QUALIFICATION" => & ["name" , "description" , "qualified_measure" , "qualifiers" ,] , "MEASURE_REPRESENTATION_ITEM" => & ["name" , "value_component" , "unit_component" ,] , "MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "MECHANICAL_CONTEXT" => & ["name" , "frame_of_reference" , "discipline_type" ,] , "MECHANICAL_DESIGN_AND_DRAUGHTING_RELATIONSHIP" => & ["name" , "description" , "rep_1" , "rep_2" ,] , "MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_AREA" => & ["name" , "items" , "context_of_items" ,] , "MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "MECHANICAL_DESIGN_PRESENTATION_REPRESENTATION_WITH_DRAUGHTING" => & ["name" , "items" , "context_of_items" ,] , "MECHANICAL_DESIGN_SHADED_PRESENTATION_AREA" => & ["name" , "items" , "context_of_items" ,] , "MECHANICAL_DESIGN_SHADED_PRESENTATION_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "MIN_AND_MAJOR_PLY_ORIENTATION_BASIS" => & ["name" , "description" , "relating_representation_item" , "related_representation_item" ,] , "MODIFIED_GEOMETRIC_TOLERANCE" => & ["name" , "description" , "magnitude" , "toleranced_shape_aspect" , "modifier" ,] , "MODIFIED_SOLID" => & ["name" , "rationale" , "base_solid" ,] , "MODIFIED_SOLID_WITH_PLACED_CONFIGURATION" => & ["name" , "rationale" , "base_solid" , "placing" ,] , "MOMENTS_OF_INERTIA_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "MULTI_LANGUAGE_ATTRIBUTE_ASSIGNMENT" => & ["attribute_name" , "attribute_value" , "role" , "items" ,] , "MULTIPLE_ARITY_BOOLEAN_EXPRESSION" => & ["operands" ,] , "MULTIPLE_ARITY_GENERIC_EXPRESSION" => & ["operands" ,] , "MULTIPLE_ARITY_NUMERIC_EXPRESSION" => & ["operands" ,] , "NAME_ASSIGNMENT" => & ["assigned_name" ,] , "NAME_ATTRIBUTE" => & ["attribute_value" , "named_item" ,] , "NAMED_UNIT" => & ["dimensions" ,] , "NEXT_ASSEMBLY_USAGE_OCCURRENCE" => & ["id" , "name" , "description" , "relating_product_definition" , "related_product_definition" , "reference_designator" ,] , "NON_MANIFOLD_SURFACE_SHAPE_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "NULL_REPRESENTATION_ITEM" => & ["name" ,] , "NUMERIC_EXPRESSION" => & [] , "OBJECT_ROLE" => & ["name" , "description" ,] , "OFFSET_CURVE_2D" => & ["name" , "basis_curve" , "distance" , "self_intersect" ,] , "OFFSET_CURVE_3D" => & ["name" , "basis_curve" , "distance" , "self_intersect" , "ref_direction" ,] , "OFFSET_SURFACE" => & ["name" , "basis_surface" , "distance" , "self_intersect" ,] , "ONE_DIRECTION_REPEAT_FACTOR" => & ["name" , "repeat_factor" ,] , "OPEN_SHELL" => & ["name" , "cfs_faces" ,] , "ORDINAL_DATE" => & ["year_component" , "day_component" ,] , "ORDINATE_DIMENSION" => & ["name" , "contents" ,] , "ORGANIZATION" => & ["id" , "name" , "description" ,] , "ORGANIZATION_ASSIGNMENT" => & ["assigned_organization" , "role" ,] , "ORGANIZATION_RELATIONSHIP" => & ["name" , "description" , "relating_organization" , "related_organization" ,] , "ORGANIZATION_ROLE" => & ["name" ,] , "ORGANIZATIONAL_ADDRESS" => & ["internal_location" , "street_number" , "street" , "postal_box" , "town" , "region" , "postal_code" , "country" , "facsimile_number" , "telephone_number" , "electronic_mail_address" , "telex_number" , "organizations" , "description" ,] , "ORGANIZATIONAL_PROJECT" => & ["name" , "description" , "responsible_organizations" ,] , "ORGANIZATIONAL_PROJECT_ASSIGNMENT" => & ["assigned_organizational_project" , "role" ,] , "ORGANIZATIONAL_PROJECT_RELATIONSHIP" => & ["name" , "description" , "relating_organizational_project" , "related_organizational_project" ,] , "ORGANIZATIONAL_PROJECT_ROLE" => & ["name" , "description" ,] , "ORIENTED_CLOSED_SHELL" => & ["name" , "cfs_faces" , "closed_shell_element" , "orientation" ,] , "ORIENTED_EDGE" => & ["name" , "edge_start" , "edge_end" , "edge_element" , "orientation" ,] , "ORIENTED_FACE" => & ["name" , "bounds" , "face_element" , "orientation" ,] , "ORIENTED_OPEN_SHELL" => & ["name" , "cfs_faces" , "open_shell_element" , "orientation" ,] , "ORIENTED_PATH" => & ["name" , "edge_list" , "path_element" , "orientation" ,] , "ORIENTED_SURFACE" => & ["name" , "orientation" ,] , "OUTER_BOUNDARY_CURVE" => & ["name" , "segments" , "self_intersect" ,] , "OVER_RIDING_STYLED_ITEM" => & ["name" , "styles" , "item" , "over_ridden_style" ,] , "PACKAGE_PRODUCT_CONCEPT_FEATURE" => & ["id" , "name" , "description" ,] , "PARABOLA" => & ["name" , "position" , "focal_dist" ,] , "PARALLEL_OFFSET" => & ["name" , "description" , "of_shape" , "product_definitional" , "offset" ,] , "PARALLELISM_TOLERANCE" => & ["name" , "description" , "magnitude" , "toleranced_shape_aspect" , "datum_system" ,] , "PARAMETRIC_REPRESENTATION_CONTEXT" => & ["context_identifier" , "context_type" ,] , "PART_LAMINATE_TABLE" => & ["id" , "description" , "formation" , "frame_of_reference" ,] , "PARTIAL_DOCUMENT_WITH_STRUCTURED_TEXT_REPRESENTATION_ASSIGNMENT" => & ["assigned_document_usage" , "role" , "items" , "name" , "description" ,] , "PATH" => & ["name" , "edge_list" ,] , "PCURVE" => & ["name" , "basis_surface" , "reference_to_curve" ,] , "PERCENTAGE_LAMINATE_DEFINITION" => & ["id" , "description" , "formation" , "frame_of_reference" ,] , "PERCENTAGE_LAMINATE_TABLE" => & ["id" , "description" , "formation" , "frame_of_reference" ,] , "PERCENTAGE_PLY_DEFINITION" => & ["id" , "description" , "formation" , "frame_of_reference" ,] , "PERPENDICULAR_TO" => & ["name" , "description" , "of_shape" , "product_definitional" ,] , "PERPENDICULARITY_TOLERANCE" => & ["name" , "description" , "magnitude" , "toleranced_shape_aspect" , "datum_system" ,] , "PERSON" => & ["id" , "last_name" , "first_name" , "middle_names" , "prefix_titles" , "suffix_titles" ,] , "PERSON_AND_ORGANIZATION" => & ["the_person" , "the_organization" ,] , "PERSON_AND_ORGANIZATION_ADDRESS" => & ["internal_location" , "street_number" , "street" , "postal_box" , "town" , "region" , "postal_code" , "country" , "facsimile_number" , "telephone_number" , "electronic_mail_address" , "telex_number" , "organizations" , "description" , "people" ,] , "PERSON_AND_ORGANIZATION_ASSIGNMENT" => & ["assigned_person_and_organization" , "role" ,] , "PERSON_AND_ORGANIZATION_ROLE" => & ["name" ,] , "PERSONAL_ADDRESS" => & ["internal_location" , "street_number" , "street" , "postal_box" , "town" , "region" , "postal_code" , "country" , "facsimile_number" , "telephone_number" , "electronic_mail_address" , "telex_number" , "people" , "description" ,] , "PHYSICAL_BREAKDOWN_CONTEXT" => & ["id" , "name" , "description" , "relating_product_definition" , "related_product_definition" ,] , "PHYSICAL_ELEMENT_USAGE" => & ["id" , "name" , "description" , "relating_product_definition" , "related_product_definition" ,] , "PICTURE_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "PICTURE_REPRESENTATION_ITEM" => & ["name" , "binary_value" ,] , "PLACED_DATUM_TARGET_FEATURE" => & ["name" , "description" , "of_shape" , "product_definitional" , "target_id" ,] , "PLACED_FEATURE" => & ["name" , "description" , "of_shape" , "product_definitional" ,] , "PLACEMENT" => & ["name" , "location" ,] , "PLANAR_BOX" => & ["name" , "size_in_x" , "size_in_y" , "placement" ,] , "PLANAR_EXTENT" => & ["name" , "size_in_x" , "size_in_y" ,] , "PLANE" => & ["name" , "position" ,] , "PLANE_ANGLE_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "PLANE_ANGLE_UNIT" => & ["dimensions" ,] , "PLUS_MINUS_TOLERANCE" => & ["range" , "toleranced_dimension" ,] , "PLY_LAMINATE_DEFINITION" => & ["id" , "description" , "formation" , "frame_of_reference" ,] , "PLY_LAMINATE_SEQUENCE_DEFINITION" => & ["id" , "description" , "formation" , "frame_of_reference" ,] , "PLY_LAMINATE_TABLE" => & ["id" , "description" , "formation" , "frame_of_reference" ,] , "POINT" => & ["name" ,] , "POINT_AND_VECTOR" => & ["name" , "item_element" ,] , "POINT_ON_CURVE" => & ["name" , "basis_curve" , "point_parameter" ,] , "POINT_ON_SURFACE" => & ["name" , "basis_surface" , "point_parameter_u" , "point_parameter_v" ,] , "POINT_PATH" => & ["name" , "item_element" ,] , "POINT_REPLICA" => & ["name" , "parent_pt" , "transformation" ,] , "POINT_STYLE" => & ["name" , "marker" , "marker_size" , "marker_colour" ,] , "POLAR_COMPLEX_NUMBER_LITERAL" => & ["radius" , "angle" ,] , "POLY_LOOP" => & ["name" , "polygon" ,] , "POLYLINE" => & ["name" , "points" ,] , "POSITION_TOLERANCE" => & ["name" , "description" , "magnitude" , "toleranced_shape_aspect" ,] , "POSITIONED_SKETCH" => & ["name" , "sketch_basis" , "auxiliary_elements" ,] , "POWER_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "POWER_UNIT" => & ["elements" ,] , "PRE_DEFINED_COLOUR" => & ["name" ,] , "PRE_DEFINED_CURVE_FONT" => & ["name" ,] , "PRE_DEFINED_DIMENSION_SYMBOL" => & ["name" ,] , "PRE_DEFINED_GEOMETRICAL_TOLERANCE_SYMBOL" => & ["name" ,] , "PRE_DEFINED_ITEM" => & ["name" ,] , "PRE_DEFINED_MARKER" => & ["name" ,] , "PRE_DEFINED_POINT_MARKER_SYMBOL" => & ["name" ,] , "PRE_DEFINED_SURFACE_CONDITION_SYMBOL" => & ["name" ,] , "PRE_DEFINED_SURFACE_SIDE_STYLE" => & ["name" ,] , "PRE_DEFINED_SYMBOL" => & ["name" ,] , "PRE_DEFINED_TERMINATOR_SYMBOL" => & ["name" ,] , "PRE_DEFINED_TEXT_FONT" => & ["name" ,] , "PRE_DEFINED_TILE" => & ["name" ,] , "PRECISION_QUALIFIER" => & ["precision_value" ,] , "PREDEFINED_PICTURE_REPRESENTATION_ITEM" => & ["name" , "binary_value" ,] , "PRESENTATION_AREA" => & ["name" , "items" , "context_of_items" ,] , "PRESENTATION_LAYER_ASSIGNMENT" => & ["name" , "description" , "assigned_items" ,] , "PRESENTATION_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "PRESENTATION_SET" => & [] , "PRESENTATION_SIZE" => & ["unit" , "size" ,] , "PRESENTATION_STYLE_ASSIGNMENT" => & ["styles" ,] , "PRESENTATION_STYLE_BY_CONTEXT" => & ["styles" , "style_context" ,] , "PRESENTATION_VIEW" => & ["name" , "items" , "context_of_items" ,] , "PRESENTED_ITEM" => & [] , "PRESENTED_ITEM_REPRESENTATION" => & ["presentation" , "item" ,] , "PRESSURE_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "PRESSURE_UNIT" => & ["elements" ,] , "PROCEDURAL_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "PROCEDURAL_REPRESENTATION_SEQUENCE" => & ["name" , "elements" , "suppressed_items" , "rationale" ,] , "PROCEDURAL_SHAPE_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "PROCEDURAL_SHAPE_REPRESENTATION_SEQUENCE" => & ["name" , "elements" , "suppressed_items" , "rationale" ,] , "PRODUCT" => & ["id" , "name" , "description" , "frame_of_reference" ,] , "PRODUCT_CATEGORY" => & ["name" , "description" ,] , "PRODUCT_CLASS" => & ["id" , "name" , "description" , "market_context" ,] , "PRODUCT_CONCEPT" => & ["id" , "name" , "description" , "market_context" ,] , "PRODUCT_CONCEPT_CONTEXT" => & ["name" , "frame_of_reference" , "market_segment_type" ,] , "PRODUCT_CONCEPT_FEATURE" => & ["id" , "name" , "description" ,] , "PRODUCT_CONCEPT_FEATURE_ASSOCIATION" => & ["name" , "description" , "concept" , "feature" ,] , "PRODUCT_CONCEPT_FEATURE_CATEGORY" => & ["name" , "description" ,] , "PRODUCT_CONCEPT_FEATURE_CATEGORY_USAGE" => & ["assigned_group" , "items" ,] , "PRODUCT_CONCEPT_RELATIONSHIP" => & ["name" , "description" , "relating_product_concept" , "related_product_concept" ,] , "PRODUCT_CONTEXT" => & ["name" , "frame_of_reference" , "discipline_type" ,] , "PRODUCT_DEFINITION" => & ["id" , "description" , "formation" , "frame_of_reference" ,] , "PRODUCT_DEFINITION_CONTEXT" => & ["name" , "frame_of_reference" , "life_cycle_stage" ,] , "PRODUCT_DEFINITION_CONTEXT_ASSOCIATION" => & ["definition" , "frame_of_reference" , "role" ,] , "PRODUCT_DEFINITION_CONTEXT_ROLE" => & ["name" , "description" ,] , "PRODUCT_DEFINITION_EFFECTIVITY" => & ["id" , "usage" ,] , "PRODUCT_DEFINITION_ELEMENT_RELATIONSHIP" => & ["name" , "description" ,] , "PRODUCT_DEFINITION_FORMATION" => & ["id" , "description" , "of_product" ,] , "PRODUCT_DEFINITION_FORMATION_RELATIONSHIP" => & ["id" , "name" , "description" , "relating_product_definition_formation" , "related_product_definition_formation" ,] , "PRODUCT_DEFINITION_FORMATION_WITH_SPECIFIED_SOURCE" => & ["id" , "description" , "of_product" , "make_or_buy" ,] , "PRODUCT_DEFINITION_GROUP_ASSIGNMENT" => & ["assigned_group" , "items" ,] , "PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP" => & ["name" , "description" , "occurrence" , "occurrence_usage" ,] , "PRODUCT_DEFINITION_RELATIONSHIP" => & ["id" , "name" , "description" , "relating_product_definition" , "related_product_definition" ,] , "PRODUCT_DEFINITION_SHAPE" => & ["name" , "description" , "definition" ,] , "PRODUCT_DEFINITION_SUBSTITUTE" => & ["description" , "context_relationship" , "substitute_definition" ,] , "PRODUCT_DEFINITION_USAGE" => & ["id" , "name" , "description" , "relating_product_definition" , "related_product_definition" ,] , "PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS" => & ["id" , "description" , "formation" , "frame_of_reference" , "documentation_ids" ,] , "PRODUCT_IDENTIFICATION" => & ["id" , "name" , "description" , "item_concept" , "purpose" ,] , "PRODUCT_MATERIAL_COMPOSITION_RELATIONSHIP" => & ["id" , "name" , "description" , "relating_product_definition" , "related_product_definition" , "class" , "constituent_amount" , "composition_basis" , "determination_method" ,] , "PRODUCT_RELATED_PRODUCT_CATEGORY" => & ["name" , "description" , "products" ,] , "PRODUCT_SPECIFICATION" => & ["id" , "name" , "description" , "item_concept" , "purpose" , "item_concept_feature" ,] , "PROJECTED_ZONE_DEFINITION" => & ["zone" , "boundaries" , "projection_end" , "projected_length" ,] , "PROJECTION_CURVE" => & ["name" , "styles" , "item" ,] , "PROJECTION_DIRECTED_CALLOUT" => & ["name" , "contents" ,] , "PROMISSORY_USAGE_OCCURRENCE" => & ["id" , "name" , "description" , "relating_product_definition" , "related_product_definition" , "reference_designator" ,] , "PROPERTY_DEFINITION" => & ["name" , "description" , "definition" ,] , "PROPERTY_DEFINITION_RELATIONSHIP" => & ["name" , "description" , "relating_property_definition" , "related_property_definition" ,] , "PROPERTY_DEFINITION_REPRESENTATION" => & ["definition" , "used_representation" ,] , "QUALIFIED_REPRESENTATION_ITEM" => & ["name" , "qualifiers" ,] , "QUALITATIVE_UNCERTAINTY" => & ["measure_name" , "description" , "uncertainty_value" ,] , "QUANTIFIED_ASSEMBLY_COMPONENT_USAGE" => & ["id" , "name" , "description" , "relating_product_definition" , "related_product_definition" , "reference_designator" , "quantity" ,] , "QUASI_UNIFORM_CURVE" => & ["name" , "degree" , "control_points_list" , "curve_form" , "closed_curve" , "self_intersect" ,] , "QUASI_UNIFORM_SURFACE" => & ["name" , "u_degree" , "v_degree" , "control_points_list" , "surface_form" , "u_closed" , "v_closed" , "self_intersect" ,] , "RADIOACTIVITY_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "RADIOACTIVITY_UNIT" => & ["elements" ,] , "RADIUS_DIMENSION" => & ["name" , "contents" ,] , "RANGE_CHARACTERISTIC" => & ["name" , "items" , "context_of_items" , "description" ,] , "RATIO_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "RATIO_UNIT" => & ["dimensions" ,] , "RATIONAL_B_SPLINE_CURVE" => & ["name" , "degree" , "control_points_list" , "curve_form" , "closed_curve" , "self_intersect" , "weights_data" ,] , "RATIONAL_B_SPLINE_SURFACE" => & ["name" , "u_degree" , "v_degree" , "control_points_list" , "surface_form" , "u_closed" , "v_closed" , "self_intersect" , "weights_data" ,] , "RATIONAL_REPRESENTATION_ITEM" => & ["name" , "operands" ,] , "REAL_LITERAL" => & ["the_value" ,] , "REAL_REPRESENTATION_ITEM" => & ["name" , "the_value" ,] , "RECTANGULAR_COMPOSITE_SURFACE" => & ["name" , "segments" ,] , "RECTANGULAR_TRIMMED_SURFACE" => & ["name" , "basis_surface" , "u1" , "u2" , "v1" , "v2" , "usense" , "vsense" ,] , "REFERENCED_MODIFIED_DATUM" => & ["precedence" , "referenced_datum" , "modifier" ,] , "RELATIVE_EVENT_OCCURRENCE" => & ["id" , "name" , "description" , "base_event" , "offset" ,] , "REP_ITEM_GROUP" => & ["name" , "description" ,] , "REPARAMETRISED_COMPOSITE_CURVE_SEGMENT" => & ["transition" , "same_sense" , "parent_curve" , "param_length" ,] , "REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "REPRESENTATION_CONTEXT" => & ["context_identifier" , "context_type" ,] , "REPRESENTATION_ITEM" => & ["name" ,] , "REPRESENTATION_ITEM_RELATIONSHIP" => & ["name" , "description" , "relating_representation_item" , "related_representation_item" ,] , "REPRESENTATION_MAP" => & ["mapping_origin" , "mapped_representation" ,] , "REPRESENTATION_RELATIONSHIP" => & ["name" , "description" , "rep_1" , "rep_2" ,] , "REPRESENTATION_RELATIONSHIP_WITH_TRANSFORMATION" => & ["name" , "description" , "rep_1" , "rep_2" , "transformation_operator" ,] , "REQUIREMENT_ASSIGNED_OBJECT" => & ["assigned_group" , "items" ,] , "REQUIREMENT_ASSIGNMENT" => & ["name" , "description" ,] , "REQUIREMENT_SOURCE" => & ["name" , "description" ,] , "REQUIREMENT_VIEW_DEFINITION_RELATIONSHIP" => & ["id" , "name" , "description" , "relating_product_definition" , "related_product_definition" ,] , "RESISTANCE_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "RESISTANCE_UNIT" => & ["elements" ,] , "REVOLVED_AREA_SOLID" => & ["name" , "swept_area" , "axis" , "angle" ,] , "REVOLVED_FACE_SOLID" => & ["name" , "swept_face" , "axis" , "angle" ,] , "REVOLVED_FACE_SOLID_WITH_TRIM_CONDITIONS" => & ["name" , "swept_face" , "axis" , "angle" , "first_trim_condition" , "second_trim_condition" ,] , "RIGHT_ANGULAR_WEDGE" => & ["name" , "position" , "x" , "y" , "z" , "ltx" ,] , "RIGHT_CIRCULAR_CONE" => & ["name" , "position" , "height" , "radius" , "semi_angle" ,] , "RIGHT_CIRCULAR_CYLINDER" => & ["name" , "position" , "height" , "radius" ,] , "RIGHT_TO_USAGE_ASSOCIATION" => & ["name" , "description" , "relating_method" , "related_method" ,] , "ROLE_ASSOCIATION" => & ["role" , "item_with_role" ,] , "ROUNDNESS_TOLERANCE" => & ["name" , "description" , "magnitude" , "toleranced_shape_aspect" ,] , "ROW_REPRESENTATION_ITEM" => & ["name" , "item_element" ,] , "ROW_VALUE" => & ["name" , "item_element" ,] , "ROW_VARIABLE" => & ["name" , "description" , "definition" , "used_representation" , "items" , "context_of_items" ,] , "RULE_ACTION" => & ["name" , "description" , "chosen_method" ,] , "RULE_CONDITION" => & ["name" , "item_element" ,] , "RULE_DEFINITION" => & ["id" , "description" , "formation" , "frame_of_reference" ,] , "RULE_SET" => & ["id" , "description" , "formation" , "frame_of_reference" ,] , "RULE_SET_GROUP" => & ["id" , "description" , "formation" , "frame_of_reference" ,] , "RULE_SOFTWARE_DEFINITION" => & ["id" , "description" , "formation" , "frame_of_reference" ,] , "RULE_SUPERSEDED_ASSIGNMENT" => & ["assigned_action" , "items" ,] , "RULE_SUPERSEDENCE" => & ["name" , "description" , "chosen_method" ,] , "RULED_SURFACE_SWEPT_AREA_SOLID" => & ["name" , "swept_area" , "directrix" , "start_param" , "end_param" , "reference_surface" ,] , "RUNOUT_ZONE_DEFINITION" => & ["zone" , "boundaries" , "orientation" ,] , "RUNOUT_ZONE_ORIENTATION" => & ["angle" ,] , "RUNOUT_ZONE_ORIENTATION_REFERENCE_DIRECTION" => & ["angle" , "orientation_defining_relationship" ,] , "SATISFIED_REQUIREMENT" => & ["assigned_group" , "items" ,] , "SATISFIES_REQUIREMENT" => & ["name" , "description" ,] , "SATISFYING_ITEM" => & ["assigned_group" , "items" ,] , "SCALAR_VARIABLE" => & ["name" , "description" , "definition" , "used_representation" , "items" , "context_of_items" ,] , "SCATTERING_PARAMETER" => & ["radius" , "angle" ,] , "SCULPTURED_SOLID" => & ["name" , "rationale" , "base_solid" , "sculpturing_element" , "positive_side" ,] , "SEAM_CURVE" => & ["name" , "curve_3d" , "associated_geometry" , "master_representation" ,] , "SECURITY_CLASSIFICATION" => & ["name" , "purpose" , "security_level" ,] , "SECURITY_CLASSIFICATION_ASSIGNMENT" => & ["assigned_security_classification" ,] , "SECURITY_CLASSIFICATION_LEVEL" => & ["name" ,] , "SERIAL_NUMBERED_EFFECTIVITY" => & ["id" , "effectivity_start_id" , "effectivity_end_id" ,] , "SHAPE_ASPECT" => & ["name" , "description" , "of_shape" , "product_definitional" ,] , "SHAPE_ASPECT_ASSOCIATIVITY" => & ["name" , "description" , "relating_shape_aspect" , "related_shape_aspect" ,] , "SHAPE_ASPECT_DERIVING_RELATIONSHIP" => & ["name" , "description" , "relating_shape_aspect" , "related_shape_aspect" ,] , "SHAPE_ASPECT_RELATIONSHIP" => & ["name" , "description" , "relating_shape_aspect" , "related_shape_aspect" ,] , "SHAPE_DEFINITION_REPRESENTATION" => & ["definition" , "used_representation" ,] , "SHAPE_DIMENSION_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "SHAPE_FEATURE_DEFINITION" => & ["name" , "description" ,] , "SHAPE_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "SHAPE_REPRESENTATION_RELATIONSHIP" => & ["name" , "description" , "rep_1" , "rep_2" ,] , "SHAPE_REPRESENTATION_WITH_PARAMETERS" => & ["name" , "items" , "context_of_items" ,] , "SHELL_BASED_SURFACE_MODEL" => & ["name" , "sbsm_boundary" ,] , "SHELL_BASED_WIREFRAME_MODEL" => & ["name" , "sbwm_boundary" ,] , "SHELL_BASED_WIREFRAME_SHAPE_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "SHELLED_SOLID" => & ["name" , "rationale" , "base_solid" , "deleted_face_set" , "thickness" ,] , "SI_ABSORBED_DOSE_UNIT" => & ["elements" , "dimensions" , "prefix" , "name" ,] , "SI_CAPACITANCE_UNIT" => & ["elements" , "dimensions" , "prefix" , "name" ,] , "SI_CONDUCTANCE_UNIT" => & ["elements" , "dimensions" , "prefix" , "name" ,] , "SI_DOSE_EQUIVALENT_UNIT" => & ["elements" , "dimensions" , "prefix" , "name" ,] , "SI_ELECTRIC_CHARGE_UNIT" => & ["elements" , "dimensions" , "prefix" , "name" ,] , "SI_ELECTRIC_POTENTIAL_UNIT" => & ["elements" , "dimensions" , "prefix" , "name" ,] , "SI_ENERGY_UNIT" => & ["elements" , "dimensions" , "prefix" , "name" ,] , "SI_FORCE_UNIT" => & ["elements" , "dimensions" , "prefix" , "name" ,] , "SI_FREQUENCY_UNIT" => & ["elements" , "dimensions" , "prefix" , "name" ,] , "SI_ILLUMINANCE_UNIT" => & ["elements" , "dimensions" , "prefix" , "name" ,] , "SI_INDUCTANCE_UNIT" => & ["elements" , "dimensions" , "prefix" , "name" ,] , "SI_MAGNETIC_FLUX_DENSITY_UNIT" => & ["elements" , "dimensions" , "prefix" , "name" ,] , "SI_MAGNETIC_FLUX_UNIT" => & ["elements" , "dimensions" , "prefix" , "name" ,] , "SI_POWER_UNIT" => & ["elements" , "dimensions" , "prefix" , "name" ,] , "SI_PRESSURE_UNIT" => & ["elements" , "dimensions" , "prefix" , "name" ,] , "SI_RADIOACTIVITY_UNIT" => & ["elements" , "dimensions" , "prefix" , "name" ,] , "SI_RESISTANCE_UNIT" => & ["elements" , "dimensions" , "prefix" , "name" ,] , "SI_UNIT" => & ["dimensions" , "prefix" , "name" ,] , "SIMPLE_BOOLEAN_EXPRESSION" => & [] , "SIMPLE_CLAUSE" => & ["name" , "item_element" ,] , "SIMPLE_GENERIC_EXPRESSION" => & [] , "SIMPLE_NUMERIC_EXPRESSION" => & [] , "SLASH_EXPRESSION" => & ["operands" ,] , "SMEARED_MATERIAL_DEFINITION" => & ["id" , "description" , "formation" , "frame_of_reference" ,] , "SOLID_ANGLE_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "SOLID_ANGLE_UNIT" => & ["dimensions" ,] , "SOLID_CURVE_FONT" => & ["name" ,] , "SOLID_MODEL" => & ["name" ,] , "SOLID_REPLICA" => & ["name" , "parent_solid" , "transformation" ,] , "SOLID_WITH_ANGLE_BASED_CHAMFER" => & ["name" , "rationale" , "base_solid" , "blended_edges" , "offset_distance" , "left_offset" , "offset_angle" ,] , "SOLID_WITH_CHAMFERED_EDGES" => & ["name" , "rationale" , "base_solid" , "blended_edges" ,] , "SOLID_WITH_CIRCULAR_PATTERN" => & ["name" , "rationale" , "base_solid" , "placing" , "replicated_element" , "replicate_count" , "angular_spacing" , "radial_alignment" , "reference_point" ,] , "SOLID_WITH_CIRCULAR_POCKET" => & ["name" , "rationale" , "base_solid" , "placing" , "depth" , "floor_blend_radius" , "draft_angle" , "pocket_radius" ,] , "SOLID_WITH_CIRCULAR_PROTRUSION" => & ["name" , "rationale" , "base_solid" , "placing" , "protrusion_height" , "protrusion_draft_angle" , "protrusion_radius" ,] , "SOLID_WITH_CONICAL_BOTTOM_ROUND_HOLE" => & ["name" , "rationale" , "base_solid" , "placing" , "depth" , "segments" , "segment_radii" , "segment_depths" , "semi_apex_angle" , "tip_radius" ,] , "SOLID_WITH_CONSTANT_RADIUS_EDGE_BLEND" => & ["name" , "rationale" , "base_solid" , "blended_edges" , "radius" ,] , "SOLID_WITH_CURVED_SLOT" => & ["name" , "rationale" , "base_solid" , "placing" , "depth" , "slot_width" , "closed_ends" , "end_exit_faces" , "slot_centreline" ,] , "SOLID_WITH_DEPRESSION" => & ["name" , "rationale" , "base_solid" , "placing" , "depth" ,] , "SOLID_WITH_DOUBLE_OFFSET_CHAMFER" => & ["name" , "rationale" , "base_solid" , "blended_edges" , "left_offset_distance" , "right_offset_distance" ,] , "SOLID_WITH_FLAT_BOTTOM_ROUND_HOLE" => & ["name" , "rationale" , "base_solid" , "placing" , "depth" , "segments" , "segment_radii" , "segment_depths" , "fillet_radius" ,] , "SOLID_WITH_GENERAL_POCKET" => & ["name" , "rationale" , "base_solid" , "placing" , "depth" , "floor_blend_radius" , "draft_angle" , "profile" , "reference_point" ,] , "SOLID_WITH_GENERAL_PROTRUSION" => & ["name" , "rationale" , "base_solid" , "placing" , "protrusion_height" , "protrusion_draft_angle" , "profile" , "reference_point" ,] , "SOLID_WITH_GROOVE" => & ["name" , "rationale" , "base_solid" , "placing" , "depth" , "groove_radius" , "groove_width" , "draft_angle" , "floor_fillet_radius" , "external_groove" ,] , "SOLID_WITH_HOLE" => & ["name" , "rationale" , "base_solid" , "placing" , "depth" ,] , "SOLID_WITH_INCOMPLETE_CIRCULAR_PATTERN" => & ["name" , "rationale" , "base_solid" , "placing" , "replicated_element" , "replicate_count" , "angular_spacing" , "radial_alignment" , "reference_point" , "omitted_instances" ,] , "SOLID_WITH_INCOMPLETE_RECTANGULAR_PATTERN" => & ["name" , "rationale" , "base_solid" , "placing" , "replicated_element" , "row_count" , "column_count" , "row_spacing" , "column_spacing" , "omitted_instances" ,] , "SOLID_WITH_POCKET" => & ["name" , "rationale" , "base_solid" , "placing" , "depth" , "floor_blend_radius" , "draft_angle" ,] , "SOLID_WITH_PROTRUSION" => & ["name" , "rationale" , "base_solid" , "placing" , "protrusion_height" , "protrusion_draft_angle" ,] , "SOLID_WITH_RECTANGULAR_PATTERN" => & ["name" , "rationale" , "base_solid" , "placing" , "replicated_element" , "row_count" , "column_count" , "row_spacing" , "column_spacing" ,] , "SOLID_WITH_RECTANGULAR_POCKET" => & ["name" , "rationale" , "base_solid" , "placing" , "depth" , "floor_blend_radius" , "draft_angle" , "pocket_length" , "pocket_width" , "corner_radius" ,] , "SOLID_WITH_RECTANGULAR_PROTRUSION" => & ["name" , "rationale" , "base_solid" , "placing" , "protrusion_height" , "protrusion_draft_angle" , "protrusion_length" , "protrusion_width" , "protrusion_corner_radius" ,] , "SOLID_WITH_SHAPE_ELEMENT_PATTERN" => & ["name" , "rationale" , "base_solid" , "placing" , "replicated_element" ,] , "SOLID_WITH_SINGLE_OFFSET_CHAMFER" => & ["name" , "rationale" , "base_solid" , "blended_edges" , "offset_distance" ,] , "SOLID_WITH_SLOT" => & ["name" , "rationale" , "base_solid" , "placing" , "depth" , "slot_width" , "closed_ends" , "end_exit_faces" ,] , "SOLID_WITH_SPHERICAL_BOTTOM_ROUND_HOLE" => & ["name" , "rationale" , "base_solid" , "placing" , "depth" , "segments" , "segment_radii" , "segment_depths" , "sphere_radius" ,] , "SOLID_WITH_STEPPED_ROUND_HOLE" => & ["name" , "rationale" , "base_solid" , "placing" , "depth" , "segments" , "segment_radii" , "segment_depths" ,] , "SOLID_WITH_STEPPED_ROUND_HOLE_AND_CONICAL_TRANSITIONS" => & ["name" , "rationale" , "base_solid" , "placing" , "depth" , "segments" , "segment_radii" , "segment_depths" , "conical_transitions" ,] , "SOLID_WITH_STRAIGHT_SLOT" => & ["name" , "rationale" , "base_solid" , "placing" , "depth" , "slot_width" , "closed_ends" , "end_exit_faces" , "slot_length" ,] , "SOLID_WITH_TEE_SECTION_SLOT" => & ["name" , "rationale" , "base_solid" , "placing" , "depth" , "slot_width" , "closed_ends" , "end_exit_faces" , "tee_section_width" , "collar_depth" ,] , "SOLID_WITH_THROUGH_DEPRESSION" => & ["name" , "rationale" , "base_solid" , "placing" , "depth" , "exit_faces" ,] , "SOLID_WITH_TRAPEZOIDAL_SECTION_SLOT" => & ["name" , "rationale" , "base_solid" , "placing" , "depth" , "slot_width" , "closed_ends" , "end_exit_faces" , "draft_angle" , "floor_fillet_radius" ,] , "SOLID_WITH_VARIABLE_RADIUS_EDGE_BLEND" => & ["name" , "rationale" , "base_solid" , "blended_edges" , "point_list" , "radius_list" , "edge_function_list" ,] , "SOURCE_FOR_REQUIREMENT" => & ["assigned_group" , "items" ,] , "SOURCED_REQUIREMENT" => & ["assigned_group" , "items" ,] , "SPECIFICATION_DEFINITION" => & ["id" , "description" , "formation" , "frame_of_reference" ,] , "SPECIFIED_HIGHER_USAGE_OCCURRENCE" => & ["id" , "name" , "description" , "relating_product_definition" , "related_product_definition" , "reference_designator" , "upper_usage" , "next_usage" ,] , "SPHERE" => & ["name" , "radius" , "centre" ,] , "SPHERICAL_SURFACE" => & ["name" , "position" , "radius" ,] , "STANDARD_UNCERTAINTY" => & ["measure_name" , "description" , "uncertainty_value" ,] , "START_REQUEST" => & ["assigned_action_request" , "items" ,] , "START_WORK" => & ["assigned_action" , "items" ,] , "STRAIGHTNESS_TOLERANCE" => & ["name" , "description" , "magnitude" , "toleranced_shape_aspect" ,] , "STRUCTURED_DIMENSION_CALLOUT" => & ["name" , "contents" ,] , "STRUCTURED_TEXT_COMPOSITION" => & ["name" , "item_element" ,] , "STRUCTURED_TEXT_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "STYLED_ITEM" => & ["name" , "styles" , "item" ,] , "SUBEDGE" => & ["name" , "edge_start" , "edge_end" , "parent_edge" ,] , "SUBFACE" => & ["name" , "bounds" , "parent_face" ,] , "SUPPLIED_PART_RELATIONSHIP" => & ["id" , "name" , "description" , "relating_product_definition" , "related_product_definition" ,] , "SURFACE" => & ["name" ,] , "SURFACE_CONDITION_CALLOUT" => & ["name" , "contents" ,] , "SURFACE_CURVE" => & ["name" , "curve_3d" , "associated_geometry" , "master_representation" ,] , "SURFACE_CURVE_SWEPT_AREA_SOLID" => & ["name" , "swept_area" , "directrix" , "start_param" , "end_param" , "reference_surface" ,] , "SURFACE_OF_LINEAR_EXTRUSION" => & ["name" , "swept_curve" , "extrusion_axis" ,] , "SURFACE_OF_REVOLUTION" => & ["name" , "swept_curve" , "axis_position" ,] , "SURFACE_PATCH" => & ["parent_surface" , "u_transition" , "v_transition" , "u_sense" , "v_sense" ,] , "SURFACE_PROFILE_TOLERANCE" => & ["name" , "description" , "magnitude" , "toleranced_shape_aspect" ,] , "SURFACE_RENDERING_PROPERTIES" => & ["rendered_colour" ,] , "SURFACE_REPLICA" => & ["name" , "parent_surface" , "transformation" ,] , "SURFACE_SIDE_STYLE" => & ["name" , "styles" ,] , "SURFACE_STYLE_BOUNDARY" => & ["style_of_boundary" ,] , "SURFACE_STYLE_CONTROL_GRID" => & ["style_of_control_grid" ,] , "SURFACE_STYLE_FILL_AREA" => & ["fill_area" ,] , "SURFACE_STYLE_PARAMETER_LINE" => & ["style_of_parameter_lines" , "direction_counts" ,] , "SURFACE_STYLE_REFLECTANCE_AMBIENT" => & ["ambient_reflectance" ,] , "SURFACE_STYLE_REFLECTANCE_AMBIENT_DIFFUSE" => & ["ambient_reflectance" , "diffuse_reflectance" ,] , "SURFACE_STYLE_REFLECTANCE_AMBIENT_DIFFUSE_SPECULAR" => & ["ambient_reflectance" , "diffuse_reflectance" , "specular_reflectance" , "specular_exponent" , "specular_colour" ,] , "SURFACE_STYLE_RENDERING" => & ["rendering_method" , "surface_colour" ,] , "SURFACE_STYLE_RENDERING_WITH_PROPERTIES" => & ["rendering_method" , "surface_colour" , "properties" ,] , "SURFACE_STYLE_SEGMENTATION_CURVE" => & ["style_of_segmentation_curve" ,] , "SURFACE_STYLE_SILHOUETTE" => & ["style_of_silhouette" ,] , "SURFACE_STYLE_TRANSPARENT" => & ["transparency" ,] , "SURFACE_STYLE_USAGE" => & ["side" , "style" ,] , "SURFACE_TEXTURE_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "SURFACED_OPEN_SHELL" => & ["name" , "cfs_faces" ,] , "SWEPT_AREA_SOLID" => & ["name" , "swept_area" ,] , "SWEPT_DISK_SOLID" => & ["name" , "directrix" , "radius" , "inner_radius" , "start_param" , "end_param" ,] , "SWEPT_FACE_SOLID" => & ["name" , "swept_face" ,] , "SWEPT_SURFACE" => & ["name" , "swept_curve" ,] , "SYMBOL" => & ["name" ,] , "SYMBOL_COLOUR" => & ["colour_of_symbol" ,] , "SYMBOL_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "SYMBOL_REPRESENTATION_MAP" => & ["mapping_origin" , "mapped_representation" ,] , "SYMBOL_STYLE" => & ["name" , "style_of_symbol" ,] , "SYMBOL_TARGET" => & ["name" , "placement" , "x_scale" , "y_scale" ,] , "SYMMETRIC_SHAPE_ASPECT" => & ["name" , "description" , "of_shape" , "product_definitional" ,] , "SYMMETRY_TOLERANCE" => & ["name" , "description" , "magnitude" , "toleranced_shape_aspect" , "datum_system" ,] , "TABLE_REPRESENTATION_ITEM" => & ["name" , "item_element" ,] , "TACTILE_APPEARANCE_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "TAGGED_TEXT_FORMAT" => & ["context_identifier" , "context_type" ,] , "TAGGED_TEXT_ITEM" => & ["name" , "description" ,] , "TANGENT" => & ["name" , "description" , "of_shape" , "product_definitional" ,] , "TERMINATOR_SYMBOL" => & ["name" , "styles" , "item" , "annotated_curve" ,] , "TEXT_FONT" => & ["id" , "name" , "description" ,] , "TEXT_FONT_FAMILY" => & ["id" , "name" , "description" ,] , "TEXT_FONT_IN_FAMILY" => & ["font" , "family" ,] , "TEXT_LITERAL" => & ["name" , "literal" , "placement" , "alignment" , "path" , "font" ,] , "TEXT_LITERAL_WITH_ASSOCIATED_CURVES" => & ["name" , "literal" , "placement" , "alignment" , "path" , "font" , "associated_curves" ,] , "TEXT_LITERAL_WITH_BLANKING_BOX" => & ["name" , "literal" , "placement" , "alignment" , "path" , "font" , "blanking" ,] , "TEXT_LITERAL_WITH_DELINEATION" => & ["name" , "literal" , "placement" , "alignment" , "path" , "font" , "delineation" ,] , "TEXT_LITERAL_WITH_EXTENT" => & ["name" , "literal" , "placement" , "alignment" , "path" , "font" , "extent" ,] , "TEXT_STRING_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "TEXT_STYLE" => & ["name" , "character_appearance" ,] , "TEXT_STYLE_FOR_DEFINED_FONT" => & ["text_colour" ,] , "TEXT_STYLE_WITH_BOX_CHARACTERISTICS" => & ["name" , "character_appearance" , "characteristics" ,] , "TEXT_STYLE_WITH_MIRROR" => & ["name" , "character_appearance" , "mirror_placement" ,] , "TEXT_STYLE_WITH_SPACING" => & ["name" , "character_appearance" , "character_spacing" ,] , "THERMAL_RESISTANCE_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "THERMAL_RESISTANCE_UNIT" => & ["elements" ,] , "THERMODYNAMIC_TEMPERATURE_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "THERMODYNAMIC_TEMPERATURE_UNIT" => & ["dimensions" ,] , "THICKENED_FACE_SOLID" => & ["name" , "base_element" , "offset1" , "offset2" ,] , "THICKNESS_LAMINATE_DEFINITION" => & ["id" , "description" , "formation" , "frame_of_reference" ,] , "THICKNESS_LAMINATE_TABLE" => & ["id" , "description" , "formation" , "frame_of_reference" ,] , "TIME_INTERVAL" => & ["id" , "name" , "description" ,] , "TIME_INTERVAL_ASSIGNMENT" => & ["assigned_time_interval" , "role" ,] , "TIME_INTERVAL_BASED_EFFECTIVITY" => & ["id" , "effectivity_period" ,] , "TIME_INTERVAL_RELATIONSHIP" => & ["name" , "description" , "relating_time_interval" , "related_time_interval" ,] , "TIME_INTERVAL_ROLE" => & ["name" , "description" ,] , "TIME_INTERVAL_WITH_BOUNDS" => & ["id" , "name" , "description" , "primary_bound" , "secondary_bound" , "duration" ,] , "TIME_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "TIME_UNIT" => & ["dimensions" ,] , "TOLERANCE_VALUE" => & ["lower_bound" , "upper_bound" ,] , "TOLERANCE_ZONE" => & ["name" , "description" , "of_shape" , "product_definitional" , "defining_tolerance" , "form" ,] , "TOLERANCE_ZONE_DEFINITION" => & ["zone" , "boundaries" ,] , "TOLERANCE_ZONE_FORM" => & ["name" ,] , "TOPOLOGICAL_REPRESENTATION_ITEM" => & ["name" ,] , "TOROIDAL_SURFACE" => & ["name" , "position" , "major_radius" , "minor_radius" ,] , "TORUS" => & ["name" , "position" , "major_radius" , "minor_radius" ,] , "TOTAL_RUNOUT_TOLERANCE" => & ["name" , "description" , "magnitude" , "toleranced_shape_aspect" , "datum_system" ,] , "TRACK_BLENDED_SOLID" => & ["name" , "rationale" , "base_solid" , "blended_edges" ,] , "TRACK_BLENDED_SOLID_WITH_END_CONDITIONS" => & ["name" , "rationale" , "base_solid" , "blended_edges" , "end_conditions" ,] , "TRANSFORMATION_WITH_DERIVED_ANGLE" => & ["name" , "description" , "transform_item_1" , "transform_item_2" ,] , "TRIMMED_CURVE" => & ["name" , "basis_curve" , "trim_1" , "trim_2" , "sense_agreement" , "master_representation" ,] , "TWO_DIRECTION_REPEAT_FACTOR" => & ["name" , "repeat_factor" , "second_repeat_factor" ,] , "TYPE_QUALIFIER" => & ["name" ,] , "UNARY_GENERIC_EXPRESSION" => & ["operand" ,] , "UNARY_NUMERIC_EXPRESSION" => & ["operand" ,] , "UNCERTAINTY_ASSIGNED_REPRESENTATION" => & ["name" , "items" , "context_of_items" , "uncertainty" ,] , "UNCERTAINTY_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" , "name" , "description" ,] , "UNCERTAINTY_QUALIFIER" => & ["measure_name" , "description" ,] , "UNIFORM_CURVE" => & ["name" , "degree" , "control_points_list" , "curve_form" , "closed_curve" , "self_intersect" ,] , "UNIFORM_RESOURCE_IDENTIFIER" => & ["name" , "description" ,] , "UNIFORM_SURFACE" => & ["name" , "u_degree" , "v_degree" , "control_points_list" , "surface_form" , "u_closed" , "v_closed" , "self_intersect" ,] , "USAGE_ASSOCIATION" => & ["name" , "description" , "relating_method" , "related_method" ,] , "USER_DEFINED_CURVE_FONT" => & ["name" , "pattern_list" , "mapping_source" , "mapping_target" ,] , "USER_DEFINED_MARKER" => & ["name" , "mapping_source" , "mapping_target" ,] , "USER_DEFINED_TERMINATOR_SYMBOL" => & ["name" , "mapping_source" , "mapping_target" ,] , "USER_SELECTED_ELEMENTS" => & ["name" , "picked_items" ,] , "USER_SELECTED_SHAPE_ELEMENTS" => & ["name" , "picked_items" ,] , "VALUE_RANGE" => & ["name" , "item_element" ,] , "VALUE_REPRESENTATION_ITEM" => & ["name" , "value_component" ,] , "VARIABLE_SEMANTICS" => & [] , "VARIATIONAL_REPRESENTATION_ITEM" => & ["name" ,] , "VECTOR" => & ["name" , "orientation" , "magnitude" ,] , "VECTOR_STYLE" => & ["name" , "curve_font" , "curve_width" , "curve_colour" ,] , "VELOCITY_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "VELOCITY_UNIT" => & ["elements" ,] , "VERSIONED_ACTION_REQUEST" => & ["id" , "version" , "purpose" , "description" ,] , "VERTEX" => & ["name" ,] , "VERTEX_LOOP" => & ["name" , "loop_vertex" ,] , "VERTEX_POINT" => & ["name" , "vertex_geometry" ,] , "VERTEX_SHELL" => & ["name" , "vertex_shell_extent" ,] , "VIEW_VOLUME" => & ["projection_type" , "projection_point" , "view_plane_distance" , "front_plane_distance" , "front_plane_clipping" , "back_plane_distance" , "back_plane_clipping" , "view_volume_sides_clipping" , "view_window" ,] , "VISUAL_APPEARANCE_REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "VOLUME_MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "VOLUME_UNIT" => & ["elements" ,] , "WEEK_OF_YEAR_AND_DAY_DATE" => & ["year_component" , "week_component" , "day_component" ,] , "WIRE_SHELL" => & ["name" , "wire_shell_extent" ,] , "YEAR_MONTH" => & ["year_component" , "month_component" ,] , "ZONE_STRUCTURAL_MAKEUP" => & ["id" , "description" , "formation" , "frame_of_reference" ,] , };
static PARTIALS: ::phf::Map<&'static str, &'static [&'static str]> = ::phf::phf_map! { "ABSORBED_DOSE_MEASURE_WITH_UNIT" => & [] , "ABSORBED_DOSE_UNIT" => & [] , "ABSTRACT_VARIABLE" => & [] , "ACCELERATION_MEASURE_WITH_UNIT" => & [] , "ACCELERATION_UNIT" => & [] , "ACTION" => & ["name" , "description" , "chosen_method" ,] , "ACTION_ASSIGNMENT" => & ["assigned_action" ,] , "ACTION_DIRECTIVE" => & ["name" , "description" , "analysis" , "comment" , "requests" ,] , "ACTION_METHOD" => & ["name" , "description" , "consequence" , "purpose" ,] , "ACTION_METHOD_ASSIGNMENT" => & ["assigned_action_method" , "role" ,] , "ACTION_METHOD_RELATIONSHIP" => & ["name" , "description" , "relating_method" , "related_method" ,] , "ACTION_METHOD_ROLE" => & ["name" , "description" ,] , "ACTION_PROPERTY" => & ["name" , "description" , "definition" ,] , "ACTION_PROPERTY_REPRESENTATION" => & ["name" , "description" , "property" , "representation" ,] , "ACTION_RELATIONSHIP" => & ["name" , "description" , "relating_action" , "related_action" ,] , "ACTION_REQUEST_ASSIGNMENT" => & ["assigned_action_request" ,] , "ACTION_REQUEST_SOLUTION" => & ["method" , "request" ,] , "ACTION_REQUEST_STATUS" => & ["status" , "assigned_request" ,] , "ACTION_STATUS" => & ["status" , "assigned_action" ,] , "ADDRESS" => & ["internal_location" , "street_number" , "street" , "postal_box" , "town" , "region" , "postal_code" , "country" , "facsimile_number" , "telephone_number" , "electronic_mail_address" , "telex_number" ,] , "ADVANCED_BREP_SHAPE_REPRESENTATION" => & [] , "ADVANCED_FACE" => & [] , "ALTERNATE_PRODUCT_RELATIONSHIP" => & ["name" , "definition" , "alternate" , "base" , "basis" ,] , "AMOUNT_OF_SUBSTANCE_MEASURE_WITH_UNIT" => & [] , "AMOUNT_OF_SUBSTANCE_UNIT" => & [] , "ANGLE_DIRECTION_REFERENCE" => & [] , "ANGULAR_DIMENSION" => & [] , "ANGULAR_LOCATION" => & ["angle_selection" ,] , "ANGULAR_SIZE" => & ["angle_selection" ,] , "ANGULARITY_TOLERANCE" => & [] , "ANNOTATION_CURVE_OCCURRENCE" => & [] , "ANNOTATION_FILL_AREA" => & ["boundaries" ,] , "ANNOTATION_FILL_AREA_OCCURRENCE" => & ["fill_style_target" ,] , "ANNOTATION_OCCURRENCE" => & [] , "ANNOTATION_OCCURRENCE_ASSOCIATIVITY" => & [] , "ANNOTATION_OCCURRENCE_RELATIONSHIP" => & ["name" , "description" , "relating_annotation_occurrence" , "related_annotation_occurrence" ,] , "ANNOTATION_PLANE" => & ["elements" ,] , "ANNOTATION_SUBFIGURE_OCCURRENCE" => & [] , "ANNOTATION_SYMBOL" => & [] , "ANNOTATION_SYMBOL_OCCURRENCE" => & [] , "ANNOTATION_TEXT" => & [] , "ANNOTATION_TEXT_CHARACTER" => & ["alignment" ,] , "ANNOTATION_TEXT_OCCURRENCE" => & [] , "APEX" => & [] , "APPLICATION_CONTEXT" => & ["application" ,] , "APPLICATION_CONTEXT_ELEMENT" => & ["name" , "frame_of_reference" ,] , "APPLICATION_PROTOCOL_DEFINITION" => & ["status" , "application_interpreted_model_schema_name" , "application_protocol_year" , "application" ,] , "APPLIED_ACTION_ASSIGNMENT" => & ["items" ,] , "APPLIED_ACTION_METHOD_ASSIGNMENT" => & ["items" ,] , "APPLIED_ACTION_REQUEST_ASSIGNMENT" => & ["items" ,] , "APPLIED_APPROVAL_ASSIGNMENT" => & ["items" ,] , "APPLIED_ATTRIBUTE_CLASSIFICATION_ASSIGNMENT" => & ["items" ,] , "APPLIED_CERTIFICATION_ASSIGNMENT" => & ["items" ,] , "APPLIED_CLASSIFICATION_ASSIGNMENT" => & ["items" ,] , "APPLIED_CONTRACT_ASSIGNMENT" => & ["items" ,] , "APPLIED_DATE_AND_TIME_ASSIGNMENT" => & ["items" ,] , "APPLIED_DATE_ASSIGNMENT" => & ["items" ,] , "APPLIED_DOCUMENT_REFERENCE" => & ["items" ,] , "APPLIED_DOCUMENT_USAGE_CONSTRAINT_ASSIGNMENT" => & ["items" ,] , "APPLIED_EFFECTIVITY_ASSIGNMENT" => & ["items" ,] , "APPLIED_EVENT_OCCURRENCE_ASSIGNMENT" => & ["items" ,] , "APPLIED_EXTERNAL_IDENTIFICATION_ASSIGNMENT" => & ["items" ,] , "APPLIED_GROUP_ASSIGNMENT" => & ["items" ,] , "APPLIED_IDENTIFICATION_ASSIGNMENT" => & ["items" ,] , "APPLIED_NAME_ASSIGNMENT" => & ["item" ,] , "APPLIED_ORGANIZATION_ASSIGNMENT" => & ["items" ,] , "APPLIED_ORGANIZATIONAL_PROJECT_ASSIGNMENT" => & ["items" ,] , "APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT" => & ["items" ,] , "APPLIED_PRESENTED_ITEM" => & ["items" ,] , "APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT" => & ["items" ,] , "APPLIED_TIME_INTERVAL_ASSIGNMENT" => & ["items" ,] , "APPLIED_USAGE_RIGHT" => & [] , "APPROVAL" => & ["status" , "level" ,] , "APPROVAL_ASSIGNMENT" => & ["assigned_approval" ,] , "APPROVAL_DATE_TIME" => & ["date_time" , "dated_approval" ,] , "APPROVAL_PERSON_ORGANIZATION" => & ["person_organization" , "authorized_approval" , "role" ,] , "APPROVAL_RELATIONSHIP" => & ["name" , "description" , "relating_approval" , "related_approval" ,] , "APPROVAL_ROLE" => & ["role" ,] , "APPROVAL_STATUS" => & ["name" ,] , "AREA_IN_SET" => & ["area" , "in_set" ,] , "AREA_MEASURE_WITH_UNIT" => & [] , "AREA_UNIT" => & [] , "ASSEMBLY_COMPONENT_USAGE" => & ["reference_designator" ,] , "ASSEMBLY_COMPONENT_USAGE_SUBSTITUTE" => & ["name" , "definition" , "base" , "substitute" ,] , "ASSIGNED_REQUIREMENT" => & ["items" ,] , "ATOMIC_FORMULA" => & [] , "ATTRIBUTE_ASSERTION" => & [] , "ATTRIBUTE_CLASSIFICATION_ASSIGNMENT" => & ["assigned_class" , "attribute_name" , "role" ,] , "ATTRIBUTE_LANGUAGE_ASSIGNMENT" => & ["items" ,] , "ATTRIBUTE_VALUE_ASSIGNMENT" => & ["attribute_name" , "attribute_value" , "role" ,] , "ATTRIBUTE_VALUE_ROLE" => & ["name" , "description" ,] , "AUXILIARY_GEOMETRIC_REPRESENTATION_ITEM" => & [] , "AXIS1_PLACEMENT" => & ["axis" ,] , "AXIS2_PLACEMENT_2D" => & ["ref_direction" ,] , "AXIS2_PLACEMENT_3D" => & ["axis" , "ref_direction" ,] , "B_SPLINE_CURVE" => & ["degree" , "control_points_list" , "curve_form" , "closed_curve" , "self_intersect" ,] , "B_SPLINE_CURVE_WITH_KNOTS" => & ["knot_multiplicities" , "knots" , "knot_spec" ,] , "B_SPLINE_SURFACE" => & ["u_degree" , "v_degree" , "control_points_list" , "surface_form" , "u_closed" , "v_closed" , "self_intersect" ,] , "B_SPLINE_SURFACE_WITH_KNOTS" => & ["u_multiplicities" , "v_multiplicities" , "u_knots" , "v_knots" , "knot_spec" ,] , "BACK_CHAINING_RULE" => & [] , "BACK_CHAINING_RULE_BODY" => & [] , "BACKGROUND_COLOUR" => & ["presentation" ,] , "BEVELED_SHEET_REPRESENTATION" => & [] , "BEZIER_CURVE" => & [] , "BEZIER_SURFACE" => & [] , "BINARY_GENERIC_EXPRESSION" => & ["operands" ,] , "BINARY_NUMERIC_EXPRESSION" => & [] , "BINARY_REPRESENTATION_ITEM" => & ["binary_value" ,] , "BLOCK" => & ["position" , "x" , "y" , "z" ,] , "BOOLEAN_EXPRESSION" => & [] , "BOOLEAN_LITERAL" => & ["the_value" ,] , "BOOLEAN_REPRESENTATION_ITEM" => & [] , "BOOLEAN_RESULT" => & ["operator" , "first_operand" , "second_operand" ,] , "BOUNDARY_CURVE" => & [] , "BOUNDED_CURVE" => & [] , "BOUNDED_PCURVE" => & [] , "BOUNDED_SURFACE" => & [] , "BOUNDED_SURFACE_CURVE" => & [] , "BOX_DOMAIN" => & ["corner" , "xlength" , "ylength" , "zlength" ,] , "BOXED_HALF_SPACE" => & ["enclosure" ,] , "BREAKDOWN_CONTEXT" => & [] , "BREAKDOWN_ELEMENT_GROUP_ASSIGNMENT" => & ["items" ,] , "BREAKDOWN_ELEMENT_REALIZATION" => & [] , "BREAKDOWN_ELEMENT_USAGE" => & [] , "BREAKDOWN_OF" => & [] , "BREP_WITH_VOIDS" => & ["voids" ,] , "BYTES_REPRESENTATION_ITEM" => & [] , "CALENDAR_DATE" => & ["day_component" , "month_component" ,] , "CAMERA_IMAGE" => & [] , "CAMERA_IMAGE_3D_WITH_SCALE" => & [] , "CAMERA_MODEL" => & [] , "CAMERA_MODEL_D_3" => & ["view_reference_system" , "perspective_of_volume" ,] , "CAMERA_MODEL_D_3_MULTI_CLIPPING" => & ["shape_clipping" ,] , "CAMERA_MODEL_D_3_MULTI_CLIPPING_INTERSECTION" => & ["shape_clipping" ,] , "CAMERA_MODEL_D_3_MULTI_CLIPPING_UNION" => & ["shape_clipping" ,] , "CAMERA_MODEL_D_3_WITH_HLHSR" => & ["hidden_line_surface_removal" ,] , "CAMERA_MODEL_WITH_LIGHT_SOURCES" => & ["sources" ,] , "CAMERA_USAGE" => & [] , "CAPACITANCE_MEASURE_WITH_UNIT" => & [] , "CAPACITANCE_UNIT" => & [] , "CARTESIAN_POINT" => & ["coordinates" ,] , "CARTESIAN_TRANSFORMATION_OPERATOR" => & ["axis1" , "axis2" , "local_origin" , "scale" ,] , "CARTESIAN_TRANSFORMATION_OPERATOR_2D" => & [] , "CARTESIAN_TRANSFORMATION_OPERATOR_3D" => & ["axis3" ,] , "CC_DESIGN_APPROVAL" => & ["items" ,] , "CC_DESIGN_CERTIFICATION" => & ["items" ,] , "CC_DESIGN_CONTRACT" => & ["items" ,] , "CC_DESIGN_DATE_AND_TIME_ASSIGNMENT" => & ["items" ,] , "CC_DESIGN_PERSON_AND_ORGANIZATION_ASSIGNMENT" => & ["items" ,] , "CC_DESIGN_SECURITY_CLASSIFICATION" => & ["items" ,] , "CC_DESIGN_SPECIFICATION_REFERENCE" => & ["items" ,] , "CELSIUS_TEMPERATURE_MEASURE_WITH_UNIT" => & [] , "CENTRE_OF_SYMMETRY" => & [] , "CERTIFICATION" => & ["name" , "purpose" , "kind" ,] , "CERTIFICATION_ASSIGNMENT" => & ["assigned_certification" ,] , "CERTIFICATION_TYPE" => & ["description" ,] , "CHANGE" => & ["items" ,] , "CHANGE_REQUEST" => & ["items" ,] , "CHARACTER_GLYPH_FONT_USAGE" => & ["character" , "font" ,] , "CHARACTER_GLYPH_STYLE_OUTLINE" => & ["outline_style" ,] , "CHARACTER_GLYPH_STYLE_STROKE" => & ["stroke_style" ,] , "CHARACTER_GLYPH_SYMBOL" => & ["character_box" , "baseline_ratio" ,] , "CHARACTER_GLYPH_SYMBOL_OUTLINE" => & ["outlines" ,] , "CHARACTER_GLYPH_SYMBOL_STROKE" => & ["strokes" ,] , "CHARACTERISTIC_DATA_COLUMN_HEADER" => & [] , "CHARACTERISTIC_DATA_COLUMN_HEADER_LINK" => & [] , "CHARACTERISTIC_DATA_TABLE_HEADER" => & [] , "CHARACTERISTIC_DATA_TABLE_HEADER_DECOMPOSITION" => & [] , "CHARACTERISTIC_TYPE" => & [] , "CHARACTERIZED_CLASS" => & [] , "CHARACTERIZED_OBJECT" => & ["name" , "description" ,] , "CIRCLE" => & ["radius" ,] , "CIRCULAR_RUNOUT_TOLERANCE" => & [] , "CLASS" => & [] , "CLASS_BY_EXTENSION" => & [] , "CLASS_BY_INTENSION" => & [] , "CLASS_SYSTEM" => & [] , "CLASS_USAGE_EFFECTIVITY_CONTEXT_ASSIGNMENT" => & ["items" ,] , "CLASSIFICATION_ASSIGNMENT" => & ["assigned_class" , "role" ,] , "CLASSIFICATION_ROLE" => & ["name" , "description" ,] , "CLOSED_SHELL" => & [] , "COAXIALITY_TOLERANCE" => & [] , "COLOUR" => & [] , "COLOUR_RGB" => & ["red" , "green" , "blue" ,] , "COLOUR_SPECIFICATION" => & ["name" ,] , "COMMON_DATUM" => & [] , "COMPARISON_EXPRESSION" => & [] , "COMPLEX_CLAUSE" => & [] , "COMPLEX_CONJUNCTIVE_CLAUSE" => & [] , "COMPLEX_DISJUNCTIVE_CLAUSE" => & [] , "COMPLEX_SHELLED_SOLID" => & ["thickened_face_list" , "thickness_list" ,] , "COMPOSITE_ASSEMBLY_DEFINITION" => & [] , "COMPOSITE_ASSEMBLY_SEQUENCE_DEFINITION" => & [] , "COMPOSITE_ASSEMBLY_TABLE" => & [] , "COMPOSITE_CURVE" => & ["segments" , "self_intersect" ,] , "COMPOSITE_CURVE_ON_SURFACE" => & [] , "COMPOSITE_CURVE_SEGMENT" => & ["transition" , "same_sense" , "parent_curve" ,] , "COMPOSITE_MATERIAL_DESIGNATION" => & [] , "COMPOSITE_SHAPE_ASPECT" => & [] , "COMPOSITE_SHEET_REPRESENTATION" => & [] , "COMPOSITE_TEXT" => & ["collected_text" ,] , "COMPOSITE_TEXT_WITH_ASSOCIATED_CURVES" => & ["associated_curves" ,] , "COMPOSITE_TEXT_WITH_BLANKING_BOX" => & ["blanking" ,] , "COMPOSITE_TEXT_WITH_DELINEATION" => & ["delineation" ,] , "COMPOSITE_TEXT_WITH_EXTENT" => & ["extent" ,] , "COMPOUND_REPRESENTATION_ITEM" => & ["item_element" ,] , "COMPOUND_SHAPE_REPRESENTATION" => & [] , "CONCENTRICITY_TOLERANCE" => & [] , "CONCEPT_FEATURE_OPERATOR" => & ["name" , "description" ,] , "CONCEPT_FEATURE_RELATIONSHIP" => & ["name" , "description" , "relating_product_concept_feature" , "related_product_concept_feature" ,] , "CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION" => & ["conditional_operator" ,] , "CONDITIONAL_CONCEPT_FEATURE" => & ["condition" ,] , "CONDUCTANCE_MEASURE_WITH_UNIT" => & [] , "CONDUCTANCE_UNIT" => & [] , "CONFIGURABLE_ITEM" => & ["item_concept_feature" ,] , "CONFIGURATION_DESIGN" => & ["configuration" , "design" ,] , "CONFIGURATION_EFFECTIVITY" => & ["configuration" ,] , "CONFIGURATION_ITEM" => & ["id" , "name" , "description" , "item_concept" , "purpose" ,] , "CONFIGURATION_ITEM_HIERARCHICAL_RELATIONSHIP" => & [] , "CONFIGURATION_ITEM_RELATIONSHIP" => & ["name" , "description" , "relating_configuration_item" , "related_configuration_item" ,] , "CONFIGURATION_ITEM_REVISION_SEQUENCE" => & [] , "CONFIGURED_EFFECTIVITY_ASSIGNMENT" => & ["items" ,] , "CONFIGURED_EFFECTIVITY_CONTEXT_ASSIGNMENT" => & ["items" ,] , "CONIC" => & ["position" ,] , "CONICAL_STEPPED_HOLE_TRANSITION" => & ["transition_number" , "cone_apex_angle" , "cone_base_radius" ,] , "CONICAL_SURFACE" => & ["radius" , "semi_angle" ,] , "CONNECTED_EDGE_SET" => & ["ces_edges" ,] , "CONNECTED_FACE_SET" => & ["cfs_faces" ,] , "CONNECTED_FACE_SUB_SET" => & ["parent_face_set" ,] , "CONSTRUCTIVE_GEOMETRY_REPRESENTATION" => & [] , "CONSTRUCTIVE_GEOMETRY_REPRESENTATION_RELATIONSHIP" => & [] , "CONTACT_RATIO_REPRESENTATION" => & [] , "CONTEXT_DEPENDENT_INVISIBILITY" => & ["presentation_context" ,] , "CONTEXT_DEPENDENT_OVER_RIDING_STYLED_ITEM" => & ["style_context" ,] , "CONTEXT_DEPENDENT_SHAPE_REPRESENTATION" => & ["representation_relation" , "represented_product_relation" ,] , "CONTEXT_DEPENDENT_UNIT" => & ["name" ,] , "CONTRACT" => & ["name" , "purpose" , "kind" ,] , "CONTRACT_ASSIGNMENT" => & ["assigned_contract" ,] , "CONTRACT_RELATIONSHIP" => & ["id" , "name" , "description" , "relating_contract" , "related_contract" ,] , "CONTRACT_TYPE" => & ["description" ,] , "CONVERSION_BASED_UNIT" => & ["name" , "conversion_factor" ,] , "COORDINATED_UNIVERSAL_TIME_OFFSET" => & ["hour_offset" , "minute_offset" , "sense" ,] , "CSG_SHAPE_REPRESENTATION" => & [] , "CSG_SOLID" => & ["tree_root_expression" ,] , "CURRENCY" => & [] , "CURRENCY_MEASURE_WITH_UNIT" => & [] , "CURVE" => & [] , "CURVE_BOUNDED_SURFACE" => & ["basis_surface" , "boundaries" , "implicit_outer" ,] , "CURVE_DIMENSION" => & [] , "CURVE_REPLICA" => & ["parent_curve" , "transformation" ,] , "CURVE_STYLE" => & ["name" , "curve_font" , "curve_width" , "curve_colour" ,] , "CURVE_STYLE_FONT" => & ["name" , "pattern_list" ,] , "CURVE_STYLE_FONT_AND_SCALING" => & ["name" , "curve_font" , "curve_font_scaling" ,] , "CURVE_STYLE_FONT_PATTERN" => & ["visible_segment_length" , "invisible_segment_length" ,] , "CURVE_STYLE_RENDERING" => & ["rendering_method" , "rendering_properties" ,] , "CURVE_SWEPT_SOLID_SHAPE_REPRESENTATION" => & [] , "CYLINDRICAL_SURFACE" => & ["radius" ,] , "CYLINDRICITY_TOLERANCE" => & [] , "DATA_ENVIRONMENT" => & ["name" , "description" , "elements" ,] , "DATE" => & ["year_component" ,] , "DATE_AND_TIME" => & ["date_component" , "time_component" ,] , "DATE_AND_TIME_ASSIGNMENT" => & ["assigned_date_and_time" , "role" ,] , "DATE_ASSIGNMENT" => & ["assigned_date" , "role" ,] , "DATE_REPRESENTATION_ITEM" => & [] , "DATE_ROLE" => & ["name" ,] , "DATE_TIME_REPRESENTATION_ITEM" => & [] , "DATE_TIME_ROLE" => & ["name" ,] , "DATED_EFFECTIVITY" => & ["effectivity_end_date" , "effectivity_start_date" ,] , "DATUM" => & ["identification" ,] , "DATUM_FEATURE" => & [] , "DATUM_FEATURE_CALLOUT" => & [] , "DATUM_REFERENCE" => & ["precedence" , "referenced_datum" ,] , "DATUM_TARGET" => & ["target_id" ,] , "DATUM_TARGET_CALLOUT" => & [] , "DEFAULT_TOLERANCE_TABLE" => & [] , "DEFAULT_TOLERANCE_TABLE_CELL" => & [] , "DEFINED_SYMBOL" => & ["definition" , "target" ,] , "DEFINITIONAL_REPRESENTATION" => & [] , "DEFINITIONAL_REPRESENTATION_RELATIONSHIP" => & [] , "DEFINITIONAL_REPRESENTATION_RELATIONSHIP_WITH_SAME_CONTEXT" => & [] , "DEGENERATE_PCURVE" => & ["basis_surface" , "reference_to_curve" ,] , "DEGENERATE_TOROIDAL_SURFACE" => & ["select_outer" ,] , "DERIVED_SHAPE_ASPECT" => & [] , "DERIVED_UNIT" => & ["elements" ,] , "DERIVED_UNIT_ELEMENT" => & ["unit" , "exponent" ,] , "DESCRIPTION_ATTRIBUTE" => & ["attribute_value" , "described_item" ,] , "DESCRIPTIVE_REPRESENTATION_ITEM" => & ["description" ,] , "DESIGN_CONTEXT" => & [] , "DESIGN_MAKE_FROM_RELATIONSHIP" => & [] , "DIAMETER_DIMENSION" => & [] , "DIELECTRIC_CONSTANT_MEASURE_WITH_UNIT" => & [] , "DIMENSION_CALLOUT" => & [] , "DIMENSION_CALLOUT_COMPONENT_RELATIONSHIP" => & [] , "DIMENSION_CALLOUT_RELATIONSHIP" => & [] , "DIMENSION_CURVE" => & [] , "DIMENSION_CURVE_DIRECTED_CALLOUT" => & [] , "DIMENSION_CURVE_TERMINATOR" => & ["role" ,] , "DIMENSION_CURVE_TERMINATOR_TO_PROJECTION_CURVE_ASSOCIATIVITY" => & [] , "DIMENSION_PAIR" => & [] , "DIMENSION_RELATED_TOLERANCE_ZONE_ELEMENT" => & ["related_dimension" , "related_element" ,] , "DIMENSION_TEXT_ASSOCIATIVITY" => & [] , "DIMENSIONAL_CHARACTERISTIC_REPRESENTATION" => & ["dimension" , "representation" ,] , "DIMENSIONAL_EXPONENTS" => & ["length_exponent" , "mass_exponent" , "time_exponent" , "electric_current_exponent" , "thermodynamic_temperature_exponent" , "amount_of_substance_exponent" , "luminous_intensity_exponent" ,] , "DIMENSIONAL_LOCATION" => & [] , "DIMENSIONAL_LOCATION_WITH_PATH" => & ["path" ,] , "DIMENSIONAL_SIZE" => & ["applies_to" , "name" ,] , "DIMENSIONAL_SIZE_WITH_PATH" => & ["path" ,] , "DIRECTED_ACTION" => & ["directive" ,] , "DIRECTED_DIMENSIONAL_LOCATION" => & [] , "DIRECTION" => & ["direction_ratios" ,] , "DOCUMENT" => & ["id" , "name" , "description" , "kind" ,] , "DOCUMENT_FILE" => & [] , "DOCUMENT_IDENTIFIER" => & [] , "DOCUMENT_IDENTIFIER_ASSIGNMENT" => & ["items" ,] , "DOCUMENT_PRODUCT_ASSOCIATION" => & ["name" , "description" , "relating_document" , "related_product" ,] , "DOCUMENT_PRODUCT_EQUIVALENCE" => & [] , "DOCUMENT_REFERENCE" => & ["assigned_document" , "source" ,] , "DOCUMENT_RELATIONSHIP" => & ["name" , "description" , "relating_document" , "related_document" ,] , "DOCUMENT_REPRESENTATION_TYPE" => & ["name" , "represented_document" ,] , "DOCUMENT_TYPE" => & ["product_data_type" ,] , "DOCUMENT_USAGE_CONSTRAINT" => & ["source" , "subject_element" , "subject_element_value" ,] , "DOCUMENT_USAGE_CONSTRAINT_ASSIGNMENT" => & ["assigned_document_usage" , "role" ,] , "DOCUMENT_USAGE_ROLE" => & ["name" , "description" ,] , "DOSE_EQUIVALENT_MEASURE_WITH_UNIT" => & [] , "DOSE_EQUIVALENT_UNIT" => & [] , "DOUBLE_OFFSET_SHELLED_SOLID" => & ["thickness2" ,] , "DRAPED_DEFINED_TRANSFORMATION" => & [] , "DRAUGHTING_ANNOTATION_OCCURRENCE" => & [] , "DRAUGHTING_CALLOUT" => & ["contents" ,] , "DRAUGHTING_CALLOUT_RELATIONSHIP" => & ["name" , "description" , "relating_draughting_callout" , "related_draughting_callout" ,] , "DRAUGHTING_ELEMENTS" => & [] , "DRAUGHTING_MODEL" => & [] , "DRAUGHTING_MODEL_ITEM_ASSOCIATION" => & [] , "DRAUGHTING_PRE_DEFINED_COLOUR" => & [] , "DRAUGHTING_PRE_DEFINED_CURVE_FONT" => & [] , "DRAUGHTING_PRE_DEFINED_TEXT_FONT" => & [] , "DRAUGHTING_SUBFIGURE_REPRESENTATION" => & [] , "DRAUGHTING_SYMBOL_REPRESENTATION" => & [] , "DRAUGHTING_TEXT_LITERAL_WITH_DELINEATION" => & [] , "DRAUGHTING_TITLE" => & ["items" , "language" , "contents" ,] , "DRAWING_DEFINITION" => & ["drawing_number" , "drawing_type" ,] , "DRAWING_REVISION" => & ["revision_identifier" , "drawing_identifier" , "intended_scale" ,] , "DRAWING_REVISION_SEQUENCE" => & ["predecessor" , "successor" ,] , "DRAWING_SHEET_REVISION" => & ["revision_identifier" ,] , "DRAWING_SHEET_REVISION_SEQUENCE" => & [] , "DRAWING_SHEET_REVISION_USAGE" => & ["sheet_number" ,] , "EDGE" => & ["edge_start" , "edge_end" ,] , "EDGE_BASED_WIREFRAME_MODEL" => & ["ebwm_boundary" ,] , "EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION" => & [] , "EDGE_BLENDED_SOLID" => & ["blended_edges" ,] , "EDGE_CURVE" => & ["edge_geometry" , "same_sense" ,] , "EDGE_LOOP" => & [] , "EFFECTIVITY" => & ["id" ,] , "EFFECTIVITY_ASSIGNMENT" => & ["assigned_effectivity" ,] , "EFFECTIVITY_CONTEXT_ASSIGNMENT" => & ["assigned_effectivity_assignment" , "role" ,] , "EFFECTIVITY_CONTEXT_ROLE" => & ["name" , "description" ,] , "EFFECTIVITY_RELATIONSHIP" => & ["name" , "description" , "related_effectivity" , "relating_effectivity" ,] , "ELECTRIC_CHARGE_MEASURE_WITH_UNIT" => & [] , "ELECTRIC_CHARGE_UNIT" => & [] , "ELECTRIC_CURRENT_MEASURE_WITH_UNIT" => & [] , "ELECTRIC_CURRENT_UNIT" => & [] , "ELECTRIC_POTENTIAL_MEASURE_WITH_UNIT" => & [] , "ELECTRIC_POTENTIAL_UNIT" => & [] , "ELEMENTARY_BREP_SHAPE_REPRESENTATION" => & [] , "ELEMENTARY_SURFACE" => & ["position" ,] , "ELLIPSE" => & ["semi_axis_1" , "semi_axis_2" ,] , "ENERGY_MEASURE_WITH_UNIT" => & [] , "ENERGY_UNIT" => & [] , "ENTITY_ASSERTION" => & [] , "ENUM_REFERENCE_PREFIX" => & [] , "ENVIRONMENT" => & ["syntactic_representation" , "semantics" ,] , "EVALUATED_CHARACTERISTIC" => & [] , "EVALUATED_DEGENERATE_PCURVE" => & ["equivalent_point" ,] , "EVALUATION_PRODUCT_DEFINITION" => & [] , "EVENT_OCCURRENCE" => & ["id" , "name" , "description" ,] , "EVENT_OCCURRENCE_ASSIGNMENT" => & ["assigned_event_occurrence" , "role" ,] , "EVENT_OCCURRENCE_RELATIONSHIP" => & ["name" , "description" , "relating_event" , "related_event" ,] , "EVENT_OCCURRENCE_ROLE" => & ["name" , "description" ,] , "EXCLUSIVE_PRODUCT_CONCEPT_FEATURE_CATEGORY" => & [] , "EXECUTED_ACTION" => & [] , "EXPANDED_UNCERTAINTY" => & ["coverage_factor" ,] , "EXPLICIT_PROCEDURAL_GEOMETRIC_REPRESENTATION_ITEM_RELATIONSHIP" => & [] , "EXPLICIT_PROCEDURAL_REPRESENTATION_ITEM_RELATIONSHIP" => & [] , "EXPLICIT_PROCEDURAL_REPRESENTATION_RELATIONSHIP" => & [] , "EXPLICIT_PROCEDURAL_SHAPE_REPRESENTATION_RELATIONSHIP" => & [] , "EXPRESSION" => & [] , "EXPRESSION_CONVERSION_BASED_UNIT" => & [] , "EXTENSION" => & [] , "EXTENT" => & [] , "EXTERNAL_CLASS_LIBRARY" => & [] , "EXTERNAL_IDENTIFICATION_ASSIGNMENT" => & ["source" ,] , "EXTERNAL_SOURCE" => & ["source_id" ,] , "EXTERNAL_SOURCE_RELATIONSHIP" => & ["name" , "description" , "relating_source" , "related_source" ,] , "EXTERNALLY_DEFINED_CLASS" => & [] , "EXTERNALLY_DEFINED_COLOUR" => & [] , "EXTERNALLY_DEFINED_CONTEXT_DEPENDENT_UNIT" => & [] , "EXTERNALLY_DEFINED_CONVERSION_BASED_UNIT" => & [] , "EXTERNALLY_DEFINED_CURRENCY" => & [] , "EXTERNALLY_DEFINED_CURVE_FONT" => & [] , "EXTERNALLY_DEFINED_DIMENSION_DEFINITION" => & [] , "EXTERNALLY_DEFINED_GENERAL_PROPERTY" => & [] , "EXTERNALLY_DEFINED_HATCH_STYLE" => & [] , "EXTERNALLY_DEFINED_ITEM" => & ["item_id" , "source" ,] , "EXTERNALLY_DEFINED_ITEM_RELATIONSHIP" => & ["name" , "description" , "relating_item" , "related_item" ,] , "EXTERNALLY_DEFINED_MARKER" => & [] , "EXTERNALLY_DEFINED_PICTURE_REPRESENTATION_ITEM" => & [] , "EXTERNALLY_DEFINED_REPRESENTATION_ITEM" => & [] , "EXTERNALLY_DEFINED_STRING" => & [] , "EXTERNALLY_DEFINED_SYMBOL" => & [] , "EXTERNALLY_DEFINED_TERMINATOR_SYMBOL" => & [] , "EXTERNALLY_DEFINED_TEXT_FONT" => & [] , "EXTERNALLY_DEFINED_TILE" => & [] , "EXTERNALLY_DEFINED_TILE_STYLE" => & [] , "EXTRUDED_AREA_SOLID" => & ["extruded_direction" , "depth" ,] , "EXTRUDED_FACE_SOLID" => & ["extruded_direction" , "depth" ,] , "EXTRUDED_FACE_SOLID_WITH_DRAFT_ANGLE" => & ["draft_angle" ,] , "EXTRUDED_FACE_SOLID_WITH_MULTIPLE_DRAFT_ANGLES" => & ["drafted_edges" , "draft_angles" ,] , "EXTRUDED_FACE_SOLID_WITH_TRIM_CONDITIONS" => & ["first_trim_condition" , "second_trim_condition" , "first_trim_intent" , "second_trim_intent" , "first_offset" , "second_offset" ,] , "FACE" => & ["bounds" ,] , "FACE_BASED_SURFACE_MODEL" => & ["fbsm_faces" ,] , "FACE_BOUND" => & ["bound" , "orientation" ,] , "FACE_OUTER_BOUND" => & [] , "FACE_SURFACE" => & ["face_geometry" , "same_sense" ,] , "FACETED_BREP" => & [] , "FACETED_BREP_SHAPE_REPRESENTATION" => & [] , "FACT_TYPE" => & [] , "FILL_AREA_STYLE" => & ["name" , "fill_styles" ,] , "FILL_AREA_STYLE_COLOUR" => & ["name" , "fill_colour" ,] , "FILL_AREA_STYLE_HATCHING" => & ["hatch_line_appearance" , "start_of_next_hatch_line" , "point_of_reference_hatch_line" , "pattern_start" , "hatch_line_angle" ,] , "FILL_AREA_STYLE_TILE_COLOURED_REGION" => & ["closed_curve" , "region_colour" ,] , "FILL_AREA_STYLE_TILE_CURVE_WITH_STYLE" => & ["styled_curve" ,] , "FILL_AREA_STYLE_TILE_SYMBOL_WITH_STYLE" => & ["symbol" ,] , "FILL_AREA_STYLE_TILES" => & ["tiling_pattern" , "tiles" , "tiling_scale" ,] , "FLAT_PATTERN_PLY_REPRESENTATION_RELATIONSHIP" => & [] , "FLATNESS_TOLERANCE" => & [] , "FORCE_MEASURE_WITH_UNIT" => & [] , "FORCE_UNIT" => & [] , "FORWARD_CHAINING_RULE" => & [] , "FORWARD_CHAINING_RULE_PREMISE" => & [] , "FOUNDED_ITEM" => & [] , "FREQUENCY_MEASURE_WITH_UNIT" => & [] , "FREQUENCY_UNIT" => & [] , "FUNC" => & [] , "FUNCTIONAL_BREAKDOWN_CONTEXT" => & [] , "FUNCTIONAL_ELEMENT_USAGE" => & [] , "FUNCTIONALLY_DEFINED_TRANSFORMATION" => & ["name" , "description" ,] , "GENERAL_MATERIAL_PROPERTY" => & [] , "GENERAL_PROPERTY" => & ["id" , "name" , "description" ,] , "GENERAL_PROPERTY_ASSOCIATION" => & ["name" , "description" , "base_definition" , "derived_definition" ,] , "GENERAL_PROPERTY_RELATIONSHIP" => & ["name" , "description" , "relating_property" , "related_property" ,] , "GENERIC_CHARACTER_GLYPH_SYMBOL" => & [] , "GENERIC_EXPRESSION" => & [] , "GENERIC_LITERAL" => & [] , "GENERIC_VARIABLE" => & [] , "GEOMETRIC_ALIGNMENT" => & [] , "GEOMETRIC_CURVE_SET" => & [] , "GEOMETRIC_INTERSECTION" => & [] , "GEOMETRIC_ITEM_SPECIFIC_USAGE" => & [] , "GEOMETRIC_MODEL_ELEMENT_RELATIONSHIP" => & [] , "GEOMETRIC_REPRESENTATION_CONTEXT" => & ["coordinate_space_dimension" ,] , "GEOMETRIC_REPRESENTATION_ITEM" => & [] , "GEOMETRIC_SET" => & ["elements" ,] , "GEOMETRIC_TOLERANCE" => & ["name" , "description" , "magnitude" , "toleranced_shape_aspect" ,] , "GEOMETRIC_TOLERANCE_RELATIONSHIP" => & ["name" , "description" , "relating_geometric_tolerance" , "related_geometric_tolerance" ,] , "GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE" => & ["datum_system" ,] , "GEOMETRIC_TOLERANCE_WITH_DEFINED_UNIT" => & ["unit_size" ,] , "GEOMETRICAL_TOLERANCE_CALLOUT" => & [] , "GEOMETRICALLY_BOUNDED_2D_WIREFRAME_REPRESENTATION" => & [] , "GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION" => & [] , "GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION" => & [] , "GLOBAL_ASSIGNMENT" => & [] , "GLOBAL_UNCERTAINTY_ASSIGNED_CONTEXT" => & ["uncertainty" ,] , "GLOBAL_UNIT_ASSIGNED_CONTEXT" => & ["units" ,] , "GROUND_FACT" => & [] , "GROUP" => & ["name" , "description" ,] , "GROUP_ASSIGNMENT" => & ["assigned_group" ,] , "GROUP_RELATIONSHIP" => & ["name" , "description" , "relating_group" , "related_group" ,] , "HALF_SPACE_SOLID" => & ["base_surface" , "agreement_flag" ,] , "HARDNESS_REPRESENTATION" => & [] , "HIDDEN_ELEMENT_OVER_RIDING_STYLED_ITEM" => & [] , "HYPERBOLA" => & ["semi_axis" , "semi_imag_axis" ,] , "ID_ATTRIBUTE" => & ["attribute_value" , "identified_item" ,] , "IDENTIFICATION_ASSIGNMENT" => & ["assigned_id" , "role" ,] , "IDENTIFICATION_ROLE" => & ["name" , "description" ,] , "ILLUMINANCE_MEASURE_WITH_UNIT" => & [] , "ILLUMINANCE_UNIT" => & [] , "INCLUDED_TEXT_BLOCK" => & [] , "INCLUSION_PRODUCT_CONCEPT_FEATURE" => & [] , "INDIRECTLY_SELECTED_ELEMENTS" => & ["indirectly_picked_items" ,] , "INDIRECTLY_SELECTED_SHAPE_ELEMENTS" => & [] , "INDUCTANCE_MEASURE_WITH_UNIT" => & [] , "INDUCTANCE_UNIT" => & [] , "INFORMATION_RIGHT" => & [] , "INFORMATION_USAGE_RIGHT" => & [] , "INSTANCE_USAGE_CONTEXT_ASSIGNMENT" => & ["items" ,] , "INSTANCED_FEATURE" => & [] , "INT_LITERAL" => & [] , "INTEGER_REPRESENTATION_ITEM" => & [] , "INTERSECTION_CURVE" => & [] , "INTERVAL_EXPRESSION" => & [] , "INVISIBILITY" => & ["invisible_items" ,] , "ISO_4217_CURRENCY" => & [] , "ITEM_DEFINED_TRANSFORMATION" => & ["name" , "description" , "transform_item_1" , "transform_item_2" ,] , "ITEM_IDENTIFIED_REPRESENTATION_USAGE" => & ["name" , "description" , "definition" , "used_representation" , "identified_item" ,] , "KNOWN_SOURCE" => & [] , "LAID_DEFINED_TRANSFORMATION" => & [] , "LAMINATE_TABLE" => & [] , "LANGUAGE" => & [] , "LEADER_CURVE" => & [] , "LEADER_DIRECTED_CALLOUT" => & [] , "LEADER_DIRECTED_DIMENSION" => & [] , "LEADER_TERMINATOR" => & [] , "LENGTH_MEASURE_WITH_UNIT" => & [] , "LENGTH_UNIT" => & [] , "LIGHT_SOURCE" => & ["light_colour" ,] , "LIGHT_SOURCE_AMBIENT" => & [] , "LIGHT_SOURCE_DIRECTIONAL" => & ["orientation" ,] , "LIGHT_SOURCE_POSITIONAL" => & ["position" , "constant_attenuation" , "distance_attenuation" ,] , "LIGHT_SOURCE_SPOT" => & ["position" , "orientation" , "concentration_exponent" , "constant_attenuation" , "distance_attenuation" , "spread_angle" ,] , "LIMITS_AND_FITS" => & ["form_variance" , "zone_variance" , "grade" , "source" ,] , "LINE" => & ["pnt" , "dir" ,] , "LINE_PROFILE_TOLERANCE" => & [] , "LINEAR_DIMENSION" => & [] , "LITERAL_CONJUNCTION" => & [] , "LITERAL_DISJUNCTION" => & [] , "LITERAL_NUMBER" => & ["the_value" ,] , "LOCAL_TIME" => & ["hour_component" , "minute_component" , "second_component" , "zone" ,] , "LOGICAL_LITERAL" => & ["lit_value" ,] , "LOGICAL_REPRESENTATION_ITEM" => & [] , "LOOP" => & [] , "LOSS_TANGENT_MEASURE_WITH_UNIT" => & [] , "LOT_EFFECTIVITY" => & ["effectivity_lot_id" , "effectivity_lot_size" ,] , "LUMINOUS_FLUX_MEASURE_WITH_UNIT" => & [] , "LUMINOUS_FLUX_UNIT" => & [] , "LUMINOUS_INTENSITY_MEASURE_WITH_UNIT" => & [] , "LUMINOUS_INTENSITY_UNIT" => & [] , "MAGNETIC_FLUX_DENSITY_MEASURE_WITH_UNIT" => & [] , "MAGNETIC_FLUX_DENSITY_UNIT" => & [] , "MAGNETIC_FLUX_MEASURE_WITH_UNIT" => & [] , "MAGNETIC_FLUX_UNIT" => & [] , "MAKE_FROM_USAGE_OPTION" => & ["ranking" , "ranking_rationale" , "quantity" ,] , "MANIFOLD_SOLID_BREP" => & ["outer" ,] , "MANIFOLD_SUBSURFACE_SHAPE_REPRESENTATION" => & [] , "MANIFOLD_SURFACE_SHAPE_REPRESENTATION" => & [] , "MAPPED_ITEM" => & ["mapping_source" , "mapping_target" ,] , "MASS_MEASURE_WITH_UNIT" => & [] , "MASS_UNIT" => & [] , "MATERIAL_DESIGNATION" => & ["name" , "definitions" ,] , "MATERIAL_DESIGNATION_CHARACTERIZATION" => & ["name" , "description" , "designation" , "property" ,] , "MATERIAL_PROPERTY" => & [] , "MATERIAL_PROPERTY_REPRESENTATION" => & ["dependent_environment" ,] , "MEASURE_QUALIFICATION" => & ["name" , "description" , "qualified_measure" , "qualifiers" ,] , "MEASURE_REPRESENTATION_ITEM" => & [] , "MEASURE_WITH_UNIT" => & ["value_component" , "unit_component" ,] , "MECHANICAL_CONTEXT" => & [] , "MECHANICAL_DESIGN_AND_DRAUGHTING_RELATIONSHIP" => & [] , "MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_AREA" => & [] , "MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION" => & [] , "MECHANICAL_DESIGN_PRESENTATION_REPRESENTATION_WITH_DRAUGHTING" => & [] , "MECHANICAL_DESIGN_SHADED_PRESENTATION_AREA" => & [] , "MECHANICAL_DESIGN_SHADED_PRESENTATION_REPRESENTATION" => & [] , "MIN_AND_MAJOR_PLY_ORIENTATION_BASIS" => & [] , "MODIFIED_GEOMETRIC_TOLERANCE" => & ["modifier" ,] , "MODIFIED_SOLID" => & ["rationale" , "base_solid" ,] , "MODIFIED_SOLID_WITH_PLACED_CONFIGURATION" => & ["placing" ,] , "MOMENTS_OF_INERTIA_REPRESENTATION" => & [] , "MULTI_LANGUAGE_ATTRIBUTE_ASSIGNMENT" => & ["items" ,] , "MULTIPLE_ARITY_BOOLEAN_EXPRESSION" => & [] , "MULTIPLE_ARITY_GENERIC_EXPRESSION" => & ["operands" ,] , "MULTIPLE_ARITY_NUMERIC_EXPRESSION" => & [] , "NAME_ASSIGNMENT" => & ["assigned_name" ,] , "NAME_ATTRIBUTE" => & ["attribute_value" , "named_item" ,] , "NAMED_UNIT" => & ["dimensions" ,] , "NEXT_ASSEMBLY_USAGE_OCCURRENCE" => & [] , "NON_MANIFOLD_SURFACE_SHAPE_REPRESENTATION" => & [] , "NULL_REPRESENTATION_ITEM" => & [] , "NUMERIC_EXPRESSION" => & [] , "OBJECT_ROLE" => & ["name" , "description" ,] , "OFFSET_CURVE_2D" => & ["basis_curve" , "distance" , "self_intersect" ,] , "OFFSET_CURVE_3D" => & ["basis_curve" , "distance" , "self_intersect" , "ref_direction" ,] , "OFFSET_SURFACE" => & ["basis_surface" , "distance" , "self_intersect" ,] , "ONE_DIRECTION_REPEAT_FACTOR" => & ["repeat_factor" ,] , "OPEN_SHELL" => & [] , "ORDINAL_DATE" => & ["day_component" ,] , "ORDINATE_DIMENSION" => & [] , "ORGANIZATION" => & ["id" , "name" , "description" ,] , "ORGANIZATION_ASSIGNMENT" => & ["assigned_organization" , "role" ,] , "ORGANIZATION_RELATIONSHIP" => & ["name" , "description" , "relating_organization" , "related_organization" ,] , "ORGANIZATION_ROLE" => & ["name" ,] , "ORGANIZATIONAL_ADDRESS" => & ["organizations" , "description" ,] , "ORGANIZATIONAL_PROJECT" => & ["name" , "description" , "responsible_organizations" ,] , "ORGANIZATIONAL_PROJECT_ASSIGNMENT" => & ["assigned_organizational_project" , "role" ,] , "ORGANIZATIONAL_PROJECT_RELATIONSHIP" => & ["name" , "description" , "relating_organizational_project" , "related_organizational_project" ,] , "ORGANIZATIONAL_PROJECT_ROLE" => & ["name" , "description" ,] , "ORIENTED_CLOSED_SHELL" => & ["closed_shell_element" , "orientation" ,] , "ORIENTED_EDGE" => & ["edge_element" , "orientation" ,] , "ORIENTED_FACE" => & ["face_element" , "orientation" ,] , "ORIENTED_OPEN_SHELL" => & ["open_shell_element" , "orientation" ,] , "ORIENTED_PATH" => & ["path_element" , "orientation" ,] , "ORIENTED_SURFACE" => & ["orientation" ,] , "OUTER_BOUNDARY_CURVE" => & [] , "OVER_RIDING_STYLED_ITEM" => & ["over_ridden_style" ,] , "PACKAGE_PRODUCT_CONCEPT_FEATURE" => & [] , "PARABOLA" => & ["focal_dist" ,] , "PARALLEL_OFFSET" => & ["offset" ,] , "PARALLELISM_TOLERANCE" => & [] , "PARAMETRIC_REPRESENTATION_CONTEXT" => & [] , "PART_LAMINATE_TABLE" => & [] , "PARTIAL_DOCUMENT_WITH_STRUCTURED_TEXT_REPRESENTATION_ASSIGNMENT" => & [] , "PATH" => & ["edge_list" ,] , "PCURVE" => & ["basis_surface" , "reference_to_curve" ,] , "PERCENTAGE_LAMINATE_DEFINITION" => & [] , "PERCENTAGE_LAMINATE_TABLE" => & [] , "PERCENTAGE_PLY_DEFINITION" => & [] , "PERPENDICULAR_TO" => & [] , "PERPENDICULARITY_TOLERANCE" => & [] , "PERSON" => & ["id" , "last_name" , "first_name" , "middle_names" , "prefix_titles" , "suffix_titles" ,] , "PERSON_AND_ORGANIZATION" => & ["the_person" , "the_organization" ,] , "PERSON_AND_ORGANIZATION_ADDRESS" => & [] , "PERSON_AND_ORGANIZATION_ASSIGNMENT" => & ["assigned_person_and_organization" , "role" ,] , "PERSON_AND_ORGANIZATION_ROLE" => & ["name" ,] , "PERSONAL_ADDRESS" => & ["people" , "description" ,] , "PHYSICAL_BREAKDOWN_CONTEXT" => & [] , "PHYSICAL_ELEMENT_USAGE" => & [] , "PICTURE_REPRESENTATION" => & [] , "PICTURE_REPRESENTATION_ITEM" => & [] , "PLACED_DATUM_TARGET_FEATURE" => & [] , "PLACED_FEATURE" => & [] , "PLACEMENT" => & ["location" ,] , "PLANAR_BOX" => & ["placement" ,] , "PLANAR_EXTENT" => & ["size_in_x" , "size_in_y" ,] , "PLANE" => & [] , "PLANE_ANGLE_MEASURE_WITH_UNIT" => & [] , "PLANE_ANGLE_UNIT" => & [] , "PLUS_MINUS_TOLERANCE" => & ["range" , "toleranced_dimension" ,] , "PLY_LAMINATE_DEFINITION" => & [] , "PLY_LAMINATE_SEQUENCE_DEFINITION" => & [] , "PLY_LAMINATE_TABLE" => & [] , "POINT" => & [] , "POINT_AND_VECTOR" => & [] , "POINT_ON_CURVE" => & ["basis_curve" , "point_parameter" ,] , "POINT_ON_SURFACE" => & ["basis_surface" , "point_parameter_u" , "point_parameter_v" ,] , "POINT_PATH" => & [] , "POINT_REPLICA" => & ["parent_pt" , "transformation" ,] , "POINT_STYLE" => & ["name" , "marker" , "marker_size" , "marker_colour" ,] , "POLAR_COMPLEX_NUMBER_LITERAL" => & ["radius" , "angle" ,] , "POLY_LOOP" => & ["polygon" ,] , "POLYLINE" => & ["points" ,] , "POSITION_TOLERANCE" => & [] , "POSITIONED_SKETCH" => & ["sketch_basis" , "auxiliary_elements" ,] , "POWER_MEASURE_WITH_UNIT" => & [] , "POWER_UNIT" => & [] , "PRE_DEFINED_COLOUR" => & [] , "PRE_DEFINED_CURVE_FONT" => & [] , "PRE_DEFINED_DIMENSION_SYMBOL" => & [] , "PRE_DEFINED_GEOMETRICAL_TOLERANCE_SYMBOL" => & [] , "PRE_DEFINED_ITEM" => & ["name" ,] , "PRE_DEFINED_MARKER" => & [] , "PRE_DEFINED_POINT_MARKER_SYMBOL" => & [] , "PRE_DEFINED_SURFACE_CONDITION_SYMBOL" => & [] , "PRE_DEFINED_SURFACE_SIDE_STYLE" => & [] , "PRE_DEFINED_SYMBOL" => & [] , "PRE_DEFINED_TERMINATOR_SYMBOL" => & [] , "PRE_DEFINED_TEXT_FONT" => & [] , "PRE_DEFINED_TILE" => & [] , "PRECISION_QUALIFIER" => & ["precision_value" ,] , "PREDEFINED_PICTURE_REPRESENTATION_ITEM" => & [] , "PRESENTATION_AREA" => & [] , "PRESENTATION_LAYER_ASSIGNMENT" => & ["name" , "description" , "assigned_items" ,] , "PRESENTATION_REPRESENTATION" => & [] , "PRESENTATION_SET" => & [] , "PRESENTATION_SIZE" => & ["unit" , "size" ,] , "PRESENTATION_STYLE_ASSIGNMENT" => & ["styles" ,] , "PRESENTATION_STYLE_BY_CONTEXT" => & ["style_context" ,] , "PRESENTATION_VIEW" => & [] , "PRESENTED_ITEM" => & [] , "PRESENTED_ITEM_REPRESENTATION" => & ["presentation" , "item" ,] , "PRESSURE_MEASURE_WITH_UNIT" => & [] , "PRESSURE_UNIT" => & [] , "PROCEDURAL_REPRESENTATION" => & [] , "PROCEDURAL_REPRESENTATION_SEQUENCE" => & ["elements" , "suppressed_items" , "rationale" ,] , "PROCEDURAL_SHAPE_REPRESENTATION" => & [] , "PROCEDURAL_SHAPE_REPRESENTATION_SEQUENCE" => & [] , "PRODUCT" => & ["id" , "name" , "description" , "frame_of_reference" ,] , "PRODUCT_CATEGORY" => & ["name" , "description" ,] , "PRODUCT_CLASS" => & [] , "PRODUCT_CONCEPT" => & ["id" , "name" , "description" , "market_context" ,] , "PRODUCT_CONCEPT_CONTEXT" => & ["market_segment_type" ,] , "PRODUCT_CONCEPT_FEATURE" => & ["id" , "name" , "description" ,] , "PRODUCT_CONCEPT_FEATURE_ASSOCIATION" => & ["name" , "description" , "concept" , "feature" ,] , "PRODUCT_CONCEPT_FEATURE_CATEGORY" => & [] , "PRODUCT_CONCEPT_FEATURE_CATEGORY_USAGE" => & ["items" ,] , "PRODUCT_CONCEPT_RELATIONSHIP" => & ["name" , "description" , "relating_product_concept" , "related_product_concept" ,] , "PRODUCT_CONTEXT" => & ["discipline_type" ,] , "PRODUCT_DEFINITION" => & ["id" , "description" , "formation" , "frame_of_reference" ,] , "PRODUCT_DEFINITION_CONTEXT" => & ["life_cycle_stage" ,] , "PRODUCT_DEFINITION_CONTEXT_ASSOCIATION" => & ["definition" , "frame_of_reference" , "role" ,] , "PRODUCT_DEFINITION_CONTEXT_ROLE" => & ["name" , "description" ,] , "PRODUCT_DEFINITION_EFFECTIVITY" => & ["usage" ,] , "PRODUCT_DEFINITION_ELEMENT_RELATIONSHIP" => & [] , "PRODUCT_DEFINITION_FORMATION" => & ["id" , "description" , "of_product" ,] , "PRODUCT_DEFINITION_FORMATION_RELATIONSHIP" => & ["id" , "name" , "description" , "relating_product_definition_formation" , "related_product_definition_formation" ,] , "PRODUCT_DEFINITION_FORMATION_WITH_SPECIFIED_SOURCE" => & ["make_or_buy" ,] , "PRODUCT_DEFINITION_GROUP_ASSIGNMENT" => & ["items" ,] , "PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP" => & ["name" , "description" , "occurrence" , "occurrence_usage" ,] , "PRODUCT_DEFINITION_RELATIONSHIP" => & ["id" , "name" , "description" , "relating_product_definition" , "related_product_definition" ,] , "PRODUCT_DEFINITION_SHAPE" => & [] , "PRODUCT_DEFINITION_SUBSTITUTE" => & ["description" , "context_relationship" , "substitute_definition" ,] , "PRODUCT_DEFINITION_USAGE" => & [] , "PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS" => & ["documentation_ids" ,] , "PRODUCT_IDENTIFICATION" => & [] , "PRODUCT_MATERIAL_COMPOSITION_RELATIONSHIP" => & ["class" , "constituent_amount" , "composition_basis" , "determination_method" ,] , "PRODUCT_RELATED_PRODUCT_CATEGORY" => & ["products" ,] , "PRODUCT_SPECIFICATION" => & [] , "PROJECTED_ZONE_DEFINITION" => & ["projection_end" , "projected_length" ,] , "PROJECTION_CURVE" => & [] , "PROJECTION_DIRECTED_CALLOUT" => & [] , "PROMISSORY_USAGE_OCCURRENCE" => & [] , "PROPERTY_DEFINITION" => & ["name" , "description" , "definition" ,] , "PROPERTY_DEFINITION_RELATIONSHIP" => & ["name" , "description" , "relating_property_definition" , "related_property_definition" ,] , "PROPERTY_DEFINITION_REPRESENTATION" => & ["definition" , "used_representation" ,] , "QUALIFIED_REPRESENTATION_ITEM" => & ["qualifiers" ,] , "QUALITATIVE_UNCERTAINTY" => & ["uncertainty_value" ,] , "QUANTIFIED_ASSEMBLY_COMPONENT_USAGE" => & ["quantity" ,] , "QUASI_UNIFORM_CURVE" => & [] , "QUASI_UNIFORM_SURFACE" => & [] , "RADIOACTIVITY_MEASURE_WITH_UNIT" => & [] , "RADIOACTIVITY_UNIT" => & [] , "RADIUS_DIMENSION" => & [] , "RANGE_CHARACTERISTIC" => & [] , "RATIO_MEASURE_WITH_UNIT" => & [] , "RATIO_UNIT" => & [] , "RATIONAL_B_SPLINE_CURVE" => & ["weights_data" ,] , "RATIONAL_B_SPLINE_SURFACE" => & ["weights_data" ,] , "RATIONAL_REPRESENTATION_ITEM" => & [] , "REAL_LITERAL" => & [] , "REAL_REPRESENTATION_ITEM" => & [] , "RECTANGULAR_COMPOSITE_SURFACE" => & ["segments" ,] , "RECTANGULAR_TRIMMED_SURFACE" => & ["basis_surface" , "u1" , "u2" , "v1" , "v2" , "usense" , "vsense" ,] , "REFERENCED_MODIFIED_DATUM" => & ["modifier" ,] , "RELATIVE_EVENT_OCCURRENCE" => & ["base_event" , "offset" ,] , "REP_ITEM_GROUP" => & [] , "REPARAMETRISED_COMPOSITE_CURVE_SEGMENT" => & ["param_length" ,] , "REPRESENTATION" => & ["name" , "items" , "context_of_items" ,] , "REPRESENTATION_CONTEXT" => & ["context_identifier" , "context_type" ,] , "REPRESENTATION_ITEM" => & ["name" ,] , "REPRESENTATION_ITEM_RELATIONSHIP" => & ["name" , "description" , "relating_representation_item" , "related_representation_item" ,] , "REPRESENTATION_MAP" => & ["mapping_origin" , "mapped_representation" ,] , "REPRESENTATION_RELATIONSHIP" => & ["name" , "description" , "rep_1" , "rep_2" ,] , "REPRESENTATION_RELATIONSHIP_WITH_TRANSFORMATION" => & ["transformation_operator" ,] , "REQUIREMENT_ASSIGNED_OBJECT" => & ["items" ,] , "REQUIREMENT_ASSIGNMENT" => & [] , "REQUIREMENT_SOURCE" => & [] , "REQUIREMENT_VIEW_DEFINITION_RELATIONSHIP" => & [] , "RESISTANCE_MEASURE_WITH_UNIT" => & [] , "RESISTANCE_UNIT" => & [] , "REVOLVED_AREA_SOLID" => & ["axis" , "angle" ,] , "REVOLVED_FACE_SOLID" => & ["axis" , "angle" ,] , "REVOLVED_FACE_SOLID_WITH_TRIM_CONDITIONS" => & ["first_trim_condition" , "second_trim_condition" ,] , "RIGHT_ANGULAR_WEDGE" => & ["position" , "x" , "y" , "z" , "ltx" ,] , "RIGHT_CIRCULAR_CONE" => & ["position" , "height" , "radius" , "semi_angle" ,] , "RIGHT_CIRCULAR_CYLINDER" => & ["position" , "height" , "radius" ,] , "RIGHT_TO_USAGE_ASSOCIATION" => & [] , "ROLE_ASSOCIATION" => & ["role" , "item_with_role" ,] , "ROUNDNESS_TOLERANCE" => & [] , "ROW_REPRESENTATION_ITEM" => & [] , "ROW_VALUE" => & [] , "ROW_VARIABLE" => & [] , "RULE_ACTION" => & [] , "RULE_CONDITION" => & [] , "RULE_DEFINITION" => & [] , "RULE_SET" => & [] , "RULE_SET_GROUP" => & [] , "RULE_SOFTWARE_DEFINITION" => & [] , "RULE_SUPERSEDED_ASSIGNMENT" => & ["items" ,] , "RULE_SUPERSEDENCE" => & [] , "RULED_SURFACE_SWEPT_AREA_SOLID" => & [] , "RUNOUT_ZONE_DEFINITION" => & ["orientation" ,] , "RUNOUT_ZONE_ORIENTATION" => & ["angle" ,] , "RUNOUT_ZONE_ORIENTATION_REFERENCE_DIRECTION" => & ["orientation_defining_relationship" ,] , "SATISFIED_REQUIREMENT" => & ["items" ,] , "SATISFIES_REQUIREMENT" => & [] , "SATISFYING_ITEM" => & ["items" ,] , "SCALAR_VARIABLE" => & [] , "SCATTERING_PARAMETER" => & [] , "SCULPTURED_SOLID" => & ["sculpturing_element" , "positive_side" ,] , "SEAM_CURVE" => & [] , "SECURITY_CLASSIFICATION" => & ["name" , "purpose" , "security_level" ,] , "SECURITY_CLASSIFICATION_ASSIGNMENT" => & ["assigned_security_classification" ,] , "SECURITY_CLASSIFICATION_LEVEL" => & ["name" ,] , "SERIAL_NUMBERED_EFFECTIVITY" => & ["effectivity_start_id" , "effectivity_end_id" ,] , "SHAPE_ASPECT" => & ["name" , "description" , "of_shape" , "product_definitional" ,] , "SHAPE_ASPECT_ASSOCIATIVITY" => & [] , "SHAPE_ASPECT_DERIVING_RELATIONSHIP" => & [] , "SHAPE_ASPECT_RELATIONSHIP" => & ["name" , "description" , "relating_shape_aspect" , "related_shape_aspect" ,] , "SHAPE_DEFINITION_REPRESENTATION" => & [] , "SHAPE_DIMENSION_REPRESENTATION" => & [] , "SHAPE_FEATURE_DEFINITION" => & [] , "SHAPE_REPRESENTATION" => & [] , "SHAPE_REPRESENTATION_RELATIONSHIP" => & [] , "SHAPE_REPRESENTATION_WITH_PARAMETERS" => & [] , "SHELL_BASED_SURFACE_MODEL" => & ["sbsm_boundary" ,] , "SHELL_BASED_WIREFRAME_MODEL" => & ["sbwm_boundary" ,] , "SHELL_BASED_WIREFRAME_SHAPE_REPRESENTATION" => & [] , "SHELLED_SOLID" => & ["deleted_face_set" , "thickness" ,] , "SI_ABSORBED_DOSE_UNIT" => & [] , "SI_CAPACITANCE_UNIT" => & [] , "SI_CONDUCTANCE_UNIT" => & [] , "SI_DOSE_EQUIVALENT_UNIT" => & [] , "SI_ELECTRIC_CHARGE_UNIT" => & [] , "SI_ELECTRIC_POTENTIAL_UNIT" => & [] , "SI_ENERGY_UNIT" => & [] , "SI_FORCE_UNIT" => & [] , "SI_FREQUENCY_UNIT" => & [] , "SI_ILLUMINANCE_UNIT" => & [] , "SI_INDUCTANCE_UNIT" => & [] , "SI_MAGNETIC_FLUX_DENSITY_UNIT" => & [] , "SI_MAGNETIC_FLUX_UNIT" => & [] , "SI_POWER_UNIT" => & [] , "SI_PRESSURE_UNIT" => & [] , "SI_RADIOACTIVITY_UNIT" => & [] , "SI_RESISTANCE_UNIT" => & [] , "SI_UNIT" => & ["prefix" , "name" ,] , "SIMPLE_BOOLEAN_EXPRESSION" => & [] , "SIMPLE_CLAUSE" => & [] , "SIMPLE_GENERIC_EXPRESSION" => & [] , "SIMPLE_NUMERIC_EXPRESSION" => & [] , "SLASH_EXPRESSION" => & [] , "SMEARED_MATERIAL_DEFINITION" => & [] , "SOLID_ANGLE_MEASURE_WITH_UNIT" => & [] , "SOLID_ANGLE_UNIT" => & [] , "SOLID_CURVE_FONT" => & [] , "SOLID_MODEL" => & [] , "SOLID_REPLICA" => & ["parent_solid" , "transformation" ,] , "SOLID_WITH_ANGLE_BASED_CHAMFER" => & ["offset_distance" , "left_offset" , "offset_angle" ,] , "SOLID_WITH_CHAMFERED_EDGES" => & [] , "SOLID_WITH_CIRCULAR_PATTERN" => & ["replicate_count" , "angular_spacing" , "radial_alignment" , "reference_point" ,] , "SOLID_WITH_CIRCULAR_POCKET" => & ["pocket_radius" ,] , "SOLID_WITH_CIRCULAR_PROTRUSION" => & ["protrusion_radius" ,] , "SOLID_WITH_CONICAL_BOTTOM_ROUND_HOLE" => & ["semi_apex_angle" , "tip_radius" ,] , "SOLID_WITH_CONSTANT_RADIUS_EDGE_BLEND" => & ["radius" ,] , "SOLID_WITH_CURVED_SLOT" => & ["slot_centreline" ,] , "SOLID_WITH_DEPRESSION" => & ["depth" ,] , "SOLID_WITH_DOUBLE_OFFSET_CHAMFER" => & ["left_offset_distance" , "right_offset_distance" ,] , "SOLID_WITH_FLAT_BOTTOM_ROUND_HOLE" => & ["fillet_radius" ,] , "SOLID_WITH_GENERAL_POCKET" => & ["profile" , "reference_point" ,] , "SOLID_WITH_GENERAL_PROTRUSION" => & ["profile" , "reference_point" ,] , "SOLID_WITH_GROOVE" => & ["groove_radius" , "groove_width" , "draft_angle" , "floor_fillet_radius" , "external_groove" ,] , "SOLID_WITH_HOLE" => & [] , "SOLID_WITH_INCOMPLETE_CIRCULAR_PATTERN" => & ["omitted_instances" ,] , "SOLID_WITH_INCOMPLETE_RECTANGULAR_PATTERN" => & ["omitted_instances" ,] , "SOLID_WITH_POCKET" => & ["floor_blend_radius" , "draft_angle" ,] , "SOLID_WITH_PROTRUSION" => & ["protrusion_height" , "protrusion_draft_angle" ,] , "SOLID_WITH_RECTANGULAR_PATTERN" => & ["row_count" , "column_count" , "row_spacing" , "column_spacing" ,] , "SOLID_WITH_RECTANGULAR_POCKET" => & ["pocket_length" , "pocket_width" , "corner_radius" ,] , "SOLID_WITH_RECTANGULAR_PROTRUSION" => & ["protrusion_length" , "protrusion_width" , "protrusion_corner_radius" ,] , "SOLID_WITH_SHAPE_ELEMENT_PATTERN" => & ["replicated_element" ,] , "SOLID_WITH_SINGLE_OFFSET_CHAMFER" => & ["offset_distance" ,] , "SOLID_WITH_SLOT" => & ["slot_width" , "closed_ends" , "end_exit_faces" ,] , "SOLID_WITH_SPHERICAL_BOTTOM_ROUND_HOLE" => & ["sphere_radius" ,] , "SOLID_WITH_STEPPED_ROUND_HOLE" => & ["segments" , "segment_radii" , "segment_depths" ,] , "SOLID_WITH_STEPPED_ROUND_HOLE_AND_CONICAL_TRANSITIONS" => & ["conical_transitions" ,] , "SOLID_WITH_STRAIGHT_SLOT" => & ["slot_length" ,] , "SOLID_WITH_TEE_SECTION_SLOT" => & ["tee_section_width" , "collar_depth" ,] , "SOLID_WITH_THROUGH_DEPRESSION" => & ["exit_faces" ,] , "SOLID_WITH_TRAPEZOIDAL_SECTION_SLOT" => & ["draft_angle" , "floor_fillet_radius" ,] , "SOLID_WITH_VARIABLE_RADIUS_EDGE_BLEND" => & ["point_list" , "radius_list" , "edge_function_list" ,] , "SOURCE_FOR_REQUIREMENT" => & ["items" ,] , "SOURCED_REQUIREMENT" => & ["items" ,] , "SPECIFICATION_DEFINITION" => & [] , "SPECIFIED_HIGHER_USAGE_OCCURRENCE" => & ["upper_usage" , "next_usage" ,] , "SPHERE" => & ["radius" , "centre" ,] , "SPHERICAL_SURFACE" => & ["radius" ,] , "STANDARD_UNCERTAINTY" => & ["uncertainty_value" ,] , "START_REQUEST" => & ["items" ,] , "START_WORK" => & ["items" ,] , "STRAIGHTNESS_TOLERANCE" => & [] , "STRUCTURED_DIMENSION_CALLOUT" => & [] , "STRUCTURED_TEXT_COMPOSITION" => & [] , "STRUCTURED_TEXT_REPRESENTATION" => & [] , "STYLED_ITEM" => & ["styles" , "item" ,] , "SUBEDGE" => & ["parent_edge" ,] , "SUBFACE" => & ["parent_face" ,] , "SUPPLIED_PART_RELATIONSHIP" => & [] , "SURFACE" => & [] , "SURFACE_CONDITION_CALLOUT" => & [] , "SURFACE_CURVE" => & ["curve_3d" , "associated_geometry" , "master_representation" ,] , "SURFACE_CURVE_SWEPT_AREA_SOLID" => & ["directrix" , "start_param" , "end_param" , "reference_surface" ,] , "SURFACE_OF_LINEAR_EXTRUSION" => & ["extrusion_axis" ,] , "SURFACE_OF_REVOLUTION" => & ["axis_position" ,] , "SURFACE_PATCH" => & ["parent_surface" , "u_transition" , "v_transition" , "u_sense" , "v_sense" ,] , "SURFACE_PROFILE_TOLERANCE" => & [] , "SURFACE_RENDERING_PROPERTIES" => & ["rendered_colour" ,] , "SURFACE_REPLICA" => & ["parent_surface" , "transformation" ,] , "SURFACE_SIDE_STYLE" => & ["name" , "styles" ,] , "SURFACE_STYLE_BOUNDARY" => & ["style_of_boundary" ,] , "SURFACE_STYLE_CONTROL_GRID" => & ["style_of_control_grid" ,] , "SURFACE_STYLE_FILL_AREA" => & ["fill_area" ,] , "SURFACE_STYLE_PARAMETER_LINE" => & ["style_of_parameter_lines" , "direction_counts" ,] , "SURFACE_STYLE_REFLECTANCE_AMBIENT" => & ["ambient_reflectance" ,] , "SURFACE_STYLE_REFLECTANCE_AMBIENT_DIFFUSE" => & ["diffuse_reflectance" ,] , "SURFACE_STYLE_REFLECTANCE_AMBIENT_DIFFUSE_SPECULAR" => & ["specular_reflectance" , "specular_exponent" , "specular_colour" ,] , "SURFACE_STYLE_RENDERING" => & ["rendering_method" , "surface_colour" ,] , "SURFACE_STYLE_RENDERING_WITH_PROPERTIES" => & ["properties" ,] , "SURFACE_STYLE_SEGMENTATION_CURVE" => & ["style_of_segmentation_curve" ,] , "SURFACE_STYLE_SILHOUETTE" => & ["style_of_silhouette" ,] , "SURFACE_STYLE_TRANSPARENT" => & ["transparency" ,] , "SURFACE_STYLE_USAGE" => & ["side" , "style" ,] , "SURFACE_TEXTURE_REPRESENTATION" => & [] , "SURFACED_OPEN_SHELL" => & [] , "SWEPT_AREA_SOLID" => & ["swept_area" ,] , "SWEPT_DISK_SOLID" => & ["directrix" , "radius" , "inner_radius" , "start_param" , "end_param" ,] , "SWEPT_FACE_SOLID" => & ["swept_face" ,] , "SWEPT_SURFACE" => & ["swept_curve" ,] , "SYMBOL" => & [] , "SYMBOL_COLOUR" => & ["colour_of_symbol" ,] , "SYMBOL_REPRESENTATION" => & [] , "SYMBOL_REPRESENTATION_MAP" => & [] , "SYMBOL_STYLE" => & ["name" , "style_of_symbol" ,] , "SYMBOL_TARGET" => & ["placement" , "x_scale" , "y_scale" ,] , "SYMMETRIC_SHAPE_ASPECT" => & [] , "SYMMETRY_TOLERANCE" => & [] , "TABLE_REPRESENTATION_ITEM" => & [] , "TACTILE_APPEARANCE_REPRESENTATION" => & [] , "TAGGED_TEXT_FORMAT" => & [] , "TAGGED_TEXT_ITEM" => & [] , "TANGENT" => & [] , "TERMINATOR_SYMBOL" => & ["annotated_curve" ,] , "TEXT_FONT" => & ["id" , "name" , "description" ,] , "TEXT_FONT_FAMILY" => & ["id" , "name" , "description" ,] , "TEXT_FONT_IN_FAMILY" => & ["font" , "family" ,] , "TEXT_LITERAL" => & ["literal" , "placement" , "alignment" , "path" , "font" ,] , "TEXT_LITERAL_WITH_ASSOCIATED_CURVES" => & ["associated_curves" ,] , "TEXT_LITERAL_WITH_BLANKING_BOX" => & ["blanking" ,] , "TEXT_LITERAL_WITH_DELINEATION" => & ["delineation" ,] , "TEXT_LITERAL_WITH_EXTENT" => & ["extent" ,] , "TEXT_STRING_REPRESENTATION" => & [] , "TEXT_STYLE" => & ["name" , "character_appearance" ,] , "TEXT_STYLE_FOR_DEFINED_FONT" => & ["text_colour" ,] , "TEXT_STYLE_WITH_BOX_CHARACTERISTICS" => & ["characteristics" ,] , "TEXT_STYLE_WITH_MIRROR" => & ["mirror_placement" ,] , "TEXT_STYLE_WITH_SPACING" => & ["character_spacing" ,] , "THERMAL_RESISTANCE_MEASURE_WITH_UNIT" => & [] , "THERMAL_RESISTANCE_UNIT" => & [] , "THERMODYNAMIC_TEMPERATURE_MEASURE_WITH_UNIT" => & [] , "THERMODYNAMIC_TEMPERATURE_UNIT" => & [] , "THICKENED_FACE_SOLID" => & ["base_element" , "offset1" , "offset2" ,] , "THICKNESS_LAMINATE_DEFINITION" => & [] , "THICKNESS_LAMINATE_TABLE" => & [] , "TIME_INTERVAL" => & ["id" , "name" , "description" ,] , "TIME_INTERVAL_ASSIGNMENT" => & ["assigned_time_interval" , "role" ,] , "TIME_INTERVAL_BASED_EFFECTIVITY" => & ["effectivity_period" ,] , "TIME_INTERVAL_RELATIONSHIP" => & ["name" , "description" , "relating_time_interval" , "related_time_interval" ,] , "TIME_INTERVAL_ROLE" => & ["name" , "description" ,] , "TIME_INTERVAL_WITH_BOUNDS" => & ["primary_bound" , "secondary_bound" , "duration" ,] , "TIME_MEASURE_WITH_UNIT" => & [] , "TIME_UNIT" => & [] , "TOLERANCE_VALUE" => & ["lower_bound" , "upper_bound" ,] , "TOLERANCE_ZONE" => & ["defining_tolerance" , "form" ,] , "TOLERANCE_ZONE_DEFINITION" => & ["zone" , "boundaries" ,] , "TOLERANCE_ZONE_FORM" => & ["name" ,] , "TOPOLOGICAL_REPRESENTATION_ITEM" => & [] , "TOROIDAL_SURFACE" => & ["major_radius" , "minor_radius" ,] , "TORUS" => & ["position" , "major_radius" , "minor_radius" ,] , "TOTAL_RUNOUT_TOLERANCE" => & [] , "TRACK_BLENDED_SOLID" => & [] , "TRACK_BLENDED_SOLID_WITH_END_CONDITIONS" => & ["end_conditions" ,] , "TRANSFORMATION_WITH_DERIVED_ANGLE" => & [] , "TRIMMED_CURVE" => & ["basis_curve" , "trim_1" , "trim_2" , "sense_agreement" , "master_representation" ,] , "TWO_DIRECTION_REPEAT_FACTOR" => & ["second_repeat_factor" ,] , "TYPE_QUALIFIER" => & ["name" ,] , "UNARY_GENERIC_EXPRESSION" => & ["operand" ,] , "UNARY_NUMERIC_EXPRESSION" => & [] , "UNCERTAINTY_ASSIGNED_REPRESENTATION" => & ["uncertainty" ,] , "UNCERTAINTY_MEASURE_WITH_UNIT" => & ["name" , "description" ,] , "UNCERTAINTY_QUALIFIER" => & ["measure_name" , "description" ,] , "UNIFORM_CURVE" => & [] , "UNIFORM_RESOURCE_IDENTIFIER" => & [] , "UNIFORM_SURFACE" => & [] , "USAGE_ASSOCIATION" => & [] , "USER_DEFINED_CURVE_FONT" => & [] , "USER_DEFINED_MARKER" => & [] , "USER_DEFINED_TERMINATOR_SYMBOL" => & [] , "USER_SELECTED_ELEMENTS" => & ["picked_items" ,] , "USER_SELECTED_SHAPE_ELEMENTS" => & [] , "VALUE_RANGE" => & [] , "VALUE_REPRESENTATION_ITEM" => & ["value_component" ,] , "VARIABLE_SEMANTICS" => & [] , "VARIATIONAL_REPRESENTATION_ITEM" => & [] , "VECTOR" => & ["orientation" , "magnitude" ,] , "VECTOR_STYLE" => & [] , "VELOCITY_MEASURE_WITH_UNIT" => & [] , "VELOCITY_UNIT" => & [] , "VERSIONED_ACTION_REQUEST" => & ["id" , "version" , "purpose" , "description" ,] , "VERTEX" => & [] , "VERTEX_LOOP" => & ["loop_vertex" ,] , "VERTEX_POINT" => & ["vertex_geometry" ,] , "VERTEX_SHELL" => & ["vertex_shell_extent" ,] , "VIEW_VOLUME" => & ["projection_type" , "projection_point" , "view_plane_distance" , "front_plane_distance" , "front_plane_clipping" , "back_plane_distance" , "back_plane_clipping" , "view_volume_sides_clipping" , "view_window" ,] , "VISUAL_APPEARANCE_REPRESENTATION" => & [] , "VOLUME_MEASURE_WITH_UNIT" => & [] , "VOLUME_UNIT" => & [] , "WEEK_OF_YEAR_AND_DAY_DATE" => & ["week_component" , "day_component" ,] , "WIRE_SHELL" => & ["wire_shell_extent" ,] , "YEAR_MONTH" => & ["month_component" ,] , "ZONE_STRUCTURAL_MAKEUP" => & [] , };
#[derive(Debug, Clone, PartialEq, Default, TableInit)]
pub struct Tables {
    absorbed_dose_measure_with_unit: HashMap<u64, as_holder!(AbsorbedDoseMeasureWithUnit)>,
    absorbed_dose_unit: HashMap<u64, as_holder!(AbsorbedDoseUnit)>,
    abstract_variable: HashMap<u64, as_holder!(AbstractVariable)>,
    acceleration_measure_with_unit: HashMap<u64, as_holder!(AccelerationMeasureWithUnit)>,
    acceleration_unit: HashMap<u64, as_holder!(AccelerationUnit)>,
    action: HashMap<u64, as_holder!(Action)>,
    action_assignment: HashMap<u64, as_holder!(ActionAssignment)>,
    action_directive: HashMap<u64, as_holder!(ActionDirective)>,
    action_method: HashMap<u64, as_holder!(ActionMethod)>,
    action_method_assignment: HashMap<u64, as_holder!(ActionMethodAssignment)>,
    action_method_relationship: HashMap<u64, as_holder!(ActionMethodRelationship)>,
    action_method_role: HashMap<u64, as_holder!(ActionMethodRole)>,
    action_property: HashMap<u64, as_holder!(ActionProperty)>,
    action_property_representation: HashMap<u64, as_holder!(ActionPropertyRepresentation)>,
    action_relationship: HashMap<u64, as_holder!(ActionRelationship)>,
    action_request_assignment: HashMap<u64, as_holder!(ActionRequestAssignment)>,
    action_request_solution: HashMap<u64, as_holder!(ActionRequestSolution)>,
    action_request_status: HashMap<u64, as_holder!(ActionRequestStatus)>,
    action_status: HashMap<u64, as_holder!(ActionStatus)>,
    address: HashMap<u64, as_holder!(Address)>,
    advanced_brep_shape_representation: HashMap<u64, as_holder!(AdvancedBrepShapeRepresentation)>,
    advanced_face: HashMap<u64, as_holder!(AdvancedFace)>,
    alternate_product_relationship: HashMap<u64, as_holder!(AlternateProductRelationship)>,
    amount_of_substance_measure_with_unit:
        HashMap<u64, as_holder!(AmountOfSubstanceMeasureWithUnit)>,
    amount_of_substance_unit: HashMap<u64, as_holder!(AmountOfSubstanceUnit)>,
    angle_direction_reference: HashMap<u64, as_holder!(AngleDirectionReference)>,
    angular_dimension: HashMap<u64, as_holder!(AngularDimension)>,
    angular_location: HashMap<u64, as_holder!(AngularLocation)>,
    angular_size: HashMap<u64, as_holder!(AngularSize)>,
    angularity_tolerance: HashMap<u64, as_holder!(AngularityTolerance)>,
    annotation_curve_occurrence: HashMap<u64, as_holder!(AnnotationCurveOccurrence)>,
    annotation_fill_area: HashMap<u64, as_holder!(AnnotationFillArea)>,
    annotation_fill_area_occurrence: HashMap<u64, as_holder!(AnnotationFillAreaOccurrence)>,
    annotation_occurrence: HashMap<u64, as_holder!(AnnotationOccurrence)>,
    annotation_occurrence_associativity:
        HashMap<u64, as_holder!(AnnotationOccurrenceAssociativity)>,
    annotation_occurrence_relationship: HashMap<u64, as_holder!(AnnotationOccurrenceRelationship)>,
    annotation_plane: HashMap<u64, as_holder!(AnnotationPlane)>,
    annotation_subfigure_occurrence: HashMap<u64, as_holder!(AnnotationSubfigureOccurrence)>,
    annotation_symbol: HashMap<u64, as_holder!(AnnotationSymbol)>,
    annotation_symbol_occurrence: HashMap<u64, as_holder!(AnnotationSymbolOccurrence)>,
    annotation_text: HashMap<u64, as_holder!(AnnotationText)>,
    annotation_text_character: HashMap<u64, as_holder!(AnnotationTextCharacter)>,
    annotation_text_occurrence: HashMap<u64, as_holder!(AnnotationTextOccurrence)>,
    apex: HashMap<u64, as_holder!(Apex)>,
    application_context: HashMap<u64, as_holder!(ApplicationContext)>,
    application_context_element: HashMap<u64, as_holder!(ApplicationContextElement)>,
    application_protocol_definition: HashMap<u64, as_holder!(ApplicationProtocolDefinition)>,
    applied_action_assignment: HashMap<u64, as_holder!(AppliedActionAssignment)>,
    applied_action_method_assignment: HashMap<u64, as_holder!(AppliedActionMethodAssignment)>,
    applied_action_request_assignment: HashMap<u64, as_holder!(AppliedActionRequestAssignment)>,
    applied_approval_assignment: HashMap<u64, as_holder!(AppliedApprovalAssignment)>,
    applied_attribute_classification_assignment:
        HashMap<u64, as_holder!(AppliedAttributeClassificationAssignment)>,
    applied_certification_assignment: HashMap<u64, as_holder!(AppliedCertificationAssignment)>,
    applied_classification_assignment: HashMap<u64, as_holder!(AppliedClassificationAssignment)>,
    applied_contract_assignment: HashMap<u64, as_holder!(AppliedContractAssignment)>,
    applied_date_and_time_assignment: HashMap<u64, as_holder!(AppliedDateAndTimeAssignment)>,
    applied_date_assignment: HashMap<u64, as_holder!(AppliedDateAssignment)>,
    applied_document_reference: HashMap<u64, as_holder!(AppliedDocumentReference)>,
    applied_document_usage_constraint_assignment:
        HashMap<u64, as_holder!(AppliedDocumentUsageConstraintAssignment)>,
    applied_effectivity_assignment: HashMap<u64, as_holder!(AppliedEffectivityAssignment)>,
    applied_event_occurrence_assignment: HashMap<u64, as_holder!(AppliedEventOccurrenceAssignment)>,
    applied_external_identification_assignment:
        HashMap<u64, as_holder!(AppliedExternalIdentificationAssignment)>,
    applied_group_assignment: HashMap<u64, as_holder!(AppliedGroupAssignment)>,
    applied_identification_assignment: HashMap<u64, as_holder!(AppliedIdentificationAssignment)>,
    applied_name_assignment: HashMap<u64, as_holder!(AppliedNameAssignment)>,
    applied_organization_assignment: HashMap<u64, as_holder!(AppliedOrganizationAssignment)>,
    applied_organizational_project_assignment:
        HashMap<u64, as_holder!(AppliedOrganizationalProjectAssignment)>,
    applied_person_and_organization_assignment:
        HashMap<u64, as_holder!(AppliedPersonAndOrganizationAssignment)>,
    applied_presented_item: HashMap<u64, as_holder!(AppliedPresentedItem)>,
    applied_security_classification_assignment:
        HashMap<u64, as_holder!(AppliedSecurityClassificationAssignment)>,
    applied_time_interval_assignment: HashMap<u64, as_holder!(AppliedTimeIntervalAssignment)>,
    applied_usage_right: HashMap<u64, as_holder!(AppliedUsageRight)>,
    approval: HashMap<u64, as_holder!(Approval)>,
    approval_assignment: HashMap<u64, as_holder!(ApprovalAssignment)>,
    approval_date_time: HashMap<u64, as_holder!(ApprovalDateTime)>,
    approval_person_organization: HashMap<u64, as_holder!(ApprovalPersonOrganization)>,
    approval_relationship: HashMap<u64, as_holder!(ApprovalRelationship)>,
    approval_role: HashMap<u64, as_holder!(ApprovalRole)>,
    approval_status: HashMap<u64, as_holder!(ApprovalStatus)>,
    area_in_set: HashMap<u64, as_holder!(AreaInSet)>,
    area_measure_with_unit: HashMap<u64, as_holder!(AreaMeasureWithUnit)>,
    area_unit: HashMap<u64, as_holder!(AreaUnit)>,
    assembly_component_usage: HashMap<u64, as_holder!(AssemblyComponentUsage)>,
    assembly_component_usage_substitute: HashMap<u64, as_holder!(AssemblyComponentUsageSubstitute)>,
    assigned_requirement: HashMap<u64, as_holder!(AssignedRequirement)>,
    atomic_formula: HashMap<u64, as_holder!(AtomicFormula)>,
    attribute_assertion: HashMap<u64, as_holder!(AttributeAssertion)>,
    attribute_classification_assignment:
        HashMap<u64, as_holder!(AttributeClassificationAssignment)>,
    attribute_language_assignment: HashMap<u64, as_holder!(AttributeLanguageAssignment)>,
    attribute_value_assignment: HashMap<u64, as_holder!(AttributeValueAssignment)>,
    attribute_value_role: HashMap<u64, as_holder!(AttributeValueRole)>,
    auxiliary_geometric_representation_item:
        HashMap<u64, as_holder!(AuxiliaryGeometricRepresentationItem)>,
    axis1_placement: HashMap<u64, as_holder!(Axis1Placement)>,
    axis2_placement_2d: HashMap<u64, as_holder!(Axis2Placement2D)>,
    axis2_placement_3d: HashMap<u64, as_holder!(Axis2Placement3D)>,
    b_spline_curve: HashMap<u64, as_holder!(BSplineCurve)>,
    b_spline_curve_with_knots: HashMap<u64, as_holder!(BSplineCurveWithKnots)>,
    b_spline_surface: HashMap<u64, as_holder!(BSplineSurface)>,
    b_spline_surface_with_knots: HashMap<u64, as_holder!(BSplineSurfaceWithKnots)>,
    back_chaining_rule: HashMap<u64, as_holder!(BackChainingRule)>,
    back_chaining_rule_body: HashMap<u64, as_holder!(BackChainingRuleBody)>,
    background_colour: HashMap<u64, as_holder!(BackgroundColour)>,
    beveled_sheet_representation: HashMap<u64, as_holder!(BeveledSheetRepresentation)>,
    bezier_curve: HashMap<u64, as_holder!(BezierCurve)>,
    bezier_surface: HashMap<u64, as_holder!(BezierSurface)>,
    binary_generic_expression: HashMap<u64, as_holder!(BinaryGenericExpression)>,
    binary_numeric_expression: HashMap<u64, as_holder!(BinaryNumericExpression)>,
    binary_representation_item: HashMap<u64, as_holder!(BinaryRepresentationItem)>,
    block: HashMap<u64, as_holder!(Block)>,
    boolean_expression: HashMap<u64, as_holder!(BooleanExpression)>,
    boolean_literal: HashMap<u64, as_holder!(BooleanLiteral)>,
    boolean_representation_item: HashMap<u64, as_holder!(BooleanRepresentationItem)>,
    boolean_result: HashMap<u64, as_holder!(BooleanResult)>,
    boundary_curve: HashMap<u64, as_holder!(BoundaryCurve)>,
    bounded_curve: HashMap<u64, as_holder!(BoundedCurve)>,
    bounded_pcurve: HashMap<u64, as_holder!(BoundedPcurve)>,
    bounded_surface: HashMap<u64, as_holder!(BoundedSurface)>,
    bounded_surface_curve: HashMap<u64, as_holder!(BoundedSurfaceCurve)>,
    box_domain: HashMap<u64, as_holder!(BoxDomain)>,
    boxed_half_space: HashMap<u64, as_holder!(BoxedHalfSpace)>,
    breakdown_context: HashMap<u64, as_holder!(BreakdownContext)>,
    breakdown_element_group_assignment: HashMap<u64, as_holder!(BreakdownElementGroupAssignment)>,
    breakdown_element_realization: HashMap<u64, as_holder!(BreakdownElementRealization)>,
    breakdown_element_usage: HashMap<u64, as_holder!(BreakdownElementUsage)>,
    breakdown_of: HashMap<u64, as_holder!(BreakdownOf)>,
    brep_with_voids: HashMap<u64, as_holder!(BrepWithVoids)>,
    bytes_representation_item: HashMap<u64, as_holder!(BytesRepresentationItem)>,
    calendar_date: HashMap<u64, as_holder!(CalendarDate)>,
    camera_image: HashMap<u64, as_holder!(CameraImage)>,
    camera_image_3d_with_scale: HashMap<u64, as_holder!(CameraImage3DWithScale)>,
    camera_model: HashMap<u64, as_holder!(CameraModel)>,
    camera_model_d3: HashMap<u64, as_holder!(CameraModelD3)>,
    camera_model_d3_multi_clipping: HashMap<u64, as_holder!(CameraModelD3MultiClipping)>,
    camera_model_d3_multi_clipping_intersection:
        HashMap<u64, as_holder!(CameraModelD3MultiClippingIntersection)>,
    camera_model_d3_multi_clipping_union: HashMap<u64, as_holder!(CameraModelD3MultiClippingUnion)>,
    camera_model_d3_with_hlhsr: HashMap<u64, as_holder!(CameraModelD3WithHlhsr)>,
    camera_model_with_light_sources: HashMap<u64, as_holder!(CameraModelWithLightSources)>,
    camera_usage: HashMap<u64, as_holder!(CameraUsage)>,
    capacitance_measure_with_unit: HashMap<u64, as_holder!(CapacitanceMeasureWithUnit)>,
    capacitance_unit: HashMap<u64, as_holder!(CapacitanceUnit)>,
    cartesian_point: HashMap<u64, as_holder!(CartesianPoint)>,
    cartesian_transformation_operator: HashMap<u64, as_holder!(CartesianTransformationOperator)>,
    cartesian_transformation_operator_2d:
        HashMap<u64, as_holder!(CartesianTransformationOperator2D)>,
    cartesian_transformation_operator_3d:
        HashMap<u64, as_holder!(CartesianTransformationOperator3D)>,
    cc_design_approval: HashMap<u64, as_holder!(CcDesignApproval)>,
    cc_design_certification: HashMap<u64, as_holder!(CcDesignCertification)>,
    cc_design_contract: HashMap<u64, as_holder!(CcDesignContract)>,
    cc_design_date_and_time_assignment: HashMap<u64, as_holder!(CcDesignDateAndTimeAssignment)>,
    cc_design_person_and_organization_assignment:
        HashMap<u64, as_holder!(CcDesignPersonAndOrganizationAssignment)>,
    cc_design_security_classification: HashMap<u64, as_holder!(CcDesignSecurityClassification)>,
    cc_design_specification_reference: HashMap<u64, as_holder!(CcDesignSpecificationReference)>,
    celsius_temperature_measure_with_unit:
        HashMap<u64, as_holder!(CelsiusTemperatureMeasureWithUnit)>,
    centre_of_symmetry: HashMap<u64, as_holder!(CentreOfSymmetry)>,
    certification: HashMap<u64, as_holder!(Certification)>,
    certification_assignment: HashMap<u64, as_holder!(CertificationAssignment)>,
    certification_type: HashMap<u64, as_holder!(CertificationType)>,
    change: HashMap<u64, as_holder!(Change)>,
    change_request: HashMap<u64, as_holder!(ChangeRequest)>,
    character_glyph_font_usage: HashMap<u64, as_holder!(CharacterGlyphFontUsage)>,
    character_glyph_style_outline: HashMap<u64, as_holder!(CharacterGlyphStyleOutline)>,
    character_glyph_style_stroke: HashMap<u64, as_holder!(CharacterGlyphStyleStroke)>,
    character_glyph_symbol: HashMap<u64, as_holder!(CharacterGlyphSymbol)>,
    character_glyph_symbol_outline: HashMap<u64, as_holder!(CharacterGlyphSymbolOutline)>,
    character_glyph_symbol_stroke: HashMap<u64, as_holder!(CharacterGlyphSymbolStroke)>,
    characteristic_data_column_header: HashMap<u64, as_holder!(CharacteristicDataColumnHeader)>,
    characteristic_data_column_header_link:
        HashMap<u64, as_holder!(CharacteristicDataColumnHeaderLink)>,
    characteristic_data_table_header: HashMap<u64, as_holder!(CharacteristicDataTableHeader)>,
    characteristic_data_table_header_decomposition:
        HashMap<u64, as_holder!(CharacteristicDataTableHeaderDecomposition)>,
    characteristic_type: HashMap<u64, as_holder!(CharacteristicType)>,
    characterized_class: HashMap<u64, as_holder!(CharacterizedClass)>,
    characterized_object: HashMap<u64, as_holder!(CharacterizedObject)>,
    circle: HashMap<u64, as_holder!(Circle)>,
    circular_runout_tolerance: HashMap<u64, as_holder!(CircularRunoutTolerance)>,
    class: HashMap<u64, as_holder!(Class)>,
    class_by_extension: HashMap<u64, as_holder!(ClassByExtension)>,
    class_by_intension: HashMap<u64, as_holder!(ClassByIntension)>,
    class_system: HashMap<u64, as_holder!(ClassSystem)>,
    class_usage_effectivity_context_assignment:
        HashMap<u64, as_holder!(ClassUsageEffectivityContextAssignment)>,
    classification_assignment: HashMap<u64, as_holder!(ClassificationAssignment)>,
    classification_role: HashMap<u64, as_holder!(ClassificationRole)>,
    closed_shell: HashMap<u64, as_holder!(ClosedShell)>,
    coaxiality_tolerance: HashMap<u64, as_holder!(CoaxialityTolerance)>,
    colour: HashMap<u64, as_holder!(Colour)>,
    colour_rgb: HashMap<u64, as_holder!(ColourRgb)>,
    colour_specification: HashMap<u64, as_holder!(ColourSpecification)>,
    common_datum: HashMap<u64, as_holder!(CommonDatum)>,
    comparison_expression: HashMap<u64, as_holder!(ComparisonExpression)>,
    complex_clause: HashMap<u64, as_holder!(ComplexClause)>,
    complex_conjunctive_clause: HashMap<u64, as_holder!(ComplexConjunctiveClause)>,
    complex_disjunctive_clause: HashMap<u64, as_holder!(ComplexDisjunctiveClause)>,
    complex_shelled_solid: HashMap<u64, as_holder!(ComplexShelledSolid)>,
    composite_assembly_definition: HashMap<u64, as_holder!(CompositeAssemblyDefinition)>,
    composite_assembly_sequence_definition:
        HashMap<u64, as_holder!(CompositeAssemblySequenceDefinition)>,
    composite_assembly_table: HashMap<u64, as_holder!(CompositeAssemblyTable)>,
    composite_curve: HashMap<u64, as_holder!(CompositeCurve)>,
    composite_curve_on_surface: HashMap<u64, as_holder!(CompositeCurveOnSurface)>,
    composite_curve_segment: HashMap<u64, as_holder!(CompositeCurveSegment)>,
    composite_material_designation: HashMap<u64, as_holder!(CompositeMaterialDesignation)>,
    composite_shape_aspect: HashMap<u64, as_holder!(CompositeShapeAspect)>,
    composite_sheet_representation: HashMap<u64, as_holder!(CompositeSheetRepresentation)>,
    composite_text: HashMap<u64, as_holder!(CompositeText)>,
    composite_text_with_associated_curves:
        HashMap<u64, as_holder!(CompositeTextWithAssociatedCurves)>,
    composite_text_with_blanking_box: HashMap<u64, as_holder!(CompositeTextWithBlankingBox)>,
    composite_text_with_delineation: HashMap<u64, as_holder!(CompositeTextWithDelineation)>,
    composite_text_with_extent: HashMap<u64, as_holder!(CompositeTextWithExtent)>,
    compound_representation_item: HashMap<u64, as_holder!(CompoundRepresentationItem)>,
    compound_shape_representation: HashMap<u64, as_holder!(CompoundShapeRepresentation)>,
    concentricity_tolerance: HashMap<u64, as_holder!(ConcentricityTolerance)>,
    concept_feature_operator: HashMap<u64, as_holder!(ConceptFeatureOperator)>,
    concept_feature_relationship: HashMap<u64, as_holder!(ConceptFeatureRelationship)>,
    concept_feature_relationship_with_condition:
        HashMap<u64, as_holder!(ConceptFeatureRelationshipWithCondition)>,
    conditional_concept_feature: HashMap<u64, as_holder!(ConditionalConceptFeature)>,
    conductance_measure_with_unit: HashMap<u64, as_holder!(ConductanceMeasureWithUnit)>,
    conductance_unit: HashMap<u64, as_holder!(ConductanceUnit)>,
    configurable_item: HashMap<u64, as_holder!(ConfigurableItem)>,
    configuration_design: HashMap<u64, as_holder!(ConfigurationDesign)>,
    configuration_effectivity: HashMap<u64, as_holder!(ConfigurationEffectivity)>,
    configuration_item: HashMap<u64, as_holder!(ConfigurationItem)>,
    configuration_item_hierarchical_relationship:
        HashMap<u64, as_holder!(ConfigurationItemHierarchicalRelationship)>,
    configuration_item_relationship: HashMap<u64, as_holder!(ConfigurationItemRelationship)>,
    configuration_item_revision_sequence:
        HashMap<u64, as_holder!(ConfigurationItemRevisionSequence)>,
    configured_effectivity_assignment: HashMap<u64, as_holder!(ConfiguredEffectivityAssignment)>,
    configured_effectivity_context_assignment:
        HashMap<u64, as_holder!(ConfiguredEffectivityContextAssignment)>,
    conic: HashMap<u64, as_holder!(Conic)>,
    conical_stepped_hole_transition: HashMap<u64, as_holder!(ConicalSteppedHoleTransition)>,
    conical_surface: HashMap<u64, as_holder!(ConicalSurface)>,
    connected_edge_set: HashMap<u64, as_holder!(ConnectedEdgeSet)>,
    connected_face_set: HashMap<u64, as_holder!(ConnectedFaceSet)>,
    connected_face_sub_set: HashMap<u64, as_holder!(ConnectedFaceSubSet)>,
    constructive_geometry_representation:
        HashMap<u64, as_holder!(ConstructiveGeometryRepresentation)>,
    constructive_geometry_representation_relationship:
        HashMap<u64, as_holder!(ConstructiveGeometryRepresentationRelationship)>,
    contact_ratio_representation: HashMap<u64, as_holder!(ContactRatioRepresentation)>,
    context_dependent_invisibility: HashMap<u64, as_holder!(ContextDependentInvisibility)>,
    context_dependent_over_riding_styled_item:
        HashMap<u64, as_holder!(ContextDependentOverRidingStyledItem)>,
    context_dependent_shape_representation:
        HashMap<u64, as_holder!(ContextDependentShapeRepresentation)>,
    context_dependent_unit: HashMap<u64, as_holder!(ContextDependentUnit)>,
    contract: HashMap<u64, as_holder!(Contract)>,
    contract_assignment: HashMap<u64, as_holder!(ContractAssignment)>,
    contract_relationship: HashMap<u64, as_holder!(ContractRelationship)>,
    contract_type: HashMap<u64, as_holder!(ContractType)>,
    conversion_based_unit: HashMap<u64, as_holder!(ConversionBasedUnit)>,
    coordinated_universal_time_offset: HashMap<u64, as_holder!(CoordinatedUniversalTimeOffset)>,
    csg_shape_representation: HashMap<u64, as_holder!(CsgShapeRepresentation)>,
    csg_solid: HashMap<u64, as_holder!(CsgSolid)>,
    currency: HashMap<u64, as_holder!(Currency)>,
    currency_measure_with_unit: HashMap<u64, as_holder!(CurrencyMeasureWithUnit)>,
    curve: HashMap<u64, as_holder!(Curve)>,
    curve_bounded_surface: HashMap<u64, as_holder!(CurveBoundedSurface)>,
    curve_dimension: HashMap<u64, as_holder!(CurveDimension)>,
    curve_replica: HashMap<u64, as_holder!(CurveReplica)>,
    curve_style: HashMap<u64, as_holder!(CurveStyle)>,
    curve_style_font: HashMap<u64, as_holder!(CurveStyleFont)>,
    curve_style_font_and_scaling: HashMap<u64, as_holder!(CurveStyleFontAndScaling)>,
    curve_style_font_pattern: HashMap<u64, as_holder!(CurveStyleFontPattern)>,
    curve_style_rendering: HashMap<u64, as_holder!(CurveStyleRendering)>,
    curve_swept_solid_shape_representation:
        HashMap<u64, as_holder!(CurveSweptSolidShapeRepresentation)>,
    cylindrical_surface: HashMap<u64, as_holder!(CylindricalSurface)>,
    cylindricity_tolerance: HashMap<u64, as_holder!(CylindricityTolerance)>,
    data_environment: HashMap<u64, as_holder!(DataEnvironment)>,
    date: HashMap<u64, as_holder!(Date)>,
    date_and_time: HashMap<u64, as_holder!(DateAndTime)>,
    date_and_time_assignment: HashMap<u64, as_holder!(DateAndTimeAssignment)>,
    date_assignment: HashMap<u64, as_holder!(DateAssignment)>,
    date_representation_item: HashMap<u64, as_holder!(DateRepresentationItem)>,
    date_role: HashMap<u64, as_holder!(DateRole)>,
    date_time_representation_item: HashMap<u64, as_holder!(DateTimeRepresentationItem)>,
    date_time_role: HashMap<u64, as_holder!(DateTimeRole)>,
    dated_effectivity: HashMap<u64, as_holder!(DatedEffectivity)>,
    datum: HashMap<u64, as_holder!(Datum)>,
    datum_feature: HashMap<u64, as_holder!(DatumFeature)>,
    datum_feature_callout: HashMap<u64, as_holder!(DatumFeatureCallout)>,
    datum_reference: HashMap<u64, as_holder!(DatumReference)>,
    datum_target: HashMap<u64, as_holder!(DatumTarget)>,
    datum_target_callout: HashMap<u64, as_holder!(DatumTargetCallout)>,
    default_tolerance_table: HashMap<u64, as_holder!(DefaultToleranceTable)>,
    default_tolerance_table_cell: HashMap<u64, as_holder!(DefaultToleranceTableCell)>,
    defined_symbol: HashMap<u64, as_holder!(DefinedSymbol)>,
    definitional_representation: HashMap<u64, as_holder!(DefinitionalRepresentation)>,
    definitional_representation_relationship:
        HashMap<u64, as_holder!(DefinitionalRepresentationRelationship)>,
    definitional_representation_relationship_with_same_context:
        HashMap<u64, as_holder!(DefinitionalRepresentationRelationshipWithSameContext)>,
    degenerate_pcurve: HashMap<u64, as_holder!(DegeneratePcurve)>,
    degenerate_toroidal_surface: HashMap<u64, as_holder!(DegenerateToroidalSurface)>,
    derived_shape_aspect: HashMap<u64, as_holder!(DerivedShapeAspect)>,
    derived_unit: HashMap<u64, as_holder!(DerivedUnit)>,
    derived_unit_element: HashMap<u64, as_holder!(DerivedUnitElement)>,
    description_attribute: HashMap<u64, as_holder!(DescriptionAttribute)>,
    descriptive_representation_item: HashMap<u64, as_holder!(DescriptiveRepresentationItem)>,
    design_context: HashMap<u64, as_holder!(DesignContext)>,
    design_make_from_relationship: HashMap<u64, as_holder!(DesignMakeFromRelationship)>,
    diameter_dimension: HashMap<u64, as_holder!(DiameterDimension)>,
    dielectric_constant_measure_with_unit:
        HashMap<u64, as_holder!(DielectricConstantMeasureWithUnit)>,
    dimension_callout: HashMap<u64, as_holder!(DimensionCallout)>,
    dimension_callout_component_relationship:
        HashMap<u64, as_holder!(DimensionCalloutComponentRelationship)>,
    dimension_callout_relationship: HashMap<u64, as_holder!(DimensionCalloutRelationship)>,
    dimension_curve: HashMap<u64, as_holder!(DimensionCurve)>,
    dimension_curve_directed_callout: HashMap<u64, as_holder!(DimensionCurveDirectedCallout)>,
    dimension_curve_terminator: HashMap<u64, as_holder!(DimensionCurveTerminator)>,
    dimension_curve_terminator_to_projection_curve_associativity:
        HashMap<u64, as_holder!(DimensionCurveTerminatorToProjectionCurveAssociativity)>,
    dimension_pair: HashMap<u64, as_holder!(DimensionPair)>,
    dimension_related_tolerance_zone_element:
        HashMap<u64, as_holder!(DimensionRelatedToleranceZoneElement)>,
    dimension_text_associativity: HashMap<u64, as_holder!(DimensionTextAssociativity)>,
    dimensional_characteristic_representation:
        HashMap<u64, as_holder!(DimensionalCharacteristicRepresentation)>,
    dimensional_exponents: HashMap<u64, as_holder!(DimensionalExponents)>,
    dimensional_location: HashMap<u64, as_holder!(DimensionalLocation)>,
    dimensional_location_with_path: HashMap<u64, as_holder!(DimensionalLocationWithPath)>,
    dimensional_size: HashMap<u64, as_holder!(DimensionalSize)>,
    dimensional_size_with_path: HashMap<u64, as_holder!(DimensionalSizeWithPath)>,
    directed_action: HashMap<u64, as_holder!(DirectedAction)>,
    directed_dimensional_location: HashMap<u64, as_holder!(DirectedDimensionalLocation)>,
    direction: HashMap<u64, as_holder!(Direction)>,
    document: HashMap<u64, as_holder!(Document)>,
    document_file: HashMap<u64, as_holder!(DocumentFile)>,
    document_identifier: HashMap<u64, as_holder!(DocumentIdentifier)>,
    document_identifier_assignment: HashMap<u64, as_holder!(DocumentIdentifierAssignment)>,
    document_product_association: HashMap<u64, as_holder!(DocumentProductAssociation)>,
    document_product_equivalence: HashMap<u64, as_holder!(DocumentProductEquivalence)>,
    document_reference: HashMap<u64, as_holder!(DocumentReference)>,
    document_relationship: HashMap<u64, as_holder!(DocumentRelationship)>,
    document_representation_type: HashMap<u64, as_holder!(DocumentRepresentationType)>,
    document_type: HashMap<u64, as_holder!(DocumentType)>,
    document_usage_constraint: HashMap<u64, as_holder!(DocumentUsageConstraint)>,
    document_usage_constraint_assignment:
        HashMap<u64, as_holder!(DocumentUsageConstraintAssignment)>,
    document_usage_role: HashMap<u64, as_holder!(DocumentUsageRole)>,
    dose_equivalent_measure_with_unit: HashMap<u64, as_holder!(DoseEquivalentMeasureWithUnit)>,
    dose_equivalent_unit: HashMap<u64, as_holder!(DoseEquivalentUnit)>,
    double_offset_shelled_solid: HashMap<u64, as_holder!(DoubleOffsetShelledSolid)>,
    draped_defined_transformation: HashMap<u64, as_holder!(DrapedDefinedTransformation)>,
    draughting_annotation_occurrence: HashMap<u64, as_holder!(DraughtingAnnotationOccurrence)>,
    draughting_callout: HashMap<u64, as_holder!(DraughtingCallout)>,
    draughting_callout_relationship: HashMap<u64, as_holder!(DraughtingCalloutRelationship)>,
    draughting_elements: HashMap<u64, as_holder!(DraughtingElements)>,
    draughting_model: HashMap<u64, as_holder!(DraughtingModel)>,
    draughting_model_item_association: HashMap<u64, as_holder!(DraughtingModelItemAssociation)>,
    draughting_pre_defined_colour: HashMap<u64, as_holder!(DraughtingPreDefinedColour)>,
    draughting_pre_defined_curve_font: HashMap<u64, as_holder!(DraughtingPreDefinedCurveFont)>,
    draughting_pre_defined_text_font: HashMap<u64, as_holder!(DraughtingPreDefinedTextFont)>,
    draughting_subfigure_representation:
        HashMap<u64, as_holder!(DraughtingSubfigureRepresentation)>,
    draughting_symbol_representation: HashMap<u64, as_holder!(DraughtingSymbolRepresentation)>,
    draughting_text_literal_with_delineation:
        HashMap<u64, as_holder!(DraughtingTextLiteralWithDelineation)>,
    draughting_title: HashMap<u64, as_holder!(DraughtingTitle)>,
    drawing_definition: HashMap<u64, as_holder!(DrawingDefinition)>,
    drawing_revision: HashMap<u64, as_holder!(DrawingRevision)>,
    drawing_revision_sequence: HashMap<u64, as_holder!(DrawingRevisionSequence)>,
    drawing_sheet_revision: HashMap<u64, as_holder!(DrawingSheetRevision)>,
    drawing_sheet_revision_sequence: HashMap<u64, as_holder!(DrawingSheetRevisionSequence)>,
    drawing_sheet_revision_usage: HashMap<u64, as_holder!(DrawingSheetRevisionUsage)>,
    edge: HashMap<u64, as_holder!(Edge)>,
    edge_based_wireframe_model: HashMap<u64, as_holder!(EdgeBasedWireframeModel)>,
    edge_based_wireframe_shape_representation:
        HashMap<u64, as_holder!(EdgeBasedWireframeShapeRepresentation)>,
    edge_blended_solid: HashMap<u64, as_holder!(EdgeBlendedSolid)>,
    edge_curve: HashMap<u64, as_holder!(EdgeCurve)>,
    edge_loop: HashMap<u64, as_holder!(EdgeLoop)>,
    effectivity: HashMap<u64, as_holder!(Effectivity)>,
    effectivity_assignment: HashMap<u64, as_holder!(EffectivityAssignment)>,
    effectivity_context_assignment: HashMap<u64, as_holder!(EffectivityContextAssignment)>,
    effectivity_context_role: HashMap<u64, as_holder!(EffectivityContextRole)>,
    effectivity_relationship: HashMap<u64, as_holder!(EffectivityRelationship)>,
    electric_charge_measure_with_unit: HashMap<u64, as_holder!(ElectricChargeMeasureWithUnit)>,
    electric_charge_unit: HashMap<u64, as_holder!(ElectricChargeUnit)>,
    electric_current_measure_with_unit: HashMap<u64, as_holder!(ElectricCurrentMeasureWithUnit)>,
    electric_current_unit: HashMap<u64, as_holder!(ElectricCurrentUnit)>,
    electric_potential_measure_with_unit:
        HashMap<u64, as_holder!(ElectricPotentialMeasureWithUnit)>,
    electric_potential_unit: HashMap<u64, as_holder!(ElectricPotentialUnit)>,
    elementary_brep_shape_representation:
        HashMap<u64, as_holder!(ElementaryBrepShapeRepresentation)>,
    elementary_surface: HashMap<u64, as_holder!(ElementarySurface)>,
    ellipse: HashMap<u64, as_holder!(Ellipse)>,
    energy_measure_with_unit: HashMap<u64, as_holder!(EnergyMeasureWithUnit)>,
    energy_unit: HashMap<u64, as_holder!(EnergyUnit)>,
    entity_assertion: HashMap<u64, as_holder!(EntityAssertion)>,
    enum_reference_prefix: HashMap<u64, as_holder!(EnumReferencePrefix)>,
    environment: HashMap<u64, as_holder!(Environment)>,
    evaluated_characteristic: HashMap<u64, as_holder!(EvaluatedCharacteristic)>,
    evaluated_degenerate_pcurve: HashMap<u64, as_holder!(EvaluatedDegeneratePcurve)>,
    evaluation_product_definition: HashMap<u64, as_holder!(EvaluationProductDefinition)>,
    event_occurrence: HashMap<u64, as_holder!(EventOccurrence)>,
    event_occurrence_assignment: HashMap<u64, as_holder!(EventOccurrenceAssignment)>,
    event_occurrence_relationship: HashMap<u64, as_holder!(EventOccurrenceRelationship)>,
    event_occurrence_role: HashMap<u64, as_holder!(EventOccurrenceRole)>,
    exclusive_product_concept_feature_category:
        HashMap<u64, as_holder!(ExclusiveProductConceptFeatureCategory)>,
    executed_action: HashMap<u64, as_holder!(ExecutedAction)>,
    expanded_uncertainty: HashMap<u64, as_holder!(ExpandedUncertainty)>,
    explicit_procedural_geometric_representation_item_relationship:
        HashMap<u64, as_holder!(ExplicitProceduralGeometricRepresentationItemRelationship)>,
    explicit_procedural_representation_item_relationship:
        HashMap<u64, as_holder!(ExplicitProceduralRepresentationItemRelationship)>,
    explicit_procedural_representation_relationship:
        HashMap<u64, as_holder!(ExplicitProceduralRepresentationRelationship)>,
    explicit_procedural_shape_representation_relationship:
        HashMap<u64, as_holder!(ExplicitProceduralShapeRepresentationRelationship)>,
    expression: HashMap<u64, as_holder!(Expression)>,
    expression_conversion_based_unit: HashMap<u64, as_holder!(ExpressionConversionBasedUnit)>,
    extension: HashMap<u64, as_holder!(Extension)>,
    extent: HashMap<u64, as_holder!(Extent)>,
    external_class_library: HashMap<u64, as_holder!(ExternalClassLibrary)>,
    external_identification_assignment: HashMap<u64, as_holder!(ExternalIdentificationAssignment)>,
    external_source: HashMap<u64, as_holder!(ExternalSource)>,
    external_source_relationship: HashMap<u64, as_holder!(ExternalSourceRelationship)>,
    externally_defined_class: HashMap<u64, as_holder!(ExternallyDefinedClass)>,
    externally_defined_colour: HashMap<u64, as_holder!(ExternallyDefinedColour)>,
    externally_defined_context_dependent_unit:
        HashMap<u64, as_holder!(ExternallyDefinedContextDependentUnit)>,
    externally_defined_conversion_based_unit:
        HashMap<u64, as_holder!(ExternallyDefinedConversionBasedUnit)>,
    externally_defined_currency: HashMap<u64, as_holder!(ExternallyDefinedCurrency)>,
    externally_defined_curve_font: HashMap<u64, as_holder!(ExternallyDefinedCurveFont)>,
    externally_defined_dimension_definition:
        HashMap<u64, as_holder!(ExternallyDefinedDimensionDefinition)>,
    externally_defined_general_property: HashMap<u64, as_holder!(ExternallyDefinedGeneralProperty)>,
    externally_defined_hatch_style: HashMap<u64, as_holder!(ExternallyDefinedHatchStyle)>,
    externally_defined_item: HashMap<u64, as_holder!(ExternallyDefinedItem)>,
    externally_defined_item_relationship:
        HashMap<u64, as_holder!(ExternallyDefinedItemRelationship)>,
    externally_defined_marker: HashMap<u64, as_holder!(ExternallyDefinedMarker)>,
    externally_defined_picture_representation_item:
        HashMap<u64, as_holder!(ExternallyDefinedPictureRepresentationItem)>,
    externally_defined_representation_item:
        HashMap<u64, as_holder!(ExternallyDefinedRepresentationItem)>,
    externally_defined_string: HashMap<u64, as_holder!(ExternallyDefinedString)>,
    externally_defined_symbol: HashMap<u64, as_holder!(ExternallyDefinedSymbol)>,
    externally_defined_terminator_symbol:
        HashMap<u64, as_holder!(ExternallyDefinedTerminatorSymbol)>,
    externally_defined_text_font: HashMap<u64, as_holder!(ExternallyDefinedTextFont)>,
    externally_defined_tile: HashMap<u64, as_holder!(ExternallyDefinedTile)>,
    externally_defined_tile_style: HashMap<u64, as_holder!(ExternallyDefinedTileStyle)>,
    extruded_area_solid: HashMap<u64, as_holder!(ExtrudedAreaSolid)>,
    extruded_face_solid: HashMap<u64, as_holder!(ExtrudedFaceSolid)>,
    extruded_face_solid_with_draft_angle: HashMap<u64, as_holder!(ExtrudedFaceSolidWithDraftAngle)>,
    extruded_face_solid_with_multiple_draft_angles:
        HashMap<u64, as_holder!(ExtrudedFaceSolidWithMultipleDraftAngles)>,
    extruded_face_solid_with_trim_conditions:
        HashMap<u64, as_holder!(ExtrudedFaceSolidWithTrimConditions)>,
    face: HashMap<u64, as_holder!(Face)>,
    face_based_surface_model: HashMap<u64, as_holder!(FaceBasedSurfaceModel)>,
    face_bound: HashMap<u64, as_holder!(FaceBound)>,
    face_outer_bound: HashMap<u64, as_holder!(FaceOuterBound)>,
    face_surface: HashMap<u64, as_holder!(FaceSurface)>,
    faceted_brep: HashMap<u64, as_holder!(FacetedBrep)>,
    faceted_brep_shape_representation: HashMap<u64, as_holder!(FacetedBrepShapeRepresentation)>,
    fact_type: HashMap<u64, as_holder!(FactType)>,
    fill_area_style: HashMap<u64, as_holder!(FillAreaStyle)>,
    fill_area_style_colour: HashMap<u64, as_holder!(FillAreaStyleColour)>,
    fill_area_style_hatching: HashMap<u64, as_holder!(FillAreaStyleHatching)>,
    fill_area_style_tile_coloured_region: HashMap<u64, as_holder!(FillAreaStyleTileColouredRegion)>,
    fill_area_style_tile_curve_with_style:
        HashMap<u64, as_holder!(FillAreaStyleTileCurveWithStyle)>,
    fill_area_style_tile_symbol_with_style:
        HashMap<u64, as_holder!(FillAreaStyleTileSymbolWithStyle)>,
    fill_area_style_tiles: HashMap<u64, as_holder!(FillAreaStyleTiles)>,
    flat_pattern_ply_representation_relationship:
        HashMap<u64, as_holder!(FlatPatternPlyRepresentationRelationship)>,
    flatness_tolerance: HashMap<u64, as_holder!(FlatnessTolerance)>,
    force_measure_with_unit: HashMap<u64, as_holder!(ForceMeasureWithUnit)>,
    force_unit: HashMap<u64, as_holder!(ForceUnit)>,
    forward_chaining_rule: HashMap<u64, as_holder!(ForwardChainingRule)>,
    forward_chaining_rule_premise: HashMap<u64, as_holder!(ForwardChainingRulePremise)>,
    founded_item: HashMap<u64, as_holder!(FoundedItem)>,
    frequency_measure_with_unit: HashMap<u64, as_holder!(FrequencyMeasureWithUnit)>,
    frequency_unit: HashMap<u64, as_holder!(FrequencyUnit)>,
    func: HashMap<u64, as_holder!(Func)>,
    functional_breakdown_context: HashMap<u64, as_holder!(FunctionalBreakdownContext)>,
    functional_element_usage: HashMap<u64, as_holder!(FunctionalElementUsage)>,
    functionally_defined_transformation:
        HashMap<u64, as_holder!(FunctionallyDefinedTransformation)>,
    general_material_property: HashMap<u64, as_holder!(GeneralMaterialProperty)>,
    general_property: HashMap<u64, as_holder!(GeneralProperty)>,
    general_property_association: HashMap<u64, as_holder!(GeneralPropertyAssociation)>,
    general_property_relationship: HashMap<u64, as_holder!(GeneralPropertyRelationship)>,
    generic_character_glyph_symbol: HashMap<u64, as_holder!(GenericCharacterGlyphSymbol)>,
    generic_expression: HashMap<u64, as_holder!(GenericExpression)>,
    generic_literal: HashMap<u64, as_holder!(GenericLiteral)>,
    generic_variable: HashMap<u64, as_holder!(GenericVariable)>,
    geometric_alignment: HashMap<u64, as_holder!(GeometricAlignment)>,
    geometric_curve_set: HashMap<u64, as_holder!(GeometricCurveSet)>,
    geometric_intersection: HashMap<u64, as_holder!(GeometricIntersection)>,
    geometric_item_specific_usage: HashMap<u64, as_holder!(GeometricItemSpecificUsage)>,
    geometric_model_element_relationship:
        HashMap<u64, as_holder!(GeometricModelElementRelationship)>,
    geometric_representation_context: HashMap<u64, as_holder!(GeometricRepresentationContext)>,
    geometric_representation_item: HashMap<u64, as_holder!(GeometricRepresentationItem)>,
    geometric_set: HashMap<u64, as_holder!(GeometricSet)>,
    geometric_tolerance: HashMap<u64, as_holder!(GeometricTolerance)>,
    geometric_tolerance_relationship: HashMap<u64, as_holder!(GeometricToleranceRelationship)>,
    geometric_tolerance_with_datum_reference:
        HashMap<u64, as_holder!(GeometricToleranceWithDatumReference)>,
    geometric_tolerance_with_defined_unit:
        HashMap<u64, as_holder!(GeometricToleranceWithDefinedUnit)>,
    geometrical_tolerance_callout: HashMap<u64, as_holder!(GeometricalToleranceCallout)>,
    geometrically_bounded_2d_wireframe_representation:
        HashMap<u64, as_holder!(GeometricallyBounded2DWireframeRepresentation)>,
    geometrically_bounded_surface_shape_representation:
        HashMap<u64, as_holder!(GeometricallyBoundedSurfaceShapeRepresentation)>,
    geometrically_bounded_wireframe_shape_representation:
        HashMap<u64, as_holder!(GeometricallyBoundedWireframeShapeRepresentation)>,
    global_assignment: HashMap<u64, as_holder!(GlobalAssignment)>,
    global_uncertainty_assigned_context: HashMap<u64, as_holder!(GlobalUncertaintyAssignedContext)>,
    global_unit_assigned_context: HashMap<u64, as_holder!(GlobalUnitAssignedContext)>,
    ground_fact: HashMap<u64, as_holder!(GroundFact)>,
    group: HashMap<u64, as_holder!(Group)>,
    group_assignment: HashMap<u64, as_holder!(GroupAssignment)>,
    group_relationship: HashMap<u64, as_holder!(GroupRelationship)>,
    half_space_solid: HashMap<u64, as_holder!(HalfSpaceSolid)>,
    hardness_representation: HashMap<u64, as_holder!(HardnessRepresentation)>,
    hidden_element_over_riding_styled_item:
        HashMap<u64, as_holder!(HiddenElementOverRidingStyledItem)>,
    hyperbola: HashMap<u64, as_holder!(Hyperbola)>,
    id_attribute: HashMap<u64, as_holder!(IdAttribute)>,
    identification_assignment: HashMap<u64, as_holder!(IdentificationAssignment)>,
    identification_role: HashMap<u64, as_holder!(IdentificationRole)>,
    illuminance_measure_with_unit: HashMap<u64, as_holder!(IlluminanceMeasureWithUnit)>,
    illuminance_unit: HashMap<u64, as_holder!(IlluminanceUnit)>,
    included_text_block: HashMap<u64, as_holder!(IncludedTextBlock)>,
    inclusion_product_concept_feature: HashMap<u64, as_holder!(InclusionProductConceptFeature)>,
    indirectly_selected_elements: HashMap<u64, as_holder!(IndirectlySelectedElements)>,
    indirectly_selected_shape_elements: HashMap<u64, as_holder!(IndirectlySelectedShapeElements)>,
    inductance_measure_with_unit: HashMap<u64, as_holder!(InductanceMeasureWithUnit)>,
    inductance_unit: HashMap<u64, as_holder!(InductanceUnit)>,
    information_right: HashMap<u64, as_holder!(InformationRight)>,
    information_usage_right: HashMap<u64, as_holder!(InformationUsageRight)>,
    instance_usage_context_assignment: HashMap<u64, as_holder!(InstanceUsageContextAssignment)>,
    instanced_feature: HashMap<u64, as_holder!(InstancedFeature)>,
    int_literal: HashMap<u64, as_holder!(IntLiteral)>,
    integer_representation_item: HashMap<u64, as_holder!(IntegerRepresentationItem)>,
    intersection_curve: HashMap<u64, as_holder!(IntersectionCurve)>,
    interval_expression: HashMap<u64, as_holder!(IntervalExpression)>,
    invisibility: HashMap<u64, as_holder!(Invisibility)>,
    iso4217_currency: HashMap<u64, as_holder!(Iso4217Currency)>,
    item_defined_transformation: HashMap<u64, as_holder!(ItemDefinedTransformation)>,
    item_identified_representation_usage:
        HashMap<u64, as_holder!(ItemIdentifiedRepresentationUsage)>,
    known_source: HashMap<u64, as_holder!(KnownSource)>,
    laid_defined_transformation: HashMap<u64, as_holder!(LaidDefinedTransformation)>,
    laminate_table: HashMap<u64, as_holder!(LaminateTable)>,
    language: HashMap<u64, as_holder!(Language)>,
    leader_curve: HashMap<u64, as_holder!(LeaderCurve)>,
    leader_directed_callout: HashMap<u64, as_holder!(LeaderDirectedCallout)>,
    leader_directed_dimension: HashMap<u64, as_holder!(LeaderDirectedDimension)>,
    leader_terminator: HashMap<u64, as_holder!(LeaderTerminator)>,
    length_measure_with_unit: HashMap<u64, as_holder!(LengthMeasureWithUnit)>,
    length_unit: HashMap<u64, as_holder!(LengthUnit)>,
    light_source: HashMap<u64, as_holder!(LightSource)>,
    light_source_ambient: HashMap<u64, as_holder!(LightSourceAmbient)>,
    light_source_directional: HashMap<u64, as_holder!(LightSourceDirectional)>,
    light_source_positional: HashMap<u64, as_holder!(LightSourcePositional)>,
    light_source_spot: HashMap<u64, as_holder!(LightSourceSpot)>,
    limits_and_fits: HashMap<u64, as_holder!(LimitsAndFits)>,
    line: HashMap<u64, as_holder!(Line)>,
    line_profile_tolerance: HashMap<u64, as_holder!(LineProfileTolerance)>,
    linear_dimension: HashMap<u64, as_holder!(LinearDimension)>,
    literal_conjunction: HashMap<u64, as_holder!(LiteralConjunction)>,
    literal_disjunction: HashMap<u64, as_holder!(LiteralDisjunction)>,
    literal_number: HashMap<u64, as_holder!(LiteralNumber)>,
    local_time: HashMap<u64, as_holder!(LocalTime)>,
    logical_literal: HashMap<u64, as_holder!(LogicalLiteral)>,
    logical_representation_item: HashMap<u64, as_holder!(LogicalRepresentationItem)>,
    r#loop: HashMap<u64, as_holder!(Loop)>,
    loss_tangent_measure_with_unit: HashMap<u64, as_holder!(LossTangentMeasureWithUnit)>,
    lot_effectivity: HashMap<u64, as_holder!(LotEffectivity)>,
    luminous_flux_measure_with_unit: HashMap<u64, as_holder!(LuminousFluxMeasureWithUnit)>,
    luminous_flux_unit: HashMap<u64, as_holder!(LuminousFluxUnit)>,
    luminous_intensity_measure_with_unit:
        HashMap<u64, as_holder!(LuminousIntensityMeasureWithUnit)>,
    luminous_intensity_unit: HashMap<u64, as_holder!(LuminousIntensityUnit)>,
    magnetic_flux_density_measure_with_unit:
        HashMap<u64, as_holder!(MagneticFluxDensityMeasureWithUnit)>,
    magnetic_flux_density_unit: HashMap<u64, as_holder!(MagneticFluxDensityUnit)>,
    magnetic_flux_measure_with_unit: HashMap<u64, as_holder!(MagneticFluxMeasureWithUnit)>,
    magnetic_flux_unit: HashMap<u64, as_holder!(MagneticFluxUnit)>,
    make_from_usage_option: HashMap<u64, as_holder!(MakeFromUsageOption)>,
    manifold_solid_brep: HashMap<u64, as_holder!(ManifoldSolidBrep)>,
    manifold_subsurface_shape_representation:
        HashMap<u64, as_holder!(ManifoldSubsurfaceShapeRepresentation)>,
    manifold_surface_shape_representation:
        HashMap<u64, as_holder!(ManifoldSurfaceShapeRepresentation)>,
    mapped_item: HashMap<u64, as_holder!(MappedItem)>,
    mass_measure_with_unit: HashMap<u64, as_holder!(MassMeasureWithUnit)>,
    mass_unit: HashMap<u64, as_holder!(MassUnit)>,
    material_designation: HashMap<u64, as_holder!(MaterialDesignation)>,
    material_designation_characterization:
        HashMap<u64, as_holder!(MaterialDesignationCharacterization)>,
    material_property: HashMap<u64, as_holder!(MaterialProperty)>,
    material_property_representation: HashMap<u64, as_holder!(MaterialPropertyRepresentation)>,
    measure_qualification: HashMap<u64, as_holder!(MeasureQualification)>,
    measure_representation_item: HashMap<u64, as_holder!(MeasureRepresentationItem)>,
    measure_with_unit: HashMap<u64, as_holder!(MeasureWithUnit)>,
    mechanical_context: HashMap<u64, as_holder!(MechanicalContext)>,
    mechanical_design_and_draughting_relationship:
        HashMap<u64, as_holder!(MechanicalDesignAndDraughtingRelationship)>,
    mechanical_design_geometric_presentation_area:
        HashMap<u64, as_holder!(MechanicalDesignGeometricPresentationArea)>,
    mechanical_design_geometric_presentation_representation:
        HashMap<u64, as_holder!(MechanicalDesignGeometricPresentationRepresentation)>,
    mechanical_design_presentation_representation_with_draughting:
        HashMap<u64, as_holder!(MechanicalDesignPresentationRepresentationWithDraughting)>,
    mechanical_design_shaded_presentation_area:
        HashMap<u64, as_holder!(MechanicalDesignShadedPresentationArea)>,
    mechanical_design_shaded_presentation_representation:
        HashMap<u64, as_holder!(MechanicalDesignShadedPresentationRepresentation)>,
    min_and_major_ply_orientation_basis: HashMap<u64, as_holder!(MinAndMajorPlyOrientationBasis)>,
    modified_geometric_tolerance: HashMap<u64, as_holder!(ModifiedGeometricTolerance)>,
    modified_solid: HashMap<u64, as_holder!(ModifiedSolid)>,
    modified_solid_with_placed_configuration:
        HashMap<u64, as_holder!(ModifiedSolidWithPlacedConfiguration)>,
    moments_of_inertia_representation: HashMap<u64, as_holder!(MomentsOfInertiaRepresentation)>,
    multi_language_attribute_assignment: HashMap<u64, as_holder!(MultiLanguageAttributeAssignment)>,
    multiple_arity_boolean_expression: HashMap<u64, as_holder!(MultipleArityBooleanExpression)>,
    multiple_arity_generic_expression: HashMap<u64, as_holder!(MultipleArityGenericExpression)>,
    multiple_arity_numeric_expression: HashMap<u64, as_holder!(MultipleArityNumericExpression)>,
    name_assignment: HashMap<u64, as_holder!(NameAssignment)>,
    name_attribute: HashMap<u64, as_holder!(NameAttribute)>,
    named_unit: HashMap<u64, as_holder!(NamedUnit)>,
    next_assembly_usage_occurrence: HashMap<u64, as_holder!(NextAssemblyUsageOccurrence)>,
    non_manifold_surface_shape_representation:
        HashMap<u64, as_holder!(NonManifoldSurfaceShapeRepresentation)>,
    null_representation_item: HashMap<u64, as_holder!(NullRepresentationItem)>,
    numeric_expression: HashMap<u64, as_holder!(NumericExpression)>,
    object_role: HashMap<u64, as_holder!(ObjectRole)>,
    offset_curve_2d: HashMap<u64, as_holder!(OffsetCurve2D)>,
    offset_curve_3d: HashMap<u64, as_holder!(OffsetCurve3D)>,
    offset_surface: HashMap<u64, as_holder!(OffsetSurface)>,
    one_direction_repeat_factor: HashMap<u64, as_holder!(OneDirectionRepeatFactor)>,
    open_shell: HashMap<u64, as_holder!(OpenShell)>,
    ordinal_date: HashMap<u64, as_holder!(OrdinalDate)>,
    ordinate_dimension: HashMap<u64, as_holder!(OrdinateDimension)>,
    organization: HashMap<u64, as_holder!(Organization)>,
    organization_assignment: HashMap<u64, as_holder!(OrganizationAssignment)>,
    organization_relationship: HashMap<u64, as_holder!(OrganizationRelationship)>,
    organization_role: HashMap<u64, as_holder!(OrganizationRole)>,
    organizational_address: HashMap<u64, as_holder!(OrganizationalAddress)>,
    organizational_project: HashMap<u64, as_holder!(OrganizationalProject)>,
    organizational_project_assignment: HashMap<u64, as_holder!(OrganizationalProjectAssignment)>,
    organizational_project_relationship:
        HashMap<u64, as_holder!(OrganizationalProjectRelationship)>,
    organizational_project_role: HashMap<u64, as_holder!(OrganizationalProjectRole)>,
    oriented_closed_shell: HashMap<u64, as_holder!(OrientedClosedShell)>,
    oriented_edge: HashMap<u64, as_holder!(OrientedEdge)>,
    oriented_face: HashMap<u64, as_holder!(OrientedFace)>,
    oriented_open_shell: HashMap<u64, as_holder!(OrientedOpenShell)>,
    oriented_path: HashMap<u64, as_holder!(OrientedPath)>,
    oriented_surface: HashMap<u64, as_holder!(OrientedSurface)>,
    outer_boundary_curve: HashMap<u64, as_holder!(OuterBoundaryCurve)>,
    over_riding_styled_item: HashMap<u64, as_holder!(OverRidingStyledItem)>,
    package_product_concept_feature: HashMap<u64, as_holder!(PackageProductConceptFeature)>,
    parabola: HashMap<u64, as_holder!(Parabola)>,
    parallel_offset: HashMap<u64, as_holder!(ParallelOffset)>,
    parallelism_tolerance: HashMap<u64, as_holder!(ParallelismTolerance)>,
    parametric_representation_context: HashMap<u64, as_holder!(ParametricRepresentationContext)>,
    part_laminate_table: HashMap<u64, as_holder!(PartLaminateTable)>,
    partial_document_with_structured_text_representation_assignment:
        HashMap<u64, as_holder!(PartialDocumentWithStructuredTextRepresentationAssignment)>,
    path: HashMap<u64, as_holder!(Path)>,
    pcurve: HashMap<u64, as_holder!(Pcurve)>,
    percentage_laminate_definition: HashMap<u64, as_holder!(PercentageLaminateDefinition)>,
    percentage_laminate_table: HashMap<u64, as_holder!(PercentageLaminateTable)>,
    percentage_ply_definition: HashMap<u64, as_holder!(PercentagePlyDefinition)>,
    perpendicular_to: HashMap<u64, as_holder!(PerpendicularTo)>,
    perpendicularity_tolerance: HashMap<u64, as_holder!(PerpendicularityTolerance)>,
    person: HashMap<u64, as_holder!(Person)>,
    person_and_organization: HashMap<u64, as_holder!(PersonAndOrganization)>,
    person_and_organization_address: HashMap<u64, as_holder!(PersonAndOrganizationAddress)>,
    person_and_organization_assignment: HashMap<u64, as_holder!(PersonAndOrganizationAssignment)>,
    person_and_organization_role: HashMap<u64, as_holder!(PersonAndOrganizationRole)>,
    personal_address: HashMap<u64, as_holder!(PersonalAddress)>,
    physical_breakdown_context: HashMap<u64, as_holder!(PhysicalBreakdownContext)>,
    physical_element_usage: HashMap<u64, as_holder!(PhysicalElementUsage)>,
    picture_representation: HashMap<u64, as_holder!(PictureRepresentation)>,
    picture_representation_item: HashMap<u64, as_holder!(PictureRepresentationItem)>,
    placed_datum_target_feature: HashMap<u64, as_holder!(PlacedDatumTargetFeature)>,
    placed_feature: HashMap<u64, as_holder!(PlacedFeature)>,
    placement: HashMap<u64, as_holder!(Placement)>,
    planar_box: HashMap<u64, as_holder!(PlanarBox)>,
    planar_extent: HashMap<u64, as_holder!(PlanarExtent)>,
    plane: HashMap<u64, as_holder!(Plane)>,
    plane_angle_measure_with_unit: HashMap<u64, as_holder!(PlaneAngleMeasureWithUnit)>,
    plane_angle_unit: HashMap<u64, as_holder!(PlaneAngleUnit)>,
    plus_minus_tolerance: HashMap<u64, as_holder!(PlusMinusTolerance)>,
    ply_laminate_definition: HashMap<u64, as_holder!(PlyLaminateDefinition)>,
    ply_laminate_sequence_definition: HashMap<u64, as_holder!(PlyLaminateSequenceDefinition)>,
    ply_laminate_table: HashMap<u64, as_holder!(PlyLaminateTable)>,
    point: HashMap<u64, as_holder!(Point)>,
    point_and_vector: HashMap<u64, as_holder!(PointAndVector)>,
    point_on_curve: HashMap<u64, as_holder!(PointOnCurve)>,
    point_on_surface: HashMap<u64, as_holder!(PointOnSurface)>,
    point_path: HashMap<u64, as_holder!(PointPath)>,
    point_replica: HashMap<u64, as_holder!(PointReplica)>,
    point_style: HashMap<u64, as_holder!(PointStyle)>,
    polar_complex_number_literal: HashMap<u64, as_holder!(PolarComplexNumberLiteral)>,
    poly_loop: HashMap<u64, as_holder!(PolyLoop)>,
    polyline: HashMap<u64, as_holder!(Polyline)>,
    position_tolerance: HashMap<u64, as_holder!(PositionTolerance)>,
    positioned_sketch: HashMap<u64, as_holder!(PositionedSketch)>,
    power_measure_with_unit: HashMap<u64, as_holder!(PowerMeasureWithUnit)>,
    power_unit: HashMap<u64, as_holder!(PowerUnit)>,
    pre_defined_colour: HashMap<u64, as_holder!(PreDefinedColour)>,
    pre_defined_curve_font: HashMap<u64, as_holder!(PreDefinedCurveFont)>,
    pre_defined_dimension_symbol: HashMap<u64, as_holder!(PreDefinedDimensionSymbol)>,
    pre_defined_geometrical_tolerance_symbol:
        HashMap<u64, as_holder!(PreDefinedGeometricalToleranceSymbol)>,
    pre_defined_item: HashMap<u64, as_holder!(PreDefinedItem)>,
    pre_defined_marker: HashMap<u64, as_holder!(PreDefinedMarker)>,
    pre_defined_point_marker_symbol: HashMap<u64, as_holder!(PreDefinedPointMarkerSymbol)>,
    pre_defined_surface_condition_symbol:
        HashMap<u64, as_holder!(PreDefinedSurfaceConditionSymbol)>,
    pre_defined_surface_side_style: HashMap<u64, as_holder!(PreDefinedSurfaceSideStyle)>,
    pre_defined_symbol: HashMap<u64, as_holder!(PreDefinedSymbol)>,
    pre_defined_terminator_symbol: HashMap<u64, as_holder!(PreDefinedTerminatorSymbol)>,
    pre_defined_text_font: HashMap<u64, as_holder!(PreDefinedTextFont)>,
    pre_defined_tile: HashMap<u64, as_holder!(PreDefinedTile)>,
    precision_qualifier: HashMap<u64, as_holder!(PrecisionQualifier)>,
    predefined_picture_representation_item:
        HashMap<u64, as_holder!(PredefinedPictureRepresentationItem)>,
    presentation_area: HashMap<u64, as_holder!(PresentationArea)>,
    presentation_layer_assignment: HashMap<u64, as_holder!(PresentationLayerAssignment)>,
    presentation_representation: HashMap<u64, as_holder!(PresentationRepresentation)>,
    presentation_set: HashMap<u64, as_holder!(PresentationSet)>,
    presentation_size: HashMap<u64, as_holder!(PresentationSize)>,
    presentation_style_assignment: HashMap<u64, as_holder!(PresentationStyleAssignment)>,
    presentation_style_by_context: HashMap<u64, as_holder!(PresentationStyleByContext)>,
    presentation_view: HashMap<u64, as_holder!(PresentationView)>,
    presented_item: HashMap<u64, as_holder!(PresentedItem)>,
    presented_item_representation: HashMap<u64, as_holder!(PresentedItemRepresentation)>,
    pressure_measure_with_unit: HashMap<u64, as_holder!(PressureMeasureWithUnit)>,
    pressure_unit: HashMap<u64, as_holder!(PressureUnit)>,
    procedural_representation: HashMap<u64, as_holder!(ProceduralRepresentation)>,
    procedural_representation_sequence: HashMap<u64, as_holder!(ProceduralRepresentationSequence)>,
    procedural_shape_representation: HashMap<u64, as_holder!(ProceduralShapeRepresentation)>,
    procedural_shape_representation_sequence:
        HashMap<u64, as_holder!(ProceduralShapeRepresentationSequence)>,
    product: HashMap<u64, as_holder!(Product)>,
    product_category: HashMap<u64, as_holder!(ProductCategory)>,
    product_class: HashMap<u64, as_holder!(ProductClass)>,
    product_concept: HashMap<u64, as_holder!(ProductConcept)>,
    product_concept_context: HashMap<u64, as_holder!(ProductConceptContext)>,
    product_concept_feature: HashMap<u64, as_holder!(ProductConceptFeature)>,
    product_concept_feature_association: HashMap<u64, as_holder!(ProductConceptFeatureAssociation)>,
    product_concept_feature_category: HashMap<u64, as_holder!(ProductConceptFeatureCategory)>,
    product_concept_feature_category_usage:
        HashMap<u64, as_holder!(ProductConceptFeatureCategoryUsage)>,
    product_concept_relationship: HashMap<u64, as_holder!(ProductConceptRelationship)>,
    product_context: HashMap<u64, as_holder!(ProductContext)>,
    product_definition: HashMap<u64, as_holder!(ProductDefinition)>,
    product_definition_context: HashMap<u64, as_holder!(ProductDefinitionContext)>,
    product_definition_context_association:
        HashMap<u64, as_holder!(ProductDefinitionContextAssociation)>,
    product_definition_context_role: HashMap<u64, as_holder!(ProductDefinitionContextRole)>,
    product_definition_effectivity: HashMap<u64, as_holder!(ProductDefinitionEffectivity)>,
    product_definition_element_relationship:
        HashMap<u64, as_holder!(ProductDefinitionElementRelationship)>,
    product_definition_formation: HashMap<u64, as_holder!(ProductDefinitionFormation)>,
    product_definition_formation_relationship:
        HashMap<u64, as_holder!(ProductDefinitionFormationRelationship)>,
    product_definition_formation_with_specified_source:
        HashMap<u64, as_holder!(ProductDefinitionFormationWithSpecifiedSource)>,
    product_definition_group_assignment: HashMap<u64, as_holder!(ProductDefinitionGroupAssignment)>,
    product_definition_occurrence_relationship:
        HashMap<u64, as_holder!(ProductDefinitionOccurrenceRelationship)>,
    product_definition_relationship: HashMap<u64, as_holder!(ProductDefinitionRelationship)>,
    product_definition_shape: HashMap<u64, as_holder!(ProductDefinitionShape)>,
    product_definition_substitute: HashMap<u64, as_holder!(ProductDefinitionSubstitute)>,
    product_definition_usage: HashMap<u64, as_holder!(ProductDefinitionUsage)>,
    product_definition_with_associated_documents:
        HashMap<u64, as_holder!(ProductDefinitionWithAssociatedDocuments)>,
    product_identification: HashMap<u64, as_holder!(ProductIdentification)>,
    product_material_composition_relationship:
        HashMap<u64, as_holder!(ProductMaterialCompositionRelationship)>,
    product_related_product_category: HashMap<u64, as_holder!(ProductRelatedProductCategory)>,
    product_specification: HashMap<u64, as_holder!(ProductSpecification)>,
    projected_zone_definition: HashMap<u64, as_holder!(ProjectedZoneDefinition)>,
    projection_curve: HashMap<u64, as_holder!(ProjectionCurve)>,
    projection_directed_callout: HashMap<u64, as_holder!(ProjectionDirectedCallout)>,
    promissory_usage_occurrence: HashMap<u64, as_holder!(PromissoryUsageOccurrence)>,
    property_definition: HashMap<u64, as_holder!(PropertyDefinition)>,
    property_definition_relationship: HashMap<u64, as_holder!(PropertyDefinitionRelationship)>,
    property_definition_representation: HashMap<u64, as_holder!(PropertyDefinitionRepresentation)>,
    qualified_representation_item: HashMap<u64, as_holder!(QualifiedRepresentationItem)>,
    qualitative_uncertainty: HashMap<u64, as_holder!(QualitativeUncertainty)>,
    quantified_assembly_component_usage: HashMap<u64, as_holder!(QuantifiedAssemblyComponentUsage)>,
    quasi_uniform_curve: HashMap<u64, as_holder!(QuasiUniformCurve)>,
    quasi_uniform_surface: HashMap<u64, as_holder!(QuasiUniformSurface)>,
    radioactivity_measure_with_unit: HashMap<u64, as_holder!(RadioactivityMeasureWithUnit)>,
    radioactivity_unit: HashMap<u64, as_holder!(RadioactivityUnit)>,
    radius_dimension: HashMap<u64, as_holder!(RadiusDimension)>,
    range_characteristic: HashMap<u64, as_holder!(RangeCharacteristic)>,
    ratio_measure_with_unit: HashMap<u64, as_holder!(RatioMeasureWithUnit)>,
    ratio_unit: HashMap<u64, as_holder!(RatioUnit)>,
    rational_b_spline_curve: HashMap<u64, as_holder!(RationalBSplineCurve)>,
    rational_b_spline_surface: HashMap<u64, as_holder!(RationalBSplineSurface)>,
    rational_representation_item: HashMap<u64, as_holder!(RationalRepresentationItem)>,
    real_literal: HashMap<u64, as_holder!(RealLiteral)>,
    real_representation_item: HashMap<u64, as_holder!(RealRepresentationItem)>,
    rectangular_composite_surface: HashMap<u64, as_holder!(RectangularCompositeSurface)>,
    rectangular_trimmed_surface: HashMap<u64, as_holder!(RectangularTrimmedSurface)>,
    referenced_modified_datum: HashMap<u64, as_holder!(ReferencedModifiedDatum)>,
    relative_event_occurrence: HashMap<u64, as_holder!(RelativeEventOccurrence)>,
    rep_item_group: HashMap<u64, as_holder!(RepItemGroup)>,
    reparametrised_composite_curve_segment:
        HashMap<u64, as_holder!(ReparametrisedCompositeCurveSegment)>,
    representation: HashMap<u64, as_holder!(Representation)>,
    representation_context: HashMap<u64, as_holder!(RepresentationContext)>,
    representation_item: HashMap<u64, as_holder!(RepresentationItem)>,
    representation_item_relationship: HashMap<u64, as_holder!(RepresentationItemRelationship)>,
    representation_map: HashMap<u64, as_holder!(RepresentationMap)>,
    representation_relationship: HashMap<u64, as_holder!(RepresentationRelationship)>,
    representation_relationship_with_transformation:
        HashMap<u64, as_holder!(RepresentationRelationshipWithTransformation)>,
    requirement_assigned_object: HashMap<u64, as_holder!(RequirementAssignedObject)>,
    requirement_assignment: HashMap<u64, as_holder!(RequirementAssignment)>,
    requirement_source: HashMap<u64, as_holder!(RequirementSource)>,
    requirement_view_definition_relationship:
        HashMap<u64, as_holder!(RequirementViewDefinitionRelationship)>,
    resistance_measure_with_unit: HashMap<u64, as_holder!(ResistanceMeasureWithUnit)>,
    resistance_unit: HashMap<u64, as_holder!(ResistanceUnit)>,
    revolved_area_solid: HashMap<u64, as_holder!(RevolvedAreaSolid)>,
    revolved_face_solid: HashMap<u64, as_holder!(RevolvedFaceSolid)>,
    revolved_face_solid_with_trim_conditions:
        HashMap<u64, as_holder!(RevolvedFaceSolidWithTrimConditions)>,
    right_angular_wedge: HashMap<u64, as_holder!(RightAngularWedge)>,
    right_circular_cone: HashMap<u64, as_holder!(RightCircularCone)>,
    right_circular_cylinder: HashMap<u64, as_holder!(RightCircularCylinder)>,
    right_to_usage_association: HashMap<u64, as_holder!(RightToUsageAssociation)>,
    role_association: HashMap<u64, as_holder!(RoleAssociation)>,
    roundness_tolerance: HashMap<u64, as_holder!(RoundnessTolerance)>,
    row_representation_item: HashMap<u64, as_holder!(RowRepresentationItem)>,
    row_value: HashMap<u64, as_holder!(RowValue)>,
    row_variable: HashMap<u64, as_holder!(RowVariable)>,
    rule_action: HashMap<u64, as_holder!(RuleAction)>,
    rule_condition: HashMap<u64, as_holder!(RuleCondition)>,
    rule_definition: HashMap<u64, as_holder!(RuleDefinition)>,
    rule_set: HashMap<u64, as_holder!(RuleSet)>,
    rule_set_group: HashMap<u64, as_holder!(RuleSetGroup)>,
    rule_software_definition: HashMap<u64, as_holder!(RuleSoftwareDefinition)>,
    rule_superseded_assignment: HashMap<u64, as_holder!(RuleSupersededAssignment)>,
    rule_supersedence: HashMap<u64, as_holder!(RuleSupersedence)>,
    ruled_surface_swept_area_solid: HashMap<u64, as_holder!(RuledSurfaceSweptAreaSolid)>,
    runout_zone_definition: HashMap<u64, as_holder!(RunoutZoneDefinition)>,
    runout_zone_orientation: HashMap<u64, as_holder!(RunoutZoneOrientation)>,
    runout_zone_orientation_reference_direction:
        HashMap<u64, as_holder!(RunoutZoneOrientationReferenceDirection)>,
    satisfied_requirement: HashMap<u64, as_holder!(SatisfiedRequirement)>,
    satisfies_requirement: HashMap<u64, as_holder!(SatisfiesRequirement)>,
    satisfying_item: HashMap<u64, as_holder!(SatisfyingItem)>,
    scalar_variable: HashMap<u64, as_holder!(ScalarVariable)>,
    scattering_parameter: HashMap<u64, as_holder!(ScatteringParameter)>,
    sculptured_solid: HashMap<u64, as_holder!(SculpturedSolid)>,
    seam_curve: HashMap<u64, as_holder!(SeamCurve)>,
    security_classification: HashMap<u64, as_holder!(SecurityClassification)>,
    security_classification_assignment: HashMap<u64, as_holder!(SecurityClassificationAssignment)>,
    security_classification_level: HashMap<u64, as_holder!(SecurityClassificationLevel)>,
    serial_numbered_effectivity: HashMap<u64, as_holder!(SerialNumberedEffectivity)>,
    shape_aspect: HashMap<u64, as_holder!(ShapeAspect)>,
    shape_aspect_associativity: HashMap<u64, as_holder!(ShapeAspectAssociativity)>,
    shape_aspect_deriving_relationship: HashMap<u64, as_holder!(ShapeAspectDerivingRelationship)>,
    shape_aspect_relationship: HashMap<u64, as_holder!(ShapeAspectRelationship)>,
    shape_definition_representation: HashMap<u64, as_holder!(ShapeDefinitionRepresentation)>,
    shape_dimension_representation: HashMap<u64, as_holder!(ShapeDimensionRepresentation)>,
    shape_feature_definition: HashMap<u64, as_holder!(ShapeFeatureDefinition)>,
    shape_representation: HashMap<u64, as_holder!(ShapeRepresentation)>,
    shape_representation_relationship: HashMap<u64, as_holder!(ShapeRepresentationRelationship)>,
    shape_representation_with_parameters:
        HashMap<u64, as_holder!(ShapeRepresentationWithParameters)>,
    shell_based_surface_model: HashMap<u64, as_holder!(ShellBasedSurfaceModel)>,
    shell_based_wireframe_model: HashMap<u64, as_holder!(ShellBasedWireframeModel)>,
    shell_based_wireframe_shape_representation:
        HashMap<u64, as_holder!(ShellBasedWireframeShapeRepresentation)>,
    shelled_solid: HashMap<u64, as_holder!(ShelledSolid)>,
    si_absorbed_dose_unit: HashMap<u64, as_holder!(SiAbsorbedDoseUnit)>,
    si_capacitance_unit: HashMap<u64, as_holder!(SiCapacitanceUnit)>,
    si_conductance_unit: HashMap<u64, as_holder!(SiConductanceUnit)>,
    si_dose_equivalent_unit: HashMap<u64, as_holder!(SiDoseEquivalentUnit)>,
    si_electric_charge_unit: HashMap<u64, as_holder!(SiElectricChargeUnit)>,
    si_electric_potential_unit: HashMap<u64, as_holder!(SiElectricPotentialUnit)>,
    si_energy_unit: HashMap<u64, as_holder!(SiEnergyUnit)>,
    si_force_unit: HashMap<u64, as_holder!(SiForceUnit)>,
    si_frequency_unit: HashMap<u64, as_holder!(SiFrequencyUnit)>,
    si_illuminance_unit: HashMap<u64, as_holder!(SiIlluminanceUnit)>,
    si_inductance_unit: HashMap<u64, as_holder!(SiInductanceUnit)>,
    si_magnetic_flux_density_unit: HashMap<u64, as_holder!(SiMagneticFluxDensityUnit)>,
    si_magnetic_flux_unit: HashMap<u64, as_holder!(SiMagneticFluxUnit)>,
    si_power_unit: HashMap<u64, as_holder!(SiPowerUnit)>,
    si_pressure_unit: HashMap<u64, as_holder!(SiPressureUnit)>,
    si_radioactivity_unit: HashMap<u64, as_holder!(SiRadioactivityUnit)>,
    si_resistance_unit: HashMap<u64, as_holder!(SiResistanceUnit)>,
    si_unit: HashMap<u64, as_holder!(SiUnit)>,
    simple_boolean_expression: HashMap<u64, as_holder!(SimpleBooleanExpression)>,
    simple_clause: HashMap<u64, as_holder!(SimpleClause)>,
    simple_generic_expression: HashMap<u64, as_holder!(SimpleGenericExpression)>,
    simple_numeric_expression: HashMap<u64, as_holder!(SimpleNumericExpression)>,
    slash_expression: HashMap<u64, as_holder!(SlashExpression)>,
    smeared_material_definition: HashMap<u64, as_holder!(SmearedMaterialDefinition)>,
    solid_angle_measure_with_unit: HashMap<u64, as_holder!(SolidAngleMeasureWithUnit)>,
    solid_angle_unit: HashMap<u64, as_holder!(SolidAngleUnit)>,
    solid_curve_font: HashMap<u64, as_holder!(SolidCurveFont)>,
    solid_model: HashMap<u64, as_holder!(SolidModel)>,
    solid_replica: HashMap<u64, as_holder!(SolidReplica)>,
    solid_with_angle_based_chamfer: HashMap<u64, as_holder!(SolidWithAngleBasedChamfer)>,
    solid_with_chamfered_edges: HashMap<u64, as_holder!(SolidWithChamferedEdges)>,
    solid_with_circular_pattern: HashMap<u64, as_holder!(SolidWithCircularPattern)>,
    solid_with_circular_pocket: HashMap<u64, as_holder!(SolidWithCircularPocket)>,
    solid_with_circular_protrusion: HashMap<u64, as_holder!(SolidWithCircularProtrusion)>,
    solid_with_conical_bottom_round_hole: HashMap<u64, as_holder!(SolidWithConicalBottomRoundHole)>,
    solid_with_constant_radius_edge_blend:
        HashMap<u64, as_holder!(SolidWithConstantRadiusEdgeBlend)>,
    solid_with_curved_slot: HashMap<u64, as_holder!(SolidWithCurvedSlot)>,
    solid_with_depression: HashMap<u64, as_holder!(SolidWithDepression)>,
    solid_with_double_offset_chamfer: HashMap<u64, as_holder!(SolidWithDoubleOffsetChamfer)>,
    solid_with_flat_bottom_round_hole: HashMap<u64, as_holder!(SolidWithFlatBottomRoundHole)>,
    solid_with_general_pocket: HashMap<u64, as_holder!(SolidWithGeneralPocket)>,
    solid_with_general_protrusion: HashMap<u64, as_holder!(SolidWithGeneralProtrusion)>,
    solid_with_groove: HashMap<u64, as_holder!(SolidWithGroove)>,
    solid_with_hole: HashMap<u64, as_holder!(SolidWithHole)>,
    solid_with_incomplete_circular_pattern:
        HashMap<u64, as_holder!(SolidWithIncompleteCircularPattern)>,
    solid_with_incomplete_rectangular_pattern:
        HashMap<u64, as_holder!(SolidWithIncompleteRectangularPattern)>,
    solid_with_pocket: HashMap<u64, as_holder!(SolidWithPocket)>,
    solid_with_protrusion: HashMap<u64, as_holder!(SolidWithProtrusion)>,
    solid_with_rectangular_pattern: HashMap<u64, as_holder!(SolidWithRectangularPattern)>,
    solid_with_rectangular_pocket: HashMap<u64, as_holder!(SolidWithRectangularPocket)>,
    solid_with_rectangular_protrusion: HashMap<u64, as_holder!(SolidWithRectangularProtrusion)>,
    solid_with_shape_element_pattern: HashMap<u64, as_holder!(SolidWithShapeElementPattern)>,
    solid_with_single_offset_chamfer: HashMap<u64, as_holder!(SolidWithSingleOffsetChamfer)>,
    solid_with_slot: HashMap<u64, as_holder!(SolidWithSlot)>,
    solid_with_spherical_bottom_round_hole:
        HashMap<u64, as_holder!(SolidWithSphericalBottomRoundHole)>,
    solid_with_stepped_round_hole: HashMap<u64, as_holder!(SolidWithSteppedRoundHole)>,
    solid_with_stepped_round_hole_and_conical_transitions:
        HashMap<u64, as_holder!(SolidWithSteppedRoundHoleAndConicalTransitions)>,
    solid_with_straight_slot: HashMap<u64, as_holder!(SolidWithStraightSlot)>,
    solid_with_tee_section_slot: HashMap<u64, as_holder!(SolidWithTeeSectionSlot)>,
    solid_with_through_depression: HashMap<u64, as_holder!(SolidWithThroughDepression)>,
    solid_with_trapezoidal_section_slot: HashMap<u64, as_holder!(SolidWithTrapezoidalSectionSlot)>,
    solid_with_variable_radius_edge_blend:
        HashMap<u64, as_holder!(SolidWithVariableRadiusEdgeBlend)>,
    source_for_requirement: HashMap<u64, as_holder!(SourceForRequirement)>,
    sourced_requirement: HashMap<u64, as_holder!(SourcedRequirement)>,
    specification_definition: HashMap<u64, as_holder!(SpecificationDefinition)>,
    specified_higher_usage_occurrence: HashMap<u64, as_holder!(SpecifiedHigherUsageOccurrence)>,
    sphere: HashMap<u64, as_holder!(Sphere)>,
    spherical_surface: HashMap<u64, as_holder!(SphericalSurface)>,
    standard_uncertainty: HashMap<u64, as_holder!(StandardUncertainty)>,
    start_request: HashMap<u64, as_holder!(StartRequest)>,
    start_work: HashMap<u64, as_holder!(StartWork)>,
    straightness_tolerance: HashMap<u64, as_holder!(StraightnessTolerance)>,
    structured_dimension_callout: HashMap<u64, as_holder!(StructuredDimensionCallout)>,
    structured_text_composition: HashMap<u64, as_holder!(StructuredTextComposition)>,
    structured_text_representation: HashMap<u64, as_holder!(StructuredTextRepresentation)>,
    styled_item: HashMap<u64, as_holder!(StyledItem)>,
    subedge: HashMap<u64, as_holder!(Subedge)>,
    subface: HashMap<u64, as_holder!(Subface)>,
    supplied_part_relationship: HashMap<u64, as_holder!(SuppliedPartRelationship)>,
    surface: HashMap<u64, as_holder!(Surface)>,
    surface_condition_callout: HashMap<u64, as_holder!(SurfaceConditionCallout)>,
    surface_curve: HashMap<u64, as_holder!(SurfaceCurve)>,
    surface_curve_swept_area_solid: HashMap<u64, as_holder!(SurfaceCurveSweptAreaSolid)>,
    surface_of_linear_extrusion: HashMap<u64, as_holder!(SurfaceOfLinearExtrusion)>,
    surface_of_revolution: HashMap<u64, as_holder!(SurfaceOfRevolution)>,
    surface_patch: HashMap<u64, as_holder!(SurfacePatch)>,
    surface_profile_tolerance: HashMap<u64, as_holder!(SurfaceProfileTolerance)>,
    surface_rendering_properties: HashMap<u64, as_holder!(SurfaceRenderingProperties)>,
    surface_replica: HashMap<u64, as_holder!(SurfaceReplica)>,
    surface_side_style: HashMap<u64, as_holder!(SurfaceSideStyle)>,
    surface_style_boundary: HashMap<u64, as_holder!(SurfaceStyleBoundary)>,
    surface_style_control_grid: HashMap<u64, as_holder!(SurfaceStyleControlGrid)>,
    surface_style_fill_area: HashMap<u64, as_holder!(SurfaceStyleFillArea)>,
    surface_style_parameter_line: HashMap<u64, as_holder!(SurfaceStyleParameterLine)>,
    surface_style_reflectance_ambient: HashMap<u64, as_holder!(SurfaceStyleReflectanceAmbient)>,
    surface_style_reflectance_ambient_diffuse:
        HashMap<u64, as_holder!(SurfaceStyleReflectanceAmbientDiffuse)>,
    surface_style_reflectance_ambient_diffuse_specular:
        HashMap<u64, as_holder!(SurfaceStyleReflectanceAmbientDiffuseSpecular)>,
    surface_style_rendering: HashMap<u64, as_holder!(SurfaceStyleRendering)>,
    surface_style_rendering_with_properties:
        HashMap<u64, as_holder!(SurfaceStyleRenderingWithProperties)>,
    surface_style_segmentation_curve: HashMap<u64, as_holder!(SurfaceStyleSegmentationCurve)>,
    surface_style_silhouette: HashMap<u64, as_holder!(SurfaceStyleSilhouette)>,
    surface_style_transparent: HashMap<u64, as_holder!(SurfaceStyleTransparent)>,
    surface_style_usage: HashMap<u64, as_holder!(SurfaceStyleUsage)>,
    surface_texture_representation: HashMap<u64, as_holder!(SurfaceTextureRepresentation)>,
    surfaced_open_shell: HashMap<u64, as_holder!(SurfacedOpenShell)>,
    swept_area_solid: HashMap<u64, as_holder!(SweptAreaSolid)>,
    swept_disk_solid: HashMap<u64, as_holder!(SweptDiskSolid)>,
    swept_face_solid: HashMap<u64, as_holder!(SweptFaceSolid)>,
    swept_surface: HashMap<u64, as_holder!(SweptSurface)>,
    symbol: HashMap<u64, as_holder!(Symbol)>,
    symbol_colour: HashMap<u64, as_holder!(SymbolColour)>,
    symbol_representation: HashMap<u64, as_holder!(SymbolRepresentation)>,
    symbol_representation_map: HashMap<u64, as_holder!(SymbolRepresentationMap)>,
    symbol_style: HashMap<u64, as_holder!(SymbolStyle)>,
    symbol_target: HashMap<u64, as_holder!(SymbolTarget)>,
    symmetric_shape_aspect: HashMap<u64, as_holder!(SymmetricShapeAspect)>,
    symmetry_tolerance: HashMap<u64, as_holder!(SymmetryTolerance)>,
    table_representation_item: HashMap<u64, as_holder!(TableRepresentationItem)>,
    tactile_appearance_representation: HashMap<u64, as_holder!(TactileAppearanceRepresentation)>,
    tagged_text_format: HashMap<u64, as_holder!(TaggedTextFormat)>,
    tagged_text_item: HashMap<u64, as_holder!(TaggedTextItem)>,
    tangent: HashMap<u64, as_holder!(Tangent)>,
    terminator_symbol: HashMap<u64, as_holder!(TerminatorSymbol)>,
    text_font: HashMap<u64, as_holder!(TextFont)>,
    text_font_family: HashMap<u64, as_holder!(TextFontFamily)>,
    text_font_in_family: HashMap<u64, as_holder!(TextFontInFamily)>,
    text_literal: HashMap<u64, as_holder!(TextLiteral)>,
    text_literal_with_associated_curves: HashMap<u64, as_holder!(TextLiteralWithAssociatedCurves)>,
    text_literal_with_blanking_box: HashMap<u64, as_holder!(TextLiteralWithBlankingBox)>,
    text_literal_with_delineation: HashMap<u64, as_holder!(TextLiteralWithDelineation)>,
    text_literal_with_extent: HashMap<u64, as_holder!(TextLiteralWithExtent)>,
    text_string_representation: HashMap<u64, as_holder!(TextStringRepresentation)>,
    text_style: HashMap<u64, as_holder!(TextStyle)>,
    text_style_for_defined_font: HashMap<u64, as_holder!(TextStyleForDefinedFont)>,
    text_style_with_box_characteristics: HashMap<u64, as_holder!(TextStyleWithBoxCharacteristics)>,
    text_style_with_mirror: HashMap<u64, as_holder!(TextStyleWithMirror)>,
    text_style_with_spacing: HashMap<u64, as_holder!(TextStyleWithSpacing)>,
    thermal_resistance_measure_with_unit:
        HashMap<u64, as_holder!(ThermalResistanceMeasureWithUnit)>,
    thermal_resistance_unit: HashMap<u64, as_holder!(ThermalResistanceUnit)>,
    thermodynamic_temperature_measure_with_unit:
        HashMap<u64, as_holder!(ThermodynamicTemperatureMeasureWithUnit)>,
    thermodynamic_temperature_unit: HashMap<u64, as_holder!(ThermodynamicTemperatureUnit)>,
    thickened_face_solid: HashMap<u64, as_holder!(ThickenedFaceSolid)>,
    thickness_laminate_definition: HashMap<u64, as_holder!(ThicknessLaminateDefinition)>,
    thickness_laminate_table: HashMap<u64, as_holder!(ThicknessLaminateTable)>,
    time_interval: HashMap<u64, as_holder!(TimeInterval)>,
    time_interval_assignment: HashMap<u64, as_holder!(TimeIntervalAssignment)>,
    time_interval_based_effectivity: HashMap<u64, as_holder!(TimeIntervalBasedEffectivity)>,
    time_interval_relationship: HashMap<u64, as_holder!(TimeIntervalRelationship)>,
    time_interval_role: HashMap<u64, as_holder!(TimeIntervalRole)>,
    time_interval_with_bounds: HashMap<u64, as_holder!(TimeIntervalWithBounds)>,
    time_measure_with_unit: HashMap<u64, as_holder!(TimeMeasureWithUnit)>,
    time_unit: HashMap<u64, as_holder!(TimeUnit)>,
    tolerance_value: HashMap<u64, as_holder!(ToleranceValue)>,
    tolerance_zone: HashMap<u64, as_holder!(ToleranceZone)>,
    tolerance_zone_definition: HashMap<u64, as_holder!(ToleranceZoneDefinition)>,
    tolerance_zone_form: HashMap<u64, as_holder!(ToleranceZoneForm)>,
    topological_representation_item: HashMap<u64, as_holder!(TopologicalRepresentationItem)>,
    toroidal_surface: HashMap<u64, as_holder!(ToroidalSurface)>,
    torus: HashMap<u64, as_holder!(Torus)>,
    total_runout_tolerance: HashMap<u64, as_holder!(TotalRunoutTolerance)>,
    track_blended_solid: HashMap<u64, as_holder!(TrackBlendedSolid)>,
    track_blended_solid_with_end_conditions:
        HashMap<u64, as_holder!(TrackBlendedSolidWithEndConditions)>,
    transformation_with_derived_angle: HashMap<u64, as_holder!(TransformationWithDerivedAngle)>,
    trimmed_curve: HashMap<u64, as_holder!(TrimmedCurve)>,
    two_direction_repeat_factor: HashMap<u64, as_holder!(TwoDirectionRepeatFactor)>,
    type_qualifier: HashMap<u64, as_holder!(TypeQualifier)>,
    unary_generic_expression: HashMap<u64, as_holder!(UnaryGenericExpression)>,
    unary_numeric_expression: HashMap<u64, as_holder!(UnaryNumericExpression)>,
    uncertainty_assigned_representation:
        HashMap<u64, as_holder!(UncertaintyAssignedRepresentation)>,
    uncertainty_measure_with_unit: HashMap<u64, as_holder!(UncertaintyMeasureWithUnit)>,
    uncertainty_qualifier: HashMap<u64, as_holder!(UncertaintyQualifier)>,
    uniform_curve: HashMap<u64, as_holder!(UniformCurve)>,
    uniform_resource_identifier: HashMap<u64, as_holder!(UniformResourceIdentifier)>,
    uniform_surface: HashMap<u64, as_holder!(UniformSurface)>,
    usage_association: HashMap<u64, as_holder!(UsageAssociation)>,
    user_defined_curve_font: HashMap<u64, as_holder!(UserDefinedCurveFont)>,
    user_defined_marker: HashMap<u64, as_holder!(UserDefinedMarker)>,
    user_defined_terminator_symbol: HashMap<u64, as_holder!(UserDefinedTerminatorSymbol)>,
    user_selected_elements: HashMap<u64, as_holder!(UserSelectedElements)>,
    user_selected_shape_elements: HashMap<u64, as_holder!(UserSelectedShapeElements)>,
    value_range: HashMap<u64, as_holder!(ValueRange)>,
    value_representation_item: HashMap<u64, as_holder!(ValueRepresentationItem)>,
    variable_semantics: HashMap<u64, as_holder!(VariableSemantics)>,
    variational_representation_item: HashMap<u64, as_holder!(VariationalRepresentationItem)>,
    vector: HashMap<u64, as_holder!(Vector)>,
    vector_style: HashMap<u64, as_holder!(VectorStyle)>,
    velocity_measure_with_unit: HashMap<u64, as_holder!(VelocityMeasureWithUnit)>,
    velocity_unit: HashMap<u64, as_holder!(VelocityUnit)>,
    versioned_action_request: HashMap<u64, as_holder!(VersionedActionRequest)>,
    vertex: HashMap<u64, as_holder!(Vertex)>,
    vertex_loop: HashMap<u64, as_holder!(VertexLoop)>,
    vertex_point: HashMap<u64, as_holder!(VertexPoint)>,
    vertex_shell: HashMap<u64, as_holder!(VertexShell)>,
    view_volume: HashMap<u64, as_holder!(ViewVolume)>,
    visual_appearance_representation: HashMap<u64, as_holder!(VisualAppearanceRepresentation)>,
    volume_measure_with_unit: HashMap<u64, as_holder!(VolumeMeasureWithUnit)>,
    volume_unit: HashMap<u64, as_holder!(VolumeUnit)>,
    week_of_year_and_day_date: HashMap<u64, as_holder!(WeekOfYearAndDayDate)>,
    wire_shell: HashMap<u64, as_holder!(WireShell)>,
    year_month: HashMap<u64, as_holder!(YearMonth)>,
    zone_structural_makeup: HashMap<u64, as_holder!(ZoneStructuralMakeup)>,
    absorbed_dose_measure: HashMap<u64, as_holder!(AbsorbedDoseMeasure)>,
    acceleration_measure: HashMap<u64, as_holder!(AccelerationMeasure)>,
    action_items: HashMap<u64, as_holder!(ActionItems)>,
    action_method_items: HashMap<u64, as_holder!(ActionMethodItems)>,
    action_request_item: HashMap<u64, as_holder!(ActionRequestItem)>,
    amount_of_substance_measure: HashMap<u64, as_holder!(AmountOfSubstanceMeasure)>,
    angle_direction_reference_select: HashMap<u64, as_holder!(AngleDirectionReferenceSelect)>,
    angle_direction_reference_with_a2p3d_select:
        HashMap<u64, as_holder!(AngleDirectionReferenceWithA2P3DSelect)>,
    annotation_plane_element: HashMap<u64, as_holder!(AnnotationPlaneElement)>,
    annotation_representation_select: HashMap<u64, as_holder!(AnnotationRepresentationSelect)>,
    annotation_symbol_occurrence_item: HashMap<u64, as_holder!(AnnotationSymbolOccurrenceItem)>,
    annotation_text_occurrence_item: HashMap<u64, as_holder!(AnnotationTextOccurrenceItem)>,
    approval_item: HashMap<u64, as_holder!(ApprovalItem)>,
    approved_item: HashMap<u64, as_holder!(ApprovedItem)>,
    area_measure: HashMap<u64, as_holder!(AreaMeasure)>,
    area_or_view: HashMap<u64, as_holder!(AreaOrView)>,
    attribute_classification_item: HashMap<u64, as_holder!(AttributeClassificationItem)>,
    attribute_language_item: HashMap<u64, as_holder!(AttributeLanguageItem)>,
    attribute_type: HashMap<u64, as_holder!(AttributeType)>,
    axis2_placement: HashMap<u64, as_holder!(Axis2Placement)>,
    base_solid_select: HashMap<u64, as_holder!(BaseSolidSelect)>,
    blend_end_condition_select: HashMap<u64, as_holder!(BlendEndConditionSelect)>,
    boolean_operand: HashMap<u64, as_holder!(BooleanOperand)>,
    box_characteristic_select: HashMap<u64, as_holder!(BoxCharacteristicSelect)>,
    box_height: HashMap<u64, as_holder!(BoxHeight)>,
    box_rotate_angle: HashMap<u64, as_holder!(BoxRotateAngle)>,
    box_slant_angle: HashMap<u64, as_holder!(BoxSlantAngle)>,
    box_width: HashMap<u64, as_holder!(BoxWidth)>,
    camera_model_d3_multi_clipping_interection_select:
        HashMap<u64, as_holder!(CameraModelD3MultiClippingInterectionSelect)>,
    camera_model_d3_multi_clipping_union_select:
        HashMap<u64, as_holder!(CameraModelD3MultiClippingUnionSelect)>,
    capacitance_measure: HashMap<u64, as_holder!(CapacitanceMeasure)>,
    category_usage_item: HashMap<u64, as_holder!(CategoryUsageItem)>,
    cc_classified_item: HashMap<u64, as_holder!(CcClassifiedItem)>,
    cc_person_organization_item: HashMap<u64, as_holder!(CcPersonOrganizationItem)>,
    cc_specified_item: HashMap<u64, as_holder!(CcSpecifiedItem)>,
    celsius_temperature_measure: HashMap<u64, as_holder!(CelsiusTemperatureMeasure)>,
    certification_item: HashMap<u64, as_holder!(CertificationItem)>,
    certified_item: HashMap<u64, as_holder!(CertifiedItem)>,
    change_request_item: HashMap<u64, as_holder!(ChangeRequestItem)>,
    character_spacing_select: HashMap<u64, as_holder!(CharacterSpacingSelect)>,
    character_style_select: HashMap<u64, as_holder!(CharacterStyleSelect)>,
    characterized_action_definition: HashMap<u64, as_holder!(CharacterizedActionDefinition)>,
    characterized_definition: HashMap<u64, as_holder!(CharacterizedDefinition)>,
    characterized_material_property: HashMap<u64, as_holder!(CharacterizedMaterialProperty)>,
    characterized_product_composition_value:
        HashMap<u64, as_holder!(CharacterizedProductCompositionValue)>,
    characterized_product_definition: HashMap<u64, as_holder!(CharacterizedProductDefinition)>,
    class_usage_effectivity_context_item:
        HashMap<u64, as_holder!(ClassUsageEffectivityContextItem)>,
    classification_item: HashMap<u64, as_holder!(ClassificationItem)>,
    classified_item: HashMap<u64, as_holder!(ClassifiedItem)>,
    compound_item_definition: HashMap<u64, as_holder!(CompoundItemDefinition)>,
    conductance_measure: HashMap<u64, as_holder!(ConductanceMeasure)>,
    configuration_design_item: HashMap<u64, as_holder!(ConfigurationDesignItem)>,
    configured_effectivity_context_item: HashMap<u64, as_holder!(ConfiguredEffectivityContextItem)>,
    configured_effectivity_item: HashMap<u64, as_holder!(ConfiguredEffectivityItem)>,
    constructive_geometry_representation_or_shape_represenation:
        HashMap<u64, as_holder!(ConstructiveGeometryRepresentationOrShapeRepresenation)>,
    context_dependent_measure: HashMap<u64, as_holder!(ContextDependentMeasure)>,
    contract_item: HashMap<u64, as_holder!(ContractItem)>,
    contracted_item: HashMap<u64, as_holder!(ContractedItem)>,
    count_measure: HashMap<u64, as_holder!(CountMeasure)>,
    csg_primitive: HashMap<u64, as_holder!(CsgPrimitive)>,
    csg_select: HashMap<u64, as_holder!(CsgSelect)>,
    curve_font_or_scaled_curve_font_select:
        HashMap<u64, as_holder!(CurveFontOrScaledCurveFontSelect)>,
    curve_on_surface: HashMap<u64, as_holder!(CurveOnSurface)>,
    curve_or_annotation_curve_occurrence:
        HashMap<u64, as_holder!(CurveOrAnnotationCurveOccurrence)>,
    curve_or_render: HashMap<u64, as_holder!(CurveOrRender)>,
    curve_style_font_select: HashMap<u64, as_holder!(CurveStyleFontSelect)>,
    date_and_time_item: HashMap<u64, as_holder!(DateAndTimeItem)>,
    date_item: HashMap<u64, as_holder!(DateItem)>,
    date_time_item: HashMap<u64, as_holder!(DateTimeItem)>,
    date_time_or_event_occurrence: HashMap<u64, as_holder!(DateTimeOrEventOccurrence)>,
    date_time_select: HashMap<u64, as_holder!(DateTimeSelect)>,
    day_in_month_number: HashMap<u64, as_holder!(DayInMonthNumber)>,
    day_in_week_number: HashMap<u64, as_holder!(DayInWeekNumber)>,
    day_in_year_number: HashMap<u64, as_holder!(DayInYearNumber)>,
    defined_symbol_select: HashMap<u64, as_holder!(DefinedSymbolSelect)>,
    derived_property_select: HashMap<u64, as_holder!(DerivedPropertySelect)>,
    description_attribute_select: HashMap<u64, as_holder!(DescriptionAttributeSelect)>,
    descriptive_measure: HashMap<u64, as_holder!(DescriptiveMeasure)>,
    dimension_count: HashMap<u64, as_holder!(DimensionCount)>,
    dimensional_characteristic: HashMap<u64, as_holder!(DimensionalCharacteristic)>,
    direction_count_select: HashMap<u64, as_holder!(DirectionCountSelect)>,
    document_identifier_assigned_item: HashMap<u64, as_holder!(DocumentIdentifierAssignedItem)>,
    document_reference_item: HashMap<u64, as_holder!(DocumentReferenceItem)>,
    dose_equivalent_measure: HashMap<u64, as_holder!(DoseEquivalentMeasure)>,
    draughting_callout_element: HashMap<u64, as_holder!(DraughtingCalloutElement)>,
    draughting_model_item_association_select:
        HashMap<u64, as_holder!(DraughtingModelItemAssociationSelect)>,
    draughting_model_item_select: HashMap<u64, as_holder!(DraughtingModelItemSelect)>,
    draughting_titled_item: HashMap<u64, as_holder!(DraughtingTitledItem)>,
    effectivity_item: HashMap<u64, as_holder!(EffectivityItem)>,
    electric_charge_measure: HashMap<u64, as_holder!(ElectricChargeMeasure)>,
    electric_current_measure: HashMap<u64, as_holder!(ElectricCurrentMeasure)>,
    electric_potential_measure: HashMap<u64, as_holder!(ElectricPotentialMeasure)>,
    energy_measure: HashMap<u64, as_holder!(EnergyMeasure)>,
    event_occurrence_item: HashMap<u64, as_holder!(EventOccurrenceItem)>,
    external_identification_item: HashMap<u64, as_holder!(ExternalIdentificationItem)>,
    fill_area_style_tile_shape_select: HashMap<u64, as_holder!(FillAreaStyleTileShapeSelect)>,
    fill_style_select: HashMap<u64, as_holder!(FillStyleSelect)>,
    font_select: HashMap<u64, as_holder!(FontSelect)>,
    force_measure: HashMap<u64, as_holder!(ForceMeasure)>,
    founded_item_select: HashMap<u64, as_holder!(FoundedItemSelect)>,
    frequency_measure: HashMap<u64, as_holder!(FrequencyMeasure)>,
    generalized_surface_select: HashMap<u64, as_holder!(GeneralizedSurfaceSelect)>,
    geometric_item_specific_usage_select:
        HashMap<u64, as_holder!(GeometricItemSpecificUsageSelect)>,
    geometric_set_select: HashMap<u64, as_holder!(GeometricSetSelect)>,
    groupable_item: HashMap<u64, as_holder!(GroupableItem)>,
    hour_in_day: HashMap<u64, as_holder!(HourInDay)>,
    id_attribute_select: HashMap<u64, as_holder!(IdAttributeSelect)>,
    identification_item: HashMap<u64, as_holder!(IdentificationItem)>,
    identifier: HashMap<u64, as_holder!(Identifier)>,
    illuminance_measure: HashMap<u64, as_holder!(IlluminanceMeasure)>,
    inductance_measure: HashMap<u64, as_holder!(InductanceMeasure)>,
    instance_usage_context_select: HashMap<u64, as_holder!(InstanceUsageContextSelect)>,
    invisibility_context: HashMap<u64, as_holder!(InvisibilityContext)>,
    invisible_item: HashMap<u64, as_holder!(InvisibleItem)>,
    ir_usage_item: HashMap<u64, as_holder!(IrUsageItem)>,
    label: HashMap<u64, as_holder!(Label)>,
    layered_item: HashMap<u64, as_holder!(LayeredItem)>,
    length_measure: HashMap<u64, as_holder!(LengthMeasure)>,
    list_of_reversible_topology_item: HashMap<u64, as_holder!(ListOfReversibleTopologyItem)>,
    list_representation_item: HashMap<u64, as_holder!(ListRepresentationItem)>,
    luminous_flux_measure: HashMap<u64, as_holder!(LuminousFluxMeasure)>,
    luminous_intensity_measure: HashMap<u64, as_holder!(LuminousIntensityMeasure)>,
    magnetic_flux_density_measure: HashMap<u64, as_holder!(MagneticFluxDensityMeasure)>,
    magnetic_flux_measure: HashMap<u64, as_holder!(MagneticFluxMeasure)>,
    marker_select: HashMap<u64, as_holder!(MarkerSelect)>,
    mass_measure: HashMap<u64, as_holder!(MassMeasure)>,
    measure_value: HashMap<u64, as_holder!(MeasureValue)>,
    mechanical_design_and_draughting_relationship_select:
        HashMap<u64, as_holder!(MechanicalDesignAndDraughtingRelationshipSelect)>,
    mechanical_design_geometric_presentation_area_items:
        HashMap<u64, as_holder!(MechanicalDesignGeometricPresentationAreaItems)>,
    mechanical_design_geometric_presentation_representation_items:
        HashMap<u64, as_holder!(MechanicalDesignGeometricPresentationRepresentationItems)>,
    message: HashMap<u64, as_holder!(Message)>,
    minute_in_hour: HashMap<u64, as_holder!(MinuteInHour)>,
    month_in_year_number: HashMap<u64, as_holder!(MonthInYearNumber)>,
    multi_language_attribute_item: HashMap<u64, as_holder!(MultiLanguageAttributeItem)>,
    name_attribute_select: HashMap<u64, as_holder!(NameAttributeSelect)>,
    name_item: HashMap<u64, as_holder!(NameItem)>,
    non_negative_length_measure: HashMap<u64, as_holder!(NonNegativeLengthMeasure)>,
    nonnegative_integer: HashMap<u64, as_holder!(NonnegativeInteger)>,
    numeric_measure: HashMap<u64, as_holder!(NumericMeasure)>,
    organization_item: HashMap<u64, as_holder!(OrganizationItem)>,
    orientation_basis_select: HashMap<u64, as_holder!(OrientationBasisSelect)>,
    parameter_value: HashMap<u64, as_holder!(ParameterValue)>,
    pcurve_or_surface: HashMap<u64, as_holder!(PcurveOrSurface)>,
    person_and_organization_item: HashMap<u64, as_holder!(PersonAndOrganizationItem)>,
    person_organization_select: HashMap<u64, as_holder!(PersonOrganizationSelect)>,
    picture_representation_item_select: HashMap<u64, as_holder!(PictureRepresentationItemSelect)>,
    plane_angle_measure: HashMap<u64, as_holder!(PlaneAngleMeasure)>,
    plane_or_planar_box: HashMap<u64, as_holder!(PlaneOrPlanarBox)>,
    point_and_vector_member: HashMap<u64, as_holder!(PointAndVectorMember)>,
    point_and_vector_members: HashMap<u64, as_holder!(PointAndVectorMembers)>,
    point_path_members: HashMap<u64, as_holder!(PointPathMembers)>,
    positive_integer: HashMap<u64, as_holder!(PositiveInteger)>,
    positive_length_measure: HashMap<u64, as_holder!(PositiveLengthMeasure)>,
    positive_plane_angle_measure: HashMap<u64, as_holder!(PositivePlaneAngleMeasure)>,
    positive_ratio_measure: HashMap<u64, as_holder!(PositiveRatioMeasure)>,
    power_measure: HashMap<u64, as_holder!(PowerMeasure)>,
    presentable_text: HashMap<u64, as_holder!(PresentableText)>,
    presentation_representation_select: HashMap<u64, as_holder!(PresentationRepresentationSelect)>,
    presentation_size_assignment_select: HashMap<u64, as_holder!(PresentationSizeAssignmentSelect)>,
    presentation_style_select: HashMap<u64, as_holder!(PresentationStyleSelect)>,
    presented_item_select: HashMap<u64, as_holder!(PresentedItemSelect)>,
    pressure_measure: HashMap<u64, as_holder!(PressureMeasure)>,
    product_definition_or_assembly_relationship:
        HashMap<u64, as_holder!(ProductDefinitionOrAssemblyRelationship)>,
    product_definition_or_breakdown_element_usage:
        HashMap<u64, as_holder!(ProductDefinitionOrBreakdownElementUsage)>,
    product_definition_or_product_definition_relationship:
        HashMap<u64, as_holder!(ProductDefinitionOrProductDefinitionRelationship)>,
    product_or_formation_or_definition: HashMap<u64, as_holder!(ProductOrFormationOrDefinition)>,
    project_item: HashMap<u64, as_holder!(ProjectItem)>,
    radioactivity_measure: HashMap<u64, as_holder!(RadioactivityMeasure)>,
    ratio_measure: HashMap<u64, as_holder!(RatioMeasure)>,
    rendering_properties_select: HashMap<u64, as_holder!(RenderingPropertiesSelect)>,
    represented_definition: HashMap<u64, as_holder!(RepresentedDefinition)>,
    requirement_assigned_item: HashMap<u64, as_holder!(RequirementAssignedItem)>,
    requirement_satisfaction_item: HashMap<u64, as_holder!(RequirementSatisfactionItem)>,
    requirement_source_item: HashMap<u64, as_holder!(RequirementSourceItem)>,
    resistance_measure: HashMap<u64, as_holder!(ResistanceMeasure)>,
    reversible_topology: HashMap<u64, as_holder!(ReversibleTopology)>,
    reversible_topology_item: HashMap<u64, as_holder!(ReversibleTopologyItem)>,
    role_select: HashMap<u64, as_holder!(RoleSelect)>,
    rule_superseded_item: HashMap<u64, as_holder!(RuleSupersededItem)>,
    second_in_minute: HashMap<u64, as_holder!(SecondInMinute)>,
    security_classification_item: HashMap<u64, as_holder!(SecurityClassificationItem)>,
    set_of_reversible_topology_item: HashMap<u64, as_holder!(SetOfReversibleTopologyItem)>,
    set_representation_item: HashMap<u64, as_holder!(SetRepresentationItem)>,
    shape_definition: HashMap<u64, as_holder!(ShapeDefinition)>,
    shell: HashMap<u64, as_holder!(Shell)>,
    size_select: HashMap<u64, as_holder!(SizeSelect)>,
    sketch_basis_select: HashMap<u64, as_holder!(SketchBasisSelect)>,
    solid_angle_measure: HashMap<u64, as_holder!(SolidAngleMeasure)>,
    source_item: HashMap<u64, as_holder!(SourceItem)>,
    start_request_item: HashMap<u64, as_holder!(StartRequestItem)>,
    string_representation_item_select: HashMap<u64, as_holder!(StringRepresentationItemSelect)>,
    style_context_select: HashMap<u64, as_holder!(StyleContextSelect)>,
    surface_side_style_select: HashMap<u64, as_holder!(SurfaceSideStyleSelect)>,
    surface_style_element_select: HashMap<u64, as_holder!(SurfaceStyleElementSelect)>,
    symbol_style_select: HashMap<u64, as_holder!(SymbolStyleSelect)>,
    text: HashMap<u64, as_holder!(Text)>,
    text_alignment: HashMap<u64, as_holder!(TextAlignment)>,
    text_delineation: HashMap<u64, as_holder!(TextDelineation)>,
    text_or_character: HashMap<u64, as_holder!(TextOrCharacter)>,
    text_string_representation_item: HashMap<u64, as_holder!(TextStringRepresentationItem)>,
    thermodynamic_temperature_measure: HashMap<u64, as_holder!(ThermodynamicTemperatureMeasure)>,
    time_interval_item: HashMap<u64, as_holder!(TimeIntervalItem)>,
    time_measure: HashMap<u64, as_holder!(TimeMeasure)>,
    tolerance_method_definition: HashMap<u64, as_holder!(ToleranceMethodDefinition)>,
    transformation: HashMap<u64, as_holder!(Transformation)>,
    trim_condition_select: HashMap<u64, as_holder!(TrimConditionSelect)>,
    trimming_select: HashMap<u64, as_holder!(TrimmingSelect)>,
    u_direction_count: HashMap<u64, as_holder!(UDirectionCount)>,
    unit: HashMap<u64, as_holder!(Unit)>,
    v_direction_count: HashMap<u64, as_holder!(VDirectionCount)>,
    value_qualifier: HashMap<u64, as_holder!(ValueQualifier)>,
    vector_or_direction: HashMap<u64, as_holder!(VectorOrDirection)>,
    velocity_measure: HashMap<u64, as_holder!(VelocityMeasure)>,
    volume_measure: HashMap<u64, as_holder!(VolumeMeasure)>,
    week_in_year_number: HashMap<u64, as_holder!(WeekInYearNumber)>,
    work_item: HashMap<u64, as_holder!(WorkItem)>,
    year_number: HashMap<u64, as_holder!(YearNumber)>,
}
impl Tables {
    pub fn absorbed_dose_measure_with_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AbsorbedDoseMeasureWithUnit)> {
        &self.absorbed_dose_measure_with_unit
    }
    pub fn absorbed_dose_unit_holders(&self) -> &HashMap<u64, as_holder!(AbsorbedDoseUnit)> {
        &self.absorbed_dose_unit
    }
    pub fn abstract_variable_holders(&self) -> &HashMap<u64, as_holder!(AbstractVariable)> {
        &self.abstract_variable
    }
    pub fn acceleration_measure_with_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AccelerationMeasureWithUnit)> {
        &self.acceleration_measure_with_unit
    }
    pub fn acceleration_unit_holders(&self) -> &HashMap<u64, as_holder!(AccelerationUnit)> {
        &self.acceleration_unit
    }
    pub fn action_holders(&self) -> &HashMap<u64, as_holder!(Action)> {
        &self.action
    }
    pub fn action_assignment_holders(&self) -> &HashMap<u64, as_holder!(ActionAssignment)> {
        &self.action_assignment
    }
    pub fn action_directive_holders(&self) -> &HashMap<u64, as_holder!(ActionDirective)> {
        &self.action_directive
    }
    pub fn action_method_holders(&self) -> &HashMap<u64, as_holder!(ActionMethod)> {
        &self.action_method
    }
    pub fn action_method_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ActionMethodAssignment)> {
        &self.action_method_assignment
    }
    pub fn action_method_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ActionMethodRelationship)> {
        &self.action_method_relationship
    }
    pub fn action_method_role_holders(&self) -> &HashMap<u64, as_holder!(ActionMethodRole)> {
        &self.action_method_role
    }
    pub fn action_property_holders(&self) -> &HashMap<u64, as_holder!(ActionProperty)> {
        &self.action_property
    }
    pub fn action_property_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ActionPropertyRepresentation)> {
        &self.action_property_representation
    }
    pub fn action_relationship_holders(&self) -> &HashMap<u64, as_holder!(ActionRelationship)> {
        &self.action_relationship
    }
    pub fn action_request_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ActionRequestAssignment)> {
        &self.action_request_assignment
    }
    pub fn action_request_solution_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ActionRequestSolution)> {
        &self.action_request_solution
    }
    pub fn action_request_status_holders(&self) -> &HashMap<u64, as_holder!(ActionRequestStatus)> {
        &self.action_request_status
    }
    pub fn action_status_holders(&self) -> &HashMap<u64, as_holder!(ActionStatus)> {
        &self.action_status
    }
    pub fn address_holders(&self) -> &HashMap<u64, as_holder!(Address)> {
        &self.address
    }
    pub fn advanced_brep_shape_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AdvancedBrepShapeRepresentation)> {
        &self.advanced_brep_shape_representation
    }
    pub fn advanced_face_holders(&self) -> &HashMap<u64, as_holder!(AdvancedFace)> {
        &self.advanced_face
    }
    pub fn alternate_product_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AlternateProductRelationship)> {
        &self.alternate_product_relationship
    }
    pub fn amount_of_substance_measure_with_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AmountOfSubstanceMeasureWithUnit)> {
        &self.amount_of_substance_measure_with_unit
    }
    pub fn amount_of_substance_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AmountOfSubstanceUnit)> {
        &self.amount_of_substance_unit
    }
    pub fn angle_direction_reference_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AngleDirectionReference)> {
        &self.angle_direction_reference
    }
    pub fn angular_dimension_holders(&self) -> &HashMap<u64, as_holder!(AngularDimension)> {
        &self.angular_dimension
    }
    pub fn angular_location_holders(&self) -> &HashMap<u64, as_holder!(AngularLocation)> {
        &self.angular_location
    }
    pub fn angular_size_holders(&self) -> &HashMap<u64, as_holder!(AngularSize)> {
        &self.angular_size
    }
    pub fn angularity_tolerance_holders(&self) -> &HashMap<u64, as_holder!(AngularityTolerance)> {
        &self.angularity_tolerance
    }
    pub fn annotation_curve_occurrence_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AnnotationCurveOccurrence)> {
        &self.annotation_curve_occurrence
    }
    pub fn annotation_fill_area_holders(&self) -> &HashMap<u64, as_holder!(AnnotationFillArea)> {
        &self.annotation_fill_area
    }
    pub fn annotation_fill_area_occurrence_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AnnotationFillAreaOccurrence)> {
        &self.annotation_fill_area_occurrence
    }
    pub fn annotation_occurrence_holders(&self) -> &HashMap<u64, as_holder!(AnnotationOccurrence)> {
        &self.annotation_occurrence
    }
    pub fn annotation_occurrence_associativity_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AnnotationOccurrenceAssociativity)> {
        &self.annotation_occurrence_associativity
    }
    pub fn annotation_occurrence_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AnnotationOccurrenceRelationship)> {
        &self.annotation_occurrence_relationship
    }
    pub fn annotation_plane_holders(&self) -> &HashMap<u64, as_holder!(AnnotationPlane)> {
        &self.annotation_plane
    }
    pub fn annotation_subfigure_occurrence_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AnnotationSubfigureOccurrence)> {
        &self.annotation_subfigure_occurrence
    }
    pub fn annotation_symbol_holders(&self) -> &HashMap<u64, as_holder!(AnnotationSymbol)> {
        &self.annotation_symbol
    }
    pub fn annotation_symbol_occurrence_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AnnotationSymbolOccurrence)> {
        &self.annotation_symbol_occurrence
    }
    pub fn annotation_text_holders(&self) -> &HashMap<u64, as_holder!(AnnotationText)> {
        &self.annotation_text
    }
    pub fn annotation_text_character_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AnnotationTextCharacter)> {
        &self.annotation_text_character
    }
    pub fn annotation_text_occurrence_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AnnotationTextOccurrence)> {
        &self.annotation_text_occurrence
    }
    pub fn apex_holders(&self) -> &HashMap<u64, as_holder!(Apex)> {
        &self.apex
    }
    pub fn application_context_holders(&self) -> &HashMap<u64, as_holder!(ApplicationContext)> {
        &self.application_context
    }
    pub fn application_context_element_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ApplicationContextElement)> {
        &self.application_context_element
    }
    pub fn application_protocol_definition_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ApplicationProtocolDefinition)> {
        &self.application_protocol_definition
    }
    pub fn applied_action_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AppliedActionAssignment)> {
        &self.applied_action_assignment
    }
    pub fn applied_action_method_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AppliedActionMethodAssignment)> {
        &self.applied_action_method_assignment
    }
    pub fn applied_action_request_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AppliedActionRequestAssignment)> {
        &self.applied_action_request_assignment
    }
    pub fn applied_approval_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AppliedApprovalAssignment)> {
        &self.applied_approval_assignment
    }
    pub fn applied_attribute_classification_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AppliedAttributeClassificationAssignment)> {
        &self.applied_attribute_classification_assignment
    }
    pub fn applied_certification_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AppliedCertificationAssignment)> {
        &self.applied_certification_assignment
    }
    pub fn applied_classification_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AppliedClassificationAssignment)> {
        &self.applied_classification_assignment
    }
    pub fn applied_contract_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AppliedContractAssignment)> {
        &self.applied_contract_assignment
    }
    pub fn applied_date_and_time_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AppliedDateAndTimeAssignment)> {
        &self.applied_date_and_time_assignment
    }
    pub fn applied_date_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AppliedDateAssignment)> {
        &self.applied_date_assignment
    }
    pub fn applied_document_reference_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AppliedDocumentReference)> {
        &self.applied_document_reference
    }
    pub fn applied_document_usage_constraint_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AppliedDocumentUsageConstraintAssignment)> {
        &self.applied_document_usage_constraint_assignment
    }
    pub fn applied_effectivity_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AppliedEffectivityAssignment)> {
        &self.applied_effectivity_assignment
    }
    pub fn applied_event_occurrence_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AppliedEventOccurrenceAssignment)> {
        &self.applied_event_occurrence_assignment
    }
    pub fn applied_external_identification_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AppliedExternalIdentificationAssignment)> {
        &self.applied_external_identification_assignment
    }
    pub fn applied_group_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AppliedGroupAssignment)> {
        &self.applied_group_assignment
    }
    pub fn applied_identification_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AppliedIdentificationAssignment)> {
        &self.applied_identification_assignment
    }
    pub fn applied_name_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AppliedNameAssignment)> {
        &self.applied_name_assignment
    }
    pub fn applied_organization_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AppliedOrganizationAssignment)> {
        &self.applied_organization_assignment
    }
    pub fn applied_organizational_project_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AppliedOrganizationalProjectAssignment)> {
        &self.applied_organizational_project_assignment
    }
    pub fn applied_person_and_organization_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AppliedPersonAndOrganizationAssignment)> {
        &self.applied_person_and_organization_assignment
    }
    pub fn applied_presented_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AppliedPresentedItem)> {
        &self.applied_presented_item
    }
    pub fn applied_security_classification_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AppliedSecurityClassificationAssignment)> {
        &self.applied_security_classification_assignment
    }
    pub fn applied_time_interval_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AppliedTimeIntervalAssignment)> {
        &self.applied_time_interval_assignment
    }
    pub fn applied_usage_right_holders(&self) -> &HashMap<u64, as_holder!(AppliedUsageRight)> {
        &self.applied_usage_right
    }
    pub fn approval_holders(&self) -> &HashMap<u64, as_holder!(Approval)> {
        &self.approval
    }
    pub fn approval_assignment_holders(&self) -> &HashMap<u64, as_holder!(ApprovalAssignment)> {
        &self.approval_assignment
    }
    pub fn approval_date_time_holders(&self) -> &HashMap<u64, as_holder!(ApprovalDateTime)> {
        &self.approval_date_time
    }
    pub fn approval_person_organization_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ApprovalPersonOrganization)> {
        &self.approval_person_organization
    }
    pub fn approval_relationship_holders(&self) -> &HashMap<u64, as_holder!(ApprovalRelationship)> {
        &self.approval_relationship
    }
    pub fn approval_role_holders(&self) -> &HashMap<u64, as_holder!(ApprovalRole)> {
        &self.approval_role
    }
    pub fn approval_status_holders(&self) -> &HashMap<u64, as_holder!(ApprovalStatus)> {
        &self.approval_status
    }
    pub fn area_in_set_holders(&self) -> &HashMap<u64, as_holder!(AreaInSet)> {
        &self.area_in_set
    }
    pub fn area_measure_with_unit_holders(&self) -> &HashMap<u64, as_holder!(AreaMeasureWithUnit)> {
        &self.area_measure_with_unit
    }
    pub fn area_unit_holders(&self) -> &HashMap<u64, as_holder!(AreaUnit)> {
        &self.area_unit
    }
    pub fn assembly_component_usage_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AssemblyComponentUsage)> {
        &self.assembly_component_usage
    }
    pub fn assembly_component_usage_substitute_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AssemblyComponentUsageSubstitute)> {
        &self.assembly_component_usage_substitute
    }
    pub fn assigned_requirement_holders(&self) -> &HashMap<u64, as_holder!(AssignedRequirement)> {
        &self.assigned_requirement
    }
    pub fn atomic_formula_holders(&self) -> &HashMap<u64, as_holder!(AtomicFormula)> {
        &self.atomic_formula
    }
    pub fn attribute_assertion_holders(&self) -> &HashMap<u64, as_holder!(AttributeAssertion)> {
        &self.attribute_assertion
    }
    pub fn attribute_classification_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AttributeClassificationAssignment)> {
        &self.attribute_classification_assignment
    }
    pub fn attribute_language_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AttributeLanguageAssignment)> {
        &self.attribute_language_assignment
    }
    pub fn attribute_value_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AttributeValueAssignment)> {
        &self.attribute_value_assignment
    }
    pub fn attribute_value_role_holders(&self) -> &HashMap<u64, as_holder!(AttributeValueRole)> {
        &self.attribute_value_role
    }
    pub fn auxiliary_geometric_representation_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AuxiliaryGeometricRepresentationItem)> {
        &self.auxiliary_geometric_representation_item
    }
    pub fn axis1_placement_holders(&self) -> &HashMap<u64, as_holder!(Axis1Placement)> {
        &self.axis1_placement
    }
    pub fn axis2_placement_2d_holders(&self) -> &HashMap<u64, as_holder!(Axis2Placement2D)> {
        &self.axis2_placement_2d
    }
    pub fn axis2_placement_3d_holders(&self) -> &HashMap<u64, as_holder!(Axis2Placement3D)> {
        &self.axis2_placement_3d
    }
    pub fn b_spline_curve_holders(&self) -> &HashMap<u64, as_holder!(BSplineCurve)> {
        &self.b_spline_curve
    }
    pub fn b_spline_curve_with_knots_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(BSplineCurveWithKnots)> {
        &self.b_spline_curve_with_knots
    }
    pub fn b_spline_surface_holders(&self) -> &HashMap<u64, as_holder!(BSplineSurface)> {
        &self.b_spline_surface
    }
    pub fn b_spline_surface_with_knots_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(BSplineSurfaceWithKnots)> {
        &self.b_spline_surface_with_knots
    }
    pub fn back_chaining_rule_holders(&self) -> &HashMap<u64, as_holder!(BackChainingRule)> {
        &self.back_chaining_rule
    }
    pub fn back_chaining_rule_body_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(BackChainingRuleBody)> {
        &self.back_chaining_rule_body
    }
    pub fn background_colour_holders(&self) -> &HashMap<u64, as_holder!(BackgroundColour)> {
        &self.background_colour
    }
    pub fn beveled_sheet_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(BeveledSheetRepresentation)> {
        &self.beveled_sheet_representation
    }
    pub fn bezier_curve_holders(&self) -> &HashMap<u64, as_holder!(BezierCurve)> {
        &self.bezier_curve
    }
    pub fn bezier_surface_holders(&self) -> &HashMap<u64, as_holder!(BezierSurface)> {
        &self.bezier_surface
    }
    pub fn binary_generic_expression_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(BinaryGenericExpression)> {
        &self.binary_generic_expression
    }
    pub fn binary_numeric_expression_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(BinaryNumericExpression)> {
        &self.binary_numeric_expression
    }
    pub fn binary_representation_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(BinaryRepresentationItem)> {
        &self.binary_representation_item
    }
    pub fn block_holders(&self) -> &HashMap<u64, as_holder!(Block)> {
        &self.block
    }
    pub fn boolean_expression_holders(&self) -> &HashMap<u64, as_holder!(BooleanExpression)> {
        &self.boolean_expression
    }
    pub fn boolean_literal_holders(&self) -> &HashMap<u64, as_holder!(BooleanLiteral)> {
        &self.boolean_literal
    }
    pub fn boolean_representation_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(BooleanRepresentationItem)> {
        &self.boolean_representation_item
    }
    pub fn boolean_result_holders(&self) -> &HashMap<u64, as_holder!(BooleanResult)> {
        &self.boolean_result
    }
    pub fn boundary_curve_holders(&self) -> &HashMap<u64, as_holder!(BoundaryCurve)> {
        &self.boundary_curve
    }
    pub fn bounded_curve_holders(&self) -> &HashMap<u64, as_holder!(BoundedCurve)> {
        &self.bounded_curve
    }
    pub fn bounded_pcurve_holders(&self) -> &HashMap<u64, as_holder!(BoundedPcurve)> {
        &self.bounded_pcurve
    }
    pub fn bounded_surface_holders(&self) -> &HashMap<u64, as_holder!(BoundedSurface)> {
        &self.bounded_surface
    }
    pub fn bounded_surface_curve_holders(&self) -> &HashMap<u64, as_holder!(BoundedSurfaceCurve)> {
        &self.bounded_surface_curve
    }
    pub fn box_domain_holders(&self) -> &HashMap<u64, as_holder!(BoxDomain)> {
        &self.box_domain
    }
    pub fn boxed_half_space_holders(&self) -> &HashMap<u64, as_holder!(BoxedHalfSpace)> {
        &self.boxed_half_space
    }
    pub fn breakdown_context_holders(&self) -> &HashMap<u64, as_holder!(BreakdownContext)> {
        &self.breakdown_context
    }
    pub fn breakdown_element_group_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(BreakdownElementGroupAssignment)> {
        &self.breakdown_element_group_assignment
    }
    pub fn breakdown_element_realization_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(BreakdownElementRealization)> {
        &self.breakdown_element_realization
    }
    pub fn breakdown_element_usage_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(BreakdownElementUsage)> {
        &self.breakdown_element_usage
    }
    pub fn breakdown_of_holders(&self) -> &HashMap<u64, as_holder!(BreakdownOf)> {
        &self.breakdown_of
    }
    pub fn brep_with_voids_holders(&self) -> &HashMap<u64, as_holder!(BrepWithVoids)> {
        &self.brep_with_voids
    }
    pub fn bytes_representation_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(BytesRepresentationItem)> {
        &self.bytes_representation_item
    }
    pub fn calendar_date_holders(&self) -> &HashMap<u64, as_holder!(CalendarDate)> {
        &self.calendar_date
    }
    pub fn camera_image_holders(&self) -> &HashMap<u64, as_holder!(CameraImage)> {
        &self.camera_image
    }
    pub fn camera_image_3d_with_scale_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CameraImage3DWithScale)> {
        &self.camera_image_3d_with_scale
    }
    pub fn camera_model_holders(&self) -> &HashMap<u64, as_holder!(CameraModel)> {
        &self.camera_model
    }
    pub fn camera_model_d3_holders(&self) -> &HashMap<u64, as_holder!(CameraModelD3)> {
        &self.camera_model_d3
    }
    pub fn camera_model_d3_multi_clipping_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CameraModelD3MultiClipping)> {
        &self.camera_model_d3_multi_clipping
    }
    pub fn camera_model_d3_multi_clipping_intersection_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CameraModelD3MultiClippingIntersection)> {
        &self.camera_model_d3_multi_clipping_intersection
    }
    pub fn camera_model_d3_multi_clipping_union_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CameraModelD3MultiClippingUnion)> {
        &self.camera_model_d3_multi_clipping_union
    }
    pub fn camera_model_d3_with_hlhsr_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CameraModelD3WithHlhsr)> {
        &self.camera_model_d3_with_hlhsr
    }
    pub fn camera_model_with_light_sources_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CameraModelWithLightSources)> {
        &self.camera_model_with_light_sources
    }
    pub fn camera_usage_holders(&self) -> &HashMap<u64, as_holder!(CameraUsage)> {
        &self.camera_usage
    }
    pub fn capacitance_measure_with_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CapacitanceMeasureWithUnit)> {
        &self.capacitance_measure_with_unit
    }
    pub fn capacitance_unit_holders(&self) -> &HashMap<u64, as_holder!(CapacitanceUnit)> {
        &self.capacitance_unit
    }
    pub fn cartesian_point_holders(&self) -> &HashMap<u64, as_holder!(CartesianPoint)> {
        &self.cartesian_point
    }
    pub fn cartesian_transformation_operator_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CartesianTransformationOperator)> {
        &self.cartesian_transformation_operator
    }
    pub fn cartesian_transformation_operator_2d_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CartesianTransformationOperator2D)> {
        &self.cartesian_transformation_operator_2d
    }
    pub fn cartesian_transformation_operator_3d_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CartesianTransformationOperator3D)> {
        &self.cartesian_transformation_operator_3d
    }
    pub fn cc_design_approval_holders(&self) -> &HashMap<u64, as_holder!(CcDesignApproval)> {
        &self.cc_design_approval
    }
    pub fn cc_design_certification_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CcDesignCertification)> {
        &self.cc_design_certification
    }
    pub fn cc_design_contract_holders(&self) -> &HashMap<u64, as_holder!(CcDesignContract)> {
        &self.cc_design_contract
    }
    pub fn cc_design_date_and_time_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CcDesignDateAndTimeAssignment)> {
        &self.cc_design_date_and_time_assignment
    }
    pub fn cc_design_person_and_organization_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CcDesignPersonAndOrganizationAssignment)> {
        &self.cc_design_person_and_organization_assignment
    }
    pub fn cc_design_security_classification_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CcDesignSecurityClassification)> {
        &self.cc_design_security_classification
    }
    pub fn cc_design_specification_reference_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CcDesignSpecificationReference)> {
        &self.cc_design_specification_reference
    }
    pub fn celsius_temperature_measure_with_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CelsiusTemperatureMeasureWithUnit)> {
        &self.celsius_temperature_measure_with_unit
    }
    pub fn centre_of_symmetry_holders(&self) -> &HashMap<u64, as_holder!(CentreOfSymmetry)> {
        &self.centre_of_symmetry
    }
    pub fn certification_holders(&self) -> &HashMap<u64, as_holder!(Certification)> {
        &self.certification
    }
    pub fn certification_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CertificationAssignment)> {
        &self.certification_assignment
    }
    pub fn certification_type_holders(&self) -> &HashMap<u64, as_holder!(CertificationType)> {
        &self.certification_type
    }
    pub fn change_holders(&self) -> &HashMap<u64, as_holder!(Change)> {
        &self.change
    }
    pub fn change_request_holders(&self) -> &HashMap<u64, as_holder!(ChangeRequest)> {
        &self.change_request
    }
    pub fn character_glyph_font_usage_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CharacterGlyphFontUsage)> {
        &self.character_glyph_font_usage
    }
    pub fn character_glyph_style_outline_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CharacterGlyphStyleOutline)> {
        &self.character_glyph_style_outline
    }
    pub fn character_glyph_style_stroke_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CharacterGlyphStyleStroke)> {
        &self.character_glyph_style_stroke
    }
    pub fn character_glyph_symbol_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CharacterGlyphSymbol)> {
        &self.character_glyph_symbol
    }
    pub fn character_glyph_symbol_outline_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CharacterGlyphSymbolOutline)> {
        &self.character_glyph_symbol_outline
    }
    pub fn character_glyph_symbol_stroke_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CharacterGlyphSymbolStroke)> {
        &self.character_glyph_symbol_stroke
    }
    pub fn characteristic_data_column_header_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CharacteristicDataColumnHeader)> {
        &self.characteristic_data_column_header
    }
    pub fn characteristic_data_column_header_link_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CharacteristicDataColumnHeaderLink)> {
        &self.characteristic_data_column_header_link
    }
    pub fn characteristic_data_table_header_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CharacteristicDataTableHeader)> {
        &self.characteristic_data_table_header
    }
    pub fn characteristic_data_table_header_decomposition_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CharacteristicDataTableHeaderDecomposition)> {
        &self.characteristic_data_table_header_decomposition
    }
    pub fn characteristic_type_holders(&self) -> &HashMap<u64, as_holder!(CharacteristicType)> {
        &self.characteristic_type
    }
    pub fn characterized_class_holders(&self) -> &HashMap<u64, as_holder!(CharacterizedClass)> {
        &self.characterized_class
    }
    pub fn characterized_object_holders(&self) -> &HashMap<u64, as_holder!(CharacterizedObject)> {
        &self.characterized_object
    }
    pub fn circle_holders(&self) -> &HashMap<u64, as_holder!(Circle)> {
        &self.circle
    }
    pub fn circular_runout_tolerance_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CircularRunoutTolerance)> {
        &self.circular_runout_tolerance
    }
    pub fn class_holders(&self) -> &HashMap<u64, as_holder!(Class)> {
        &self.class
    }
    pub fn class_by_extension_holders(&self) -> &HashMap<u64, as_holder!(ClassByExtension)> {
        &self.class_by_extension
    }
    pub fn class_by_intension_holders(&self) -> &HashMap<u64, as_holder!(ClassByIntension)> {
        &self.class_by_intension
    }
    pub fn class_system_holders(&self) -> &HashMap<u64, as_holder!(ClassSystem)> {
        &self.class_system
    }
    pub fn class_usage_effectivity_context_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ClassUsageEffectivityContextAssignment)> {
        &self.class_usage_effectivity_context_assignment
    }
    pub fn classification_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ClassificationAssignment)> {
        &self.classification_assignment
    }
    pub fn classification_role_holders(&self) -> &HashMap<u64, as_holder!(ClassificationRole)> {
        &self.classification_role
    }
    pub fn closed_shell_holders(&self) -> &HashMap<u64, as_holder!(ClosedShell)> {
        &self.closed_shell
    }
    pub fn coaxiality_tolerance_holders(&self) -> &HashMap<u64, as_holder!(CoaxialityTolerance)> {
        &self.coaxiality_tolerance
    }
    pub fn colour_holders(&self) -> &HashMap<u64, as_holder!(Colour)> {
        &self.colour
    }
    pub fn colour_rgb_holders(&self) -> &HashMap<u64, as_holder!(ColourRgb)> {
        &self.colour_rgb
    }
    pub fn colour_specification_holders(&self) -> &HashMap<u64, as_holder!(ColourSpecification)> {
        &self.colour_specification
    }
    pub fn common_datum_holders(&self) -> &HashMap<u64, as_holder!(CommonDatum)> {
        &self.common_datum
    }
    pub fn comparison_expression_holders(&self) -> &HashMap<u64, as_holder!(ComparisonExpression)> {
        &self.comparison_expression
    }
    pub fn complex_clause_holders(&self) -> &HashMap<u64, as_holder!(ComplexClause)> {
        &self.complex_clause
    }
    pub fn complex_conjunctive_clause_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ComplexConjunctiveClause)> {
        &self.complex_conjunctive_clause
    }
    pub fn complex_disjunctive_clause_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ComplexDisjunctiveClause)> {
        &self.complex_disjunctive_clause
    }
    pub fn complex_shelled_solid_holders(&self) -> &HashMap<u64, as_holder!(ComplexShelledSolid)> {
        &self.complex_shelled_solid
    }
    pub fn composite_assembly_definition_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CompositeAssemblyDefinition)> {
        &self.composite_assembly_definition
    }
    pub fn composite_assembly_sequence_definition_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CompositeAssemblySequenceDefinition)> {
        &self.composite_assembly_sequence_definition
    }
    pub fn composite_assembly_table_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CompositeAssemblyTable)> {
        &self.composite_assembly_table
    }
    pub fn composite_curve_holders(&self) -> &HashMap<u64, as_holder!(CompositeCurve)> {
        &self.composite_curve
    }
    pub fn composite_curve_on_surface_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CompositeCurveOnSurface)> {
        &self.composite_curve_on_surface
    }
    pub fn composite_curve_segment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CompositeCurveSegment)> {
        &self.composite_curve_segment
    }
    pub fn composite_material_designation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CompositeMaterialDesignation)> {
        &self.composite_material_designation
    }
    pub fn composite_shape_aspect_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CompositeShapeAspect)> {
        &self.composite_shape_aspect
    }
    pub fn composite_sheet_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CompositeSheetRepresentation)> {
        &self.composite_sheet_representation
    }
    pub fn composite_text_holders(&self) -> &HashMap<u64, as_holder!(CompositeText)> {
        &self.composite_text
    }
    pub fn composite_text_with_associated_curves_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CompositeTextWithAssociatedCurves)> {
        &self.composite_text_with_associated_curves
    }
    pub fn composite_text_with_blanking_box_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CompositeTextWithBlankingBox)> {
        &self.composite_text_with_blanking_box
    }
    pub fn composite_text_with_delineation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CompositeTextWithDelineation)> {
        &self.composite_text_with_delineation
    }
    pub fn composite_text_with_extent_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CompositeTextWithExtent)> {
        &self.composite_text_with_extent
    }
    pub fn compound_representation_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CompoundRepresentationItem)> {
        &self.compound_representation_item
    }
    pub fn compound_shape_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CompoundShapeRepresentation)> {
        &self.compound_shape_representation
    }
    pub fn concentricity_tolerance_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ConcentricityTolerance)> {
        &self.concentricity_tolerance
    }
    pub fn concept_feature_operator_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ConceptFeatureOperator)> {
        &self.concept_feature_operator
    }
    pub fn concept_feature_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ConceptFeatureRelationship)> {
        &self.concept_feature_relationship
    }
    pub fn concept_feature_relationship_with_condition_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ConceptFeatureRelationshipWithCondition)> {
        &self.concept_feature_relationship_with_condition
    }
    pub fn conditional_concept_feature_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ConditionalConceptFeature)> {
        &self.conditional_concept_feature
    }
    pub fn conductance_measure_with_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ConductanceMeasureWithUnit)> {
        &self.conductance_measure_with_unit
    }
    pub fn conductance_unit_holders(&self) -> &HashMap<u64, as_holder!(ConductanceUnit)> {
        &self.conductance_unit
    }
    pub fn configurable_item_holders(&self) -> &HashMap<u64, as_holder!(ConfigurableItem)> {
        &self.configurable_item
    }
    pub fn configuration_design_holders(&self) -> &HashMap<u64, as_holder!(ConfigurationDesign)> {
        &self.configuration_design
    }
    pub fn configuration_effectivity_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ConfigurationEffectivity)> {
        &self.configuration_effectivity
    }
    pub fn configuration_item_holders(&self) -> &HashMap<u64, as_holder!(ConfigurationItem)> {
        &self.configuration_item
    }
    pub fn configuration_item_hierarchical_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ConfigurationItemHierarchicalRelationship)> {
        &self.configuration_item_hierarchical_relationship
    }
    pub fn configuration_item_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ConfigurationItemRelationship)> {
        &self.configuration_item_relationship
    }
    pub fn configuration_item_revision_sequence_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ConfigurationItemRevisionSequence)> {
        &self.configuration_item_revision_sequence
    }
    pub fn configured_effectivity_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ConfiguredEffectivityAssignment)> {
        &self.configured_effectivity_assignment
    }
    pub fn configured_effectivity_context_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ConfiguredEffectivityContextAssignment)> {
        &self.configured_effectivity_context_assignment
    }
    pub fn conic_holders(&self) -> &HashMap<u64, as_holder!(Conic)> {
        &self.conic
    }
    pub fn conical_stepped_hole_transition_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ConicalSteppedHoleTransition)> {
        &self.conical_stepped_hole_transition
    }
    pub fn conical_surface_holders(&self) -> &HashMap<u64, as_holder!(ConicalSurface)> {
        &self.conical_surface
    }
    pub fn connected_edge_set_holders(&self) -> &HashMap<u64, as_holder!(ConnectedEdgeSet)> {
        &self.connected_edge_set
    }
    pub fn connected_face_set_holders(&self) -> &HashMap<u64, as_holder!(ConnectedFaceSet)> {
        &self.connected_face_set
    }
    pub fn connected_face_sub_set_holders(&self) -> &HashMap<u64, as_holder!(ConnectedFaceSubSet)> {
        &self.connected_face_sub_set
    }
    pub fn constructive_geometry_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ConstructiveGeometryRepresentation)> {
        &self.constructive_geometry_representation
    }
    pub fn constructive_geometry_representation_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ConstructiveGeometryRepresentationRelationship)> {
        &self.constructive_geometry_representation_relationship
    }
    pub fn contact_ratio_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ContactRatioRepresentation)> {
        &self.contact_ratio_representation
    }
    pub fn context_dependent_invisibility_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ContextDependentInvisibility)> {
        &self.context_dependent_invisibility
    }
    pub fn context_dependent_over_riding_styled_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ContextDependentOverRidingStyledItem)> {
        &self.context_dependent_over_riding_styled_item
    }
    pub fn context_dependent_shape_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ContextDependentShapeRepresentation)> {
        &self.context_dependent_shape_representation
    }
    pub fn context_dependent_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ContextDependentUnit)> {
        &self.context_dependent_unit
    }
    pub fn contract_holders(&self) -> &HashMap<u64, as_holder!(Contract)> {
        &self.contract
    }
    pub fn contract_assignment_holders(&self) -> &HashMap<u64, as_holder!(ContractAssignment)> {
        &self.contract_assignment
    }
    pub fn contract_relationship_holders(&self) -> &HashMap<u64, as_holder!(ContractRelationship)> {
        &self.contract_relationship
    }
    pub fn contract_type_holders(&self) -> &HashMap<u64, as_holder!(ContractType)> {
        &self.contract_type
    }
    pub fn conversion_based_unit_holders(&self) -> &HashMap<u64, as_holder!(ConversionBasedUnit)> {
        &self.conversion_based_unit
    }
    pub fn coordinated_universal_time_offset_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CoordinatedUniversalTimeOffset)> {
        &self.coordinated_universal_time_offset
    }
    pub fn csg_shape_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CsgShapeRepresentation)> {
        &self.csg_shape_representation
    }
    pub fn csg_solid_holders(&self) -> &HashMap<u64, as_holder!(CsgSolid)> {
        &self.csg_solid
    }
    pub fn currency_holders(&self) -> &HashMap<u64, as_holder!(Currency)> {
        &self.currency
    }
    pub fn currency_measure_with_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CurrencyMeasureWithUnit)> {
        &self.currency_measure_with_unit
    }
    pub fn curve_holders(&self) -> &HashMap<u64, as_holder!(Curve)> {
        &self.curve
    }
    pub fn curve_bounded_surface_holders(&self) -> &HashMap<u64, as_holder!(CurveBoundedSurface)> {
        &self.curve_bounded_surface
    }
    pub fn curve_dimension_holders(&self) -> &HashMap<u64, as_holder!(CurveDimension)> {
        &self.curve_dimension
    }
    pub fn curve_replica_holders(&self) -> &HashMap<u64, as_holder!(CurveReplica)> {
        &self.curve_replica
    }
    pub fn curve_style_holders(&self) -> &HashMap<u64, as_holder!(CurveStyle)> {
        &self.curve_style
    }
    pub fn curve_style_font_holders(&self) -> &HashMap<u64, as_holder!(CurveStyleFont)> {
        &self.curve_style_font
    }
    pub fn curve_style_font_and_scaling_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CurveStyleFontAndScaling)> {
        &self.curve_style_font_and_scaling
    }
    pub fn curve_style_font_pattern_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CurveStyleFontPattern)> {
        &self.curve_style_font_pattern
    }
    pub fn curve_style_rendering_holders(&self) -> &HashMap<u64, as_holder!(CurveStyleRendering)> {
        &self.curve_style_rendering
    }
    pub fn curve_swept_solid_shape_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CurveSweptSolidShapeRepresentation)> {
        &self.curve_swept_solid_shape_representation
    }
    pub fn cylindrical_surface_holders(&self) -> &HashMap<u64, as_holder!(CylindricalSurface)> {
        &self.cylindrical_surface
    }
    pub fn cylindricity_tolerance_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CylindricityTolerance)> {
        &self.cylindricity_tolerance
    }
    pub fn data_environment_holders(&self) -> &HashMap<u64, as_holder!(DataEnvironment)> {
        &self.data_environment
    }
    pub fn date_holders(&self) -> &HashMap<u64, as_holder!(Date)> {
        &self.date
    }
    pub fn date_and_time_holders(&self) -> &HashMap<u64, as_holder!(DateAndTime)> {
        &self.date_and_time
    }
    pub fn date_and_time_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DateAndTimeAssignment)> {
        &self.date_and_time_assignment
    }
    pub fn date_assignment_holders(&self) -> &HashMap<u64, as_holder!(DateAssignment)> {
        &self.date_assignment
    }
    pub fn date_representation_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DateRepresentationItem)> {
        &self.date_representation_item
    }
    pub fn date_role_holders(&self) -> &HashMap<u64, as_holder!(DateRole)> {
        &self.date_role
    }
    pub fn date_time_representation_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DateTimeRepresentationItem)> {
        &self.date_time_representation_item
    }
    pub fn date_time_role_holders(&self) -> &HashMap<u64, as_holder!(DateTimeRole)> {
        &self.date_time_role
    }
    pub fn dated_effectivity_holders(&self) -> &HashMap<u64, as_holder!(DatedEffectivity)> {
        &self.dated_effectivity
    }
    pub fn datum_holders(&self) -> &HashMap<u64, as_holder!(Datum)> {
        &self.datum
    }
    pub fn datum_feature_holders(&self) -> &HashMap<u64, as_holder!(DatumFeature)> {
        &self.datum_feature
    }
    pub fn datum_feature_callout_holders(&self) -> &HashMap<u64, as_holder!(DatumFeatureCallout)> {
        &self.datum_feature_callout
    }
    pub fn datum_reference_holders(&self) -> &HashMap<u64, as_holder!(DatumReference)> {
        &self.datum_reference
    }
    pub fn datum_target_holders(&self) -> &HashMap<u64, as_holder!(DatumTarget)> {
        &self.datum_target
    }
    pub fn datum_target_callout_holders(&self) -> &HashMap<u64, as_holder!(DatumTargetCallout)> {
        &self.datum_target_callout
    }
    pub fn default_tolerance_table_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DefaultToleranceTable)> {
        &self.default_tolerance_table
    }
    pub fn default_tolerance_table_cell_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DefaultToleranceTableCell)> {
        &self.default_tolerance_table_cell
    }
    pub fn defined_symbol_holders(&self) -> &HashMap<u64, as_holder!(DefinedSymbol)> {
        &self.defined_symbol
    }
    pub fn definitional_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DefinitionalRepresentation)> {
        &self.definitional_representation
    }
    pub fn definitional_representation_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DefinitionalRepresentationRelationship)> {
        &self.definitional_representation_relationship
    }
    pub fn definitional_representation_relationship_with_same_context_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DefinitionalRepresentationRelationshipWithSameContext)> {
        &self.definitional_representation_relationship_with_same_context
    }
    pub fn degenerate_pcurve_holders(&self) -> &HashMap<u64, as_holder!(DegeneratePcurve)> {
        &self.degenerate_pcurve
    }
    pub fn degenerate_toroidal_surface_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DegenerateToroidalSurface)> {
        &self.degenerate_toroidal_surface
    }
    pub fn derived_shape_aspect_holders(&self) -> &HashMap<u64, as_holder!(DerivedShapeAspect)> {
        &self.derived_shape_aspect
    }
    pub fn derived_unit_holders(&self) -> &HashMap<u64, as_holder!(DerivedUnit)> {
        &self.derived_unit
    }
    pub fn derived_unit_element_holders(&self) -> &HashMap<u64, as_holder!(DerivedUnitElement)> {
        &self.derived_unit_element
    }
    pub fn description_attribute_holders(&self) -> &HashMap<u64, as_holder!(DescriptionAttribute)> {
        &self.description_attribute
    }
    pub fn descriptive_representation_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DescriptiveRepresentationItem)> {
        &self.descriptive_representation_item
    }
    pub fn design_context_holders(&self) -> &HashMap<u64, as_holder!(DesignContext)> {
        &self.design_context
    }
    pub fn design_make_from_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DesignMakeFromRelationship)> {
        &self.design_make_from_relationship
    }
    pub fn diameter_dimension_holders(&self) -> &HashMap<u64, as_holder!(DiameterDimension)> {
        &self.diameter_dimension
    }
    pub fn dielectric_constant_measure_with_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DielectricConstantMeasureWithUnit)> {
        &self.dielectric_constant_measure_with_unit
    }
    pub fn dimension_callout_holders(&self) -> &HashMap<u64, as_holder!(DimensionCallout)> {
        &self.dimension_callout
    }
    pub fn dimension_callout_component_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DimensionCalloutComponentRelationship)> {
        &self.dimension_callout_component_relationship
    }
    pub fn dimension_callout_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DimensionCalloutRelationship)> {
        &self.dimension_callout_relationship
    }
    pub fn dimension_curve_holders(&self) -> &HashMap<u64, as_holder!(DimensionCurve)> {
        &self.dimension_curve
    }
    pub fn dimension_curve_directed_callout_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DimensionCurveDirectedCallout)> {
        &self.dimension_curve_directed_callout
    }
    pub fn dimension_curve_terminator_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DimensionCurveTerminator)> {
        &self.dimension_curve_terminator
    }
    pub fn dimension_curve_terminator_to_projection_curve_associativity_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DimensionCurveTerminatorToProjectionCurveAssociativity)> {
        &self.dimension_curve_terminator_to_projection_curve_associativity
    }
    pub fn dimension_pair_holders(&self) -> &HashMap<u64, as_holder!(DimensionPair)> {
        &self.dimension_pair
    }
    pub fn dimension_related_tolerance_zone_element_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DimensionRelatedToleranceZoneElement)> {
        &self.dimension_related_tolerance_zone_element
    }
    pub fn dimension_text_associativity_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DimensionTextAssociativity)> {
        &self.dimension_text_associativity
    }
    pub fn dimensional_characteristic_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DimensionalCharacteristicRepresentation)> {
        &self.dimensional_characteristic_representation
    }
    pub fn dimensional_exponents_holders(&self) -> &HashMap<u64, as_holder!(DimensionalExponents)> {
        &self.dimensional_exponents
    }
    pub fn dimensional_location_holders(&self) -> &HashMap<u64, as_holder!(DimensionalLocation)> {
        &self.dimensional_location
    }
    pub fn dimensional_location_with_path_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DimensionalLocationWithPath)> {
        &self.dimensional_location_with_path
    }
    pub fn dimensional_size_holders(&self) -> &HashMap<u64, as_holder!(DimensionalSize)> {
        &self.dimensional_size
    }
    pub fn dimensional_size_with_path_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DimensionalSizeWithPath)> {
        &self.dimensional_size_with_path
    }
    pub fn directed_action_holders(&self) -> &HashMap<u64, as_holder!(DirectedAction)> {
        &self.directed_action
    }
    pub fn directed_dimensional_location_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DirectedDimensionalLocation)> {
        &self.directed_dimensional_location
    }
    pub fn direction_holders(&self) -> &HashMap<u64, as_holder!(Direction)> {
        &self.direction
    }
    pub fn document_holders(&self) -> &HashMap<u64, as_holder!(Document)> {
        &self.document
    }
    pub fn document_file_holders(&self) -> &HashMap<u64, as_holder!(DocumentFile)> {
        &self.document_file
    }
    pub fn document_identifier_holders(&self) -> &HashMap<u64, as_holder!(DocumentIdentifier)> {
        &self.document_identifier
    }
    pub fn document_identifier_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DocumentIdentifierAssignment)> {
        &self.document_identifier_assignment
    }
    pub fn document_product_association_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DocumentProductAssociation)> {
        &self.document_product_association
    }
    pub fn document_product_equivalence_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DocumentProductEquivalence)> {
        &self.document_product_equivalence
    }
    pub fn document_reference_holders(&self) -> &HashMap<u64, as_holder!(DocumentReference)> {
        &self.document_reference
    }
    pub fn document_relationship_holders(&self) -> &HashMap<u64, as_holder!(DocumentRelationship)> {
        &self.document_relationship
    }
    pub fn document_representation_type_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DocumentRepresentationType)> {
        &self.document_representation_type
    }
    pub fn document_type_holders(&self) -> &HashMap<u64, as_holder!(DocumentType)> {
        &self.document_type
    }
    pub fn document_usage_constraint_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DocumentUsageConstraint)> {
        &self.document_usage_constraint
    }
    pub fn document_usage_constraint_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DocumentUsageConstraintAssignment)> {
        &self.document_usage_constraint_assignment
    }
    pub fn document_usage_role_holders(&self) -> &HashMap<u64, as_holder!(DocumentUsageRole)> {
        &self.document_usage_role
    }
    pub fn dose_equivalent_measure_with_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DoseEquivalentMeasureWithUnit)> {
        &self.dose_equivalent_measure_with_unit
    }
    pub fn dose_equivalent_unit_holders(&self) -> &HashMap<u64, as_holder!(DoseEquivalentUnit)> {
        &self.dose_equivalent_unit
    }
    pub fn double_offset_shelled_solid_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DoubleOffsetShelledSolid)> {
        &self.double_offset_shelled_solid
    }
    pub fn draped_defined_transformation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DrapedDefinedTransformation)> {
        &self.draped_defined_transformation
    }
    pub fn draughting_annotation_occurrence_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DraughtingAnnotationOccurrence)> {
        &self.draughting_annotation_occurrence
    }
    pub fn draughting_callout_holders(&self) -> &HashMap<u64, as_holder!(DraughtingCallout)> {
        &self.draughting_callout
    }
    pub fn draughting_callout_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DraughtingCalloutRelationship)> {
        &self.draughting_callout_relationship
    }
    pub fn draughting_elements_holders(&self) -> &HashMap<u64, as_holder!(DraughtingElements)> {
        &self.draughting_elements
    }
    pub fn draughting_model_holders(&self) -> &HashMap<u64, as_holder!(DraughtingModel)> {
        &self.draughting_model
    }
    pub fn draughting_model_item_association_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DraughtingModelItemAssociation)> {
        &self.draughting_model_item_association
    }
    pub fn draughting_pre_defined_colour_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DraughtingPreDefinedColour)> {
        &self.draughting_pre_defined_colour
    }
    pub fn draughting_pre_defined_curve_font_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DraughtingPreDefinedCurveFont)> {
        &self.draughting_pre_defined_curve_font
    }
    pub fn draughting_pre_defined_text_font_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DraughtingPreDefinedTextFont)> {
        &self.draughting_pre_defined_text_font
    }
    pub fn draughting_subfigure_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DraughtingSubfigureRepresentation)> {
        &self.draughting_subfigure_representation
    }
    pub fn draughting_symbol_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DraughtingSymbolRepresentation)> {
        &self.draughting_symbol_representation
    }
    pub fn draughting_text_literal_with_delineation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DraughtingTextLiteralWithDelineation)> {
        &self.draughting_text_literal_with_delineation
    }
    pub fn draughting_title_holders(&self) -> &HashMap<u64, as_holder!(DraughtingTitle)> {
        &self.draughting_title
    }
    pub fn drawing_definition_holders(&self) -> &HashMap<u64, as_holder!(DrawingDefinition)> {
        &self.drawing_definition
    }
    pub fn drawing_revision_holders(&self) -> &HashMap<u64, as_holder!(DrawingRevision)> {
        &self.drawing_revision
    }
    pub fn drawing_revision_sequence_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DrawingRevisionSequence)> {
        &self.drawing_revision_sequence
    }
    pub fn drawing_sheet_revision_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DrawingSheetRevision)> {
        &self.drawing_sheet_revision
    }
    pub fn drawing_sheet_revision_sequence_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DrawingSheetRevisionSequence)> {
        &self.drawing_sheet_revision_sequence
    }
    pub fn drawing_sheet_revision_usage_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DrawingSheetRevisionUsage)> {
        &self.drawing_sheet_revision_usage
    }
    pub fn edge_holders(&self) -> &HashMap<u64, as_holder!(Edge)> {
        &self.edge
    }
    pub fn edge_based_wireframe_model_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(EdgeBasedWireframeModel)> {
        &self.edge_based_wireframe_model
    }
    pub fn edge_based_wireframe_shape_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(EdgeBasedWireframeShapeRepresentation)> {
        &self.edge_based_wireframe_shape_representation
    }
    pub fn edge_blended_solid_holders(&self) -> &HashMap<u64, as_holder!(EdgeBlendedSolid)> {
        &self.edge_blended_solid
    }
    pub fn edge_curve_holders(&self) -> &HashMap<u64, as_holder!(EdgeCurve)> {
        &self.edge_curve
    }
    pub fn edge_loop_holders(&self) -> &HashMap<u64, as_holder!(EdgeLoop)> {
        &self.edge_loop
    }
    pub fn effectivity_holders(&self) -> &HashMap<u64, as_holder!(Effectivity)> {
        &self.effectivity
    }
    pub fn effectivity_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(EffectivityAssignment)> {
        &self.effectivity_assignment
    }
    pub fn effectivity_context_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(EffectivityContextAssignment)> {
        &self.effectivity_context_assignment
    }
    pub fn effectivity_context_role_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(EffectivityContextRole)> {
        &self.effectivity_context_role
    }
    pub fn effectivity_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(EffectivityRelationship)> {
        &self.effectivity_relationship
    }
    pub fn electric_charge_measure_with_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ElectricChargeMeasureWithUnit)> {
        &self.electric_charge_measure_with_unit
    }
    pub fn electric_charge_unit_holders(&self) -> &HashMap<u64, as_holder!(ElectricChargeUnit)> {
        &self.electric_charge_unit
    }
    pub fn electric_current_measure_with_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ElectricCurrentMeasureWithUnit)> {
        &self.electric_current_measure_with_unit
    }
    pub fn electric_current_unit_holders(&self) -> &HashMap<u64, as_holder!(ElectricCurrentUnit)> {
        &self.electric_current_unit
    }
    pub fn electric_potential_measure_with_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ElectricPotentialMeasureWithUnit)> {
        &self.electric_potential_measure_with_unit
    }
    pub fn electric_potential_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ElectricPotentialUnit)> {
        &self.electric_potential_unit
    }
    pub fn elementary_brep_shape_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ElementaryBrepShapeRepresentation)> {
        &self.elementary_brep_shape_representation
    }
    pub fn elementary_surface_holders(&self) -> &HashMap<u64, as_holder!(ElementarySurface)> {
        &self.elementary_surface
    }
    pub fn ellipse_holders(&self) -> &HashMap<u64, as_holder!(Ellipse)> {
        &self.ellipse
    }
    pub fn energy_measure_with_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(EnergyMeasureWithUnit)> {
        &self.energy_measure_with_unit
    }
    pub fn energy_unit_holders(&self) -> &HashMap<u64, as_holder!(EnergyUnit)> {
        &self.energy_unit
    }
    pub fn entity_assertion_holders(&self) -> &HashMap<u64, as_holder!(EntityAssertion)> {
        &self.entity_assertion
    }
    pub fn enum_reference_prefix_holders(&self) -> &HashMap<u64, as_holder!(EnumReferencePrefix)> {
        &self.enum_reference_prefix
    }
    pub fn environment_holders(&self) -> &HashMap<u64, as_holder!(Environment)> {
        &self.environment
    }
    pub fn evaluated_characteristic_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(EvaluatedCharacteristic)> {
        &self.evaluated_characteristic
    }
    pub fn evaluated_degenerate_pcurve_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(EvaluatedDegeneratePcurve)> {
        &self.evaluated_degenerate_pcurve
    }
    pub fn evaluation_product_definition_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(EvaluationProductDefinition)> {
        &self.evaluation_product_definition
    }
    pub fn event_occurrence_holders(&self) -> &HashMap<u64, as_holder!(EventOccurrence)> {
        &self.event_occurrence
    }
    pub fn event_occurrence_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(EventOccurrenceAssignment)> {
        &self.event_occurrence_assignment
    }
    pub fn event_occurrence_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(EventOccurrenceRelationship)> {
        &self.event_occurrence_relationship
    }
    pub fn event_occurrence_role_holders(&self) -> &HashMap<u64, as_holder!(EventOccurrenceRole)> {
        &self.event_occurrence_role
    }
    pub fn exclusive_product_concept_feature_category_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ExclusiveProductConceptFeatureCategory)> {
        &self.exclusive_product_concept_feature_category
    }
    pub fn executed_action_holders(&self) -> &HashMap<u64, as_holder!(ExecutedAction)> {
        &self.executed_action
    }
    pub fn expanded_uncertainty_holders(&self) -> &HashMap<u64, as_holder!(ExpandedUncertainty)> {
        &self.expanded_uncertainty
    }
    pub fn explicit_procedural_geometric_representation_item_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ExplicitProceduralGeometricRepresentationItemRelationship)> {
        &self.explicit_procedural_geometric_representation_item_relationship
    }
    pub fn explicit_procedural_representation_item_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ExplicitProceduralRepresentationItemRelationship)> {
        &self.explicit_procedural_representation_item_relationship
    }
    pub fn explicit_procedural_representation_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ExplicitProceduralRepresentationRelationship)> {
        &self.explicit_procedural_representation_relationship
    }
    pub fn explicit_procedural_shape_representation_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ExplicitProceduralShapeRepresentationRelationship)> {
        &self.explicit_procedural_shape_representation_relationship
    }
    pub fn expression_holders(&self) -> &HashMap<u64, as_holder!(Expression)> {
        &self.expression
    }
    pub fn expression_conversion_based_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ExpressionConversionBasedUnit)> {
        &self.expression_conversion_based_unit
    }
    pub fn extension_holders(&self) -> &HashMap<u64, as_holder!(Extension)> {
        &self.extension
    }
    pub fn extent_holders(&self) -> &HashMap<u64, as_holder!(Extent)> {
        &self.extent
    }
    pub fn external_class_library_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ExternalClassLibrary)> {
        &self.external_class_library
    }
    pub fn external_identification_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ExternalIdentificationAssignment)> {
        &self.external_identification_assignment
    }
    pub fn external_source_holders(&self) -> &HashMap<u64, as_holder!(ExternalSource)> {
        &self.external_source
    }
    pub fn external_source_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ExternalSourceRelationship)> {
        &self.external_source_relationship
    }
    pub fn externally_defined_class_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ExternallyDefinedClass)> {
        &self.externally_defined_class
    }
    pub fn externally_defined_colour_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ExternallyDefinedColour)> {
        &self.externally_defined_colour
    }
    pub fn externally_defined_context_dependent_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ExternallyDefinedContextDependentUnit)> {
        &self.externally_defined_context_dependent_unit
    }
    pub fn externally_defined_conversion_based_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ExternallyDefinedConversionBasedUnit)> {
        &self.externally_defined_conversion_based_unit
    }
    pub fn externally_defined_currency_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ExternallyDefinedCurrency)> {
        &self.externally_defined_currency
    }
    pub fn externally_defined_curve_font_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ExternallyDefinedCurveFont)> {
        &self.externally_defined_curve_font
    }
    pub fn externally_defined_dimension_definition_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ExternallyDefinedDimensionDefinition)> {
        &self.externally_defined_dimension_definition
    }
    pub fn externally_defined_general_property_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ExternallyDefinedGeneralProperty)> {
        &self.externally_defined_general_property
    }
    pub fn externally_defined_hatch_style_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ExternallyDefinedHatchStyle)> {
        &self.externally_defined_hatch_style
    }
    pub fn externally_defined_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ExternallyDefinedItem)> {
        &self.externally_defined_item
    }
    pub fn externally_defined_item_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ExternallyDefinedItemRelationship)> {
        &self.externally_defined_item_relationship
    }
    pub fn externally_defined_marker_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ExternallyDefinedMarker)> {
        &self.externally_defined_marker
    }
    pub fn externally_defined_picture_representation_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ExternallyDefinedPictureRepresentationItem)> {
        &self.externally_defined_picture_representation_item
    }
    pub fn externally_defined_representation_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ExternallyDefinedRepresentationItem)> {
        &self.externally_defined_representation_item
    }
    pub fn externally_defined_string_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ExternallyDefinedString)> {
        &self.externally_defined_string
    }
    pub fn externally_defined_symbol_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ExternallyDefinedSymbol)> {
        &self.externally_defined_symbol
    }
    pub fn externally_defined_terminator_symbol_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ExternallyDefinedTerminatorSymbol)> {
        &self.externally_defined_terminator_symbol
    }
    pub fn externally_defined_text_font_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ExternallyDefinedTextFont)> {
        &self.externally_defined_text_font
    }
    pub fn externally_defined_tile_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ExternallyDefinedTile)> {
        &self.externally_defined_tile
    }
    pub fn externally_defined_tile_style_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ExternallyDefinedTileStyle)> {
        &self.externally_defined_tile_style
    }
    pub fn extruded_area_solid_holders(&self) -> &HashMap<u64, as_holder!(ExtrudedAreaSolid)> {
        &self.extruded_area_solid
    }
    pub fn extruded_face_solid_holders(&self) -> &HashMap<u64, as_holder!(ExtrudedFaceSolid)> {
        &self.extruded_face_solid
    }
    pub fn extruded_face_solid_with_draft_angle_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ExtrudedFaceSolidWithDraftAngle)> {
        &self.extruded_face_solid_with_draft_angle
    }
    pub fn extruded_face_solid_with_multiple_draft_angles_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ExtrudedFaceSolidWithMultipleDraftAngles)> {
        &self.extruded_face_solid_with_multiple_draft_angles
    }
    pub fn extruded_face_solid_with_trim_conditions_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ExtrudedFaceSolidWithTrimConditions)> {
        &self.extruded_face_solid_with_trim_conditions
    }
    pub fn face_holders(&self) -> &HashMap<u64, as_holder!(Face)> {
        &self.face
    }
    pub fn face_based_surface_model_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(FaceBasedSurfaceModel)> {
        &self.face_based_surface_model
    }
    pub fn face_bound_holders(&self) -> &HashMap<u64, as_holder!(FaceBound)> {
        &self.face_bound
    }
    pub fn face_outer_bound_holders(&self) -> &HashMap<u64, as_holder!(FaceOuterBound)> {
        &self.face_outer_bound
    }
    pub fn face_surface_holders(&self) -> &HashMap<u64, as_holder!(FaceSurface)> {
        &self.face_surface
    }
    pub fn faceted_brep_holders(&self) -> &HashMap<u64, as_holder!(FacetedBrep)> {
        &self.faceted_brep
    }
    pub fn faceted_brep_shape_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(FacetedBrepShapeRepresentation)> {
        &self.faceted_brep_shape_representation
    }
    pub fn fact_type_holders(&self) -> &HashMap<u64, as_holder!(FactType)> {
        &self.fact_type
    }
    pub fn fill_area_style_holders(&self) -> &HashMap<u64, as_holder!(FillAreaStyle)> {
        &self.fill_area_style
    }
    pub fn fill_area_style_colour_holders(&self) -> &HashMap<u64, as_holder!(FillAreaStyleColour)> {
        &self.fill_area_style_colour
    }
    pub fn fill_area_style_hatching_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(FillAreaStyleHatching)> {
        &self.fill_area_style_hatching
    }
    pub fn fill_area_style_tile_coloured_region_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(FillAreaStyleTileColouredRegion)> {
        &self.fill_area_style_tile_coloured_region
    }
    pub fn fill_area_style_tile_curve_with_style_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(FillAreaStyleTileCurveWithStyle)> {
        &self.fill_area_style_tile_curve_with_style
    }
    pub fn fill_area_style_tile_symbol_with_style_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(FillAreaStyleTileSymbolWithStyle)> {
        &self.fill_area_style_tile_symbol_with_style
    }
    pub fn fill_area_style_tiles_holders(&self) -> &HashMap<u64, as_holder!(FillAreaStyleTiles)> {
        &self.fill_area_style_tiles
    }
    pub fn flat_pattern_ply_representation_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(FlatPatternPlyRepresentationRelationship)> {
        &self.flat_pattern_ply_representation_relationship
    }
    pub fn flatness_tolerance_holders(&self) -> &HashMap<u64, as_holder!(FlatnessTolerance)> {
        &self.flatness_tolerance
    }
    pub fn force_measure_with_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ForceMeasureWithUnit)> {
        &self.force_measure_with_unit
    }
    pub fn force_unit_holders(&self) -> &HashMap<u64, as_holder!(ForceUnit)> {
        &self.force_unit
    }
    pub fn forward_chaining_rule_holders(&self) -> &HashMap<u64, as_holder!(ForwardChainingRule)> {
        &self.forward_chaining_rule
    }
    pub fn forward_chaining_rule_premise_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ForwardChainingRulePremise)> {
        &self.forward_chaining_rule_premise
    }
    pub fn founded_item_holders(&self) -> &HashMap<u64, as_holder!(FoundedItem)> {
        &self.founded_item
    }
    pub fn frequency_measure_with_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(FrequencyMeasureWithUnit)> {
        &self.frequency_measure_with_unit
    }
    pub fn frequency_unit_holders(&self) -> &HashMap<u64, as_holder!(FrequencyUnit)> {
        &self.frequency_unit
    }
    pub fn func_holders(&self) -> &HashMap<u64, as_holder!(Func)> {
        &self.func
    }
    pub fn functional_breakdown_context_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(FunctionalBreakdownContext)> {
        &self.functional_breakdown_context
    }
    pub fn functional_element_usage_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(FunctionalElementUsage)> {
        &self.functional_element_usage
    }
    pub fn functionally_defined_transformation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(FunctionallyDefinedTransformation)> {
        &self.functionally_defined_transformation
    }
    pub fn general_material_property_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(GeneralMaterialProperty)> {
        &self.general_material_property
    }
    pub fn general_property_holders(&self) -> &HashMap<u64, as_holder!(GeneralProperty)> {
        &self.general_property
    }
    pub fn general_property_association_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(GeneralPropertyAssociation)> {
        &self.general_property_association
    }
    pub fn general_property_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(GeneralPropertyRelationship)> {
        &self.general_property_relationship
    }
    pub fn generic_character_glyph_symbol_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(GenericCharacterGlyphSymbol)> {
        &self.generic_character_glyph_symbol
    }
    pub fn generic_expression_holders(&self) -> &HashMap<u64, as_holder!(GenericExpression)> {
        &self.generic_expression
    }
    pub fn generic_literal_holders(&self) -> &HashMap<u64, as_holder!(GenericLiteral)> {
        &self.generic_literal
    }
    pub fn generic_variable_holders(&self) -> &HashMap<u64, as_holder!(GenericVariable)> {
        &self.generic_variable
    }
    pub fn geometric_alignment_holders(&self) -> &HashMap<u64, as_holder!(GeometricAlignment)> {
        &self.geometric_alignment
    }
    pub fn geometric_curve_set_holders(&self) -> &HashMap<u64, as_holder!(GeometricCurveSet)> {
        &self.geometric_curve_set
    }
    pub fn geometric_intersection_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(GeometricIntersection)> {
        &self.geometric_intersection
    }
    pub fn geometric_item_specific_usage_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(GeometricItemSpecificUsage)> {
        &self.geometric_item_specific_usage
    }
    pub fn geometric_model_element_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(GeometricModelElementRelationship)> {
        &self.geometric_model_element_relationship
    }
    pub fn geometric_representation_context_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(GeometricRepresentationContext)> {
        &self.geometric_representation_context
    }
    pub fn geometric_representation_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(GeometricRepresentationItem)> {
        &self.geometric_representation_item
    }
    pub fn geometric_set_holders(&self) -> &HashMap<u64, as_holder!(GeometricSet)> {
        &self.geometric_set
    }
    pub fn geometric_tolerance_holders(&self) -> &HashMap<u64, as_holder!(GeometricTolerance)> {
        &self.geometric_tolerance
    }
    pub fn geometric_tolerance_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(GeometricToleranceRelationship)> {
        &self.geometric_tolerance_relationship
    }
    pub fn geometric_tolerance_with_datum_reference_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(GeometricToleranceWithDatumReference)> {
        &self.geometric_tolerance_with_datum_reference
    }
    pub fn geometric_tolerance_with_defined_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(GeometricToleranceWithDefinedUnit)> {
        &self.geometric_tolerance_with_defined_unit
    }
    pub fn geometrical_tolerance_callout_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(GeometricalToleranceCallout)> {
        &self.geometrical_tolerance_callout
    }
    pub fn geometrically_bounded_2d_wireframe_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(GeometricallyBounded2DWireframeRepresentation)> {
        &self.geometrically_bounded_2d_wireframe_representation
    }
    pub fn geometrically_bounded_surface_shape_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(GeometricallyBoundedSurfaceShapeRepresentation)> {
        &self.geometrically_bounded_surface_shape_representation
    }
    pub fn geometrically_bounded_wireframe_shape_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(GeometricallyBoundedWireframeShapeRepresentation)> {
        &self.geometrically_bounded_wireframe_shape_representation
    }
    pub fn global_assignment_holders(&self) -> &HashMap<u64, as_holder!(GlobalAssignment)> {
        &self.global_assignment
    }
    pub fn global_uncertainty_assigned_context_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(GlobalUncertaintyAssignedContext)> {
        &self.global_uncertainty_assigned_context
    }
    pub fn global_unit_assigned_context_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(GlobalUnitAssignedContext)> {
        &self.global_unit_assigned_context
    }
    pub fn ground_fact_holders(&self) -> &HashMap<u64, as_holder!(GroundFact)> {
        &self.ground_fact
    }
    pub fn group_holders(&self) -> &HashMap<u64, as_holder!(Group)> {
        &self.group
    }
    pub fn group_assignment_holders(&self) -> &HashMap<u64, as_holder!(GroupAssignment)> {
        &self.group_assignment
    }
    pub fn group_relationship_holders(&self) -> &HashMap<u64, as_holder!(GroupRelationship)> {
        &self.group_relationship
    }
    pub fn half_space_solid_holders(&self) -> &HashMap<u64, as_holder!(HalfSpaceSolid)> {
        &self.half_space_solid
    }
    pub fn hardness_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(HardnessRepresentation)> {
        &self.hardness_representation
    }
    pub fn hidden_element_over_riding_styled_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(HiddenElementOverRidingStyledItem)> {
        &self.hidden_element_over_riding_styled_item
    }
    pub fn hyperbola_holders(&self) -> &HashMap<u64, as_holder!(Hyperbola)> {
        &self.hyperbola
    }
    pub fn id_attribute_holders(&self) -> &HashMap<u64, as_holder!(IdAttribute)> {
        &self.id_attribute
    }
    pub fn identification_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(IdentificationAssignment)> {
        &self.identification_assignment
    }
    pub fn identification_role_holders(&self) -> &HashMap<u64, as_holder!(IdentificationRole)> {
        &self.identification_role
    }
    pub fn illuminance_measure_with_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(IlluminanceMeasureWithUnit)> {
        &self.illuminance_measure_with_unit
    }
    pub fn illuminance_unit_holders(&self) -> &HashMap<u64, as_holder!(IlluminanceUnit)> {
        &self.illuminance_unit
    }
    pub fn included_text_block_holders(&self) -> &HashMap<u64, as_holder!(IncludedTextBlock)> {
        &self.included_text_block
    }
    pub fn inclusion_product_concept_feature_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(InclusionProductConceptFeature)> {
        &self.inclusion_product_concept_feature
    }
    pub fn indirectly_selected_elements_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(IndirectlySelectedElements)> {
        &self.indirectly_selected_elements
    }
    pub fn indirectly_selected_shape_elements_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(IndirectlySelectedShapeElements)> {
        &self.indirectly_selected_shape_elements
    }
    pub fn inductance_measure_with_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(InductanceMeasureWithUnit)> {
        &self.inductance_measure_with_unit
    }
    pub fn inductance_unit_holders(&self) -> &HashMap<u64, as_holder!(InductanceUnit)> {
        &self.inductance_unit
    }
    pub fn information_right_holders(&self) -> &HashMap<u64, as_holder!(InformationRight)> {
        &self.information_right
    }
    pub fn information_usage_right_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(InformationUsageRight)> {
        &self.information_usage_right
    }
    pub fn instance_usage_context_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(InstanceUsageContextAssignment)> {
        &self.instance_usage_context_assignment
    }
    pub fn instanced_feature_holders(&self) -> &HashMap<u64, as_holder!(InstancedFeature)> {
        &self.instanced_feature
    }
    pub fn int_literal_holders(&self) -> &HashMap<u64, as_holder!(IntLiteral)> {
        &self.int_literal
    }
    pub fn integer_representation_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(IntegerRepresentationItem)> {
        &self.integer_representation_item
    }
    pub fn intersection_curve_holders(&self) -> &HashMap<u64, as_holder!(IntersectionCurve)> {
        &self.intersection_curve
    }
    pub fn interval_expression_holders(&self) -> &HashMap<u64, as_holder!(IntervalExpression)> {
        &self.interval_expression
    }
    pub fn invisibility_holders(&self) -> &HashMap<u64, as_holder!(Invisibility)> {
        &self.invisibility
    }
    pub fn iso4217_currency_holders(&self) -> &HashMap<u64, as_holder!(Iso4217Currency)> {
        &self.iso4217_currency
    }
    pub fn item_defined_transformation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ItemDefinedTransformation)> {
        &self.item_defined_transformation
    }
    pub fn item_identified_representation_usage_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ItemIdentifiedRepresentationUsage)> {
        &self.item_identified_representation_usage
    }
    pub fn known_source_holders(&self) -> &HashMap<u64, as_holder!(KnownSource)> {
        &self.known_source
    }
    pub fn laid_defined_transformation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(LaidDefinedTransformation)> {
        &self.laid_defined_transformation
    }
    pub fn laminate_table_holders(&self) -> &HashMap<u64, as_holder!(LaminateTable)> {
        &self.laminate_table
    }
    pub fn language_holders(&self) -> &HashMap<u64, as_holder!(Language)> {
        &self.language
    }
    pub fn leader_curve_holders(&self) -> &HashMap<u64, as_holder!(LeaderCurve)> {
        &self.leader_curve
    }
    pub fn leader_directed_callout_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(LeaderDirectedCallout)> {
        &self.leader_directed_callout
    }
    pub fn leader_directed_dimension_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(LeaderDirectedDimension)> {
        &self.leader_directed_dimension
    }
    pub fn leader_terminator_holders(&self) -> &HashMap<u64, as_holder!(LeaderTerminator)> {
        &self.leader_terminator
    }
    pub fn length_measure_with_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(LengthMeasureWithUnit)> {
        &self.length_measure_with_unit
    }
    pub fn length_unit_holders(&self) -> &HashMap<u64, as_holder!(LengthUnit)> {
        &self.length_unit
    }
    pub fn light_source_holders(&self) -> &HashMap<u64, as_holder!(LightSource)> {
        &self.light_source
    }
    pub fn light_source_ambient_holders(&self) -> &HashMap<u64, as_holder!(LightSourceAmbient)> {
        &self.light_source_ambient
    }
    pub fn light_source_directional_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(LightSourceDirectional)> {
        &self.light_source_directional
    }
    pub fn light_source_positional_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(LightSourcePositional)> {
        &self.light_source_positional
    }
    pub fn light_source_spot_holders(&self) -> &HashMap<u64, as_holder!(LightSourceSpot)> {
        &self.light_source_spot
    }
    pub fn limits_and_fits_holders(&self) -> &HashMap<u64, as_holder!(LimitsAndFits)> {
        &self.limits_and_fits
    }
    pub fn line_holders(&self) -> &HashMap<u64, as_holder!(Line)> {
        &self.line
    }
    pub fn line_profile_tolerance_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(LineProfileTolerance)> {
        &self.line_profile_tolerance
    }
    pub fn linear_dimension_holders(&self) -> &HashMap<u64, as_holder!(LinearDimension)> {
        &self.linear_dimension
    }
    pub fn literal_conjunction_holders(&self) -> &HashMap<u64, as_holder!(LiteralConjunction)> {
        &self.literal_conjunction
    }
    pub fn literal_disjunction_holders(&self) -> &HashMap<u64, as_holder!(LiteralDisjunction)> {
        &self.literal_disjunction
    }
    pub fn literal_number_holders(&self) -> &HashMap<u64, as_holder!(LiteralNumber)> {
        &self.literal_number
    }
    pub fn local_time_holders(&self) -> &HashMap<u64, as_holder!(LocalTime)> {
        &self.local_time
    }
    pub fn logical_literal_holders(&self) -> &HashMap<u64, as_holder!(LogicalLiteral)> {
        &self.logical_literal
    }
    pub fn logical_representation_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(LogicalRepresentationItem)> {
        &self.logical_representation_item
    }
    pub fn loop_holders(&self) -> &HashMap<u64, as_holder!(Loop)> {
        &self.r#loop
    }
    pub fn loss_tangent_measure_with_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(LossTangentMeasureWithUnit)> {
        &self.loss_tangent_measure_with_unit
    }
    pub fn lot_effectivity_holders(&self) -> &HashMap<u64, as_holder!(LotEffectivity)> {
        &self.lot_effectivity
    }
    pub fn luminous_flux_measure_with_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(LuminousFluxMeasureWithUnit)> {
        &self.luminous_flux_measure_with_unit
    }
    pub fn luminous_flux_unit_holders(&self) -> &HashMap<u64, as_holder!(LuminousFluxUnit)> {
        &self.luminous_flux_unit
    }
    pub fn luminous_intensity_measure_with_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(LuminousIntensityMeasureWithUnit)> {
        &self.luminous_intensity_measure_with_unit
    }
    pub fn luminous_intensity_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(LuminousIntensityUnit)> {
        &self.luminous_intensity_unit
    }
    pub fn magnetic_flux_density_measure_with_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(MagneticFluxDensityMeasureWithUnit)> {
        &self.magnetic_flux_density_measure_with_unit
    }
    pub fn magnetic_flux_density_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(MagneticFluxDensityUnit)> {
        &self.magnetic_flux_density_unit
    }
    pub fn magnetic_flux_measure_with_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(MagneticFluxMeasureWithUnit)> {
        &self.magnetic_flux_measure_with_unit
    }
    pub fn magnetic_flux_unit_holders(&self) -> &HashMap<u64, as_holder!(MagneticFluxUnit)> {
        &self.magnetic_flux_unit
    }
    pub fn make_from_usage_option_holders(&self) -> &HashMap<u64, as_holder!(MakeFromUsageOption)> {
        &self.make_from_usage_option
    }
    pub fn manifold_solid_brep_holders(&self) -> &HashMap<u64, as_holder!(ManifoldSolidBrep)> {
        &self.manifold_solid_brep
    }
    pub fn manifold_subsurface_shape_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ManifoldSubsurfaceShapeRepresentation)> {
        &self.manifold_subsurface_shape_representation
    }
    pub fn manifold_surface_shape_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ManifoldSurfaceShapeRepresentation)> {
        &self.manifold_surface_shape_representation
    }
    pub fn mapped_item_holders(&self) -> &HashMap<u64, as_holder!(MappedItem)> {
        &self.mapped_item
    }
    pub fn mass_measure_with_unit_holders(&self) -> &HashMap<u64, as_holder!(MassMeasureWithUnit)> {
        &self.mass_measure_with_unit
    }
    pub fn mass_unit_holders(&self) -> &HashMap<u64, as_holder!(MassUnit)> {
        &self.mass_unit
    }
    pub fn material_designation_holders(&self) -> &HashMap<u64, as_holder!(MaterialDesignation)> {
        &self.material_designation
    }
    pub fn material_designation_characterization_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(MaterialDesignationCharacterization)> {
        &self.material_designation_characterization
    }
    pub fn material_property_holders(&self) -> &HashMap<u64, as_holder!(MaterialProperty)> {
        &self.material_property
    }
    pub fn material_property_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(MaterialPropertyRepresentation)> {
        &self.material_property_representation
    }
    pub fn measure_qualification_holders(&self) -> &HashMap<u64, as_holder!(MeasureQualification)> {
        &self.measure_qualification
    }
    pub fn measure_representation_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(MeasureRepresentationItem)> {
        &self.measure_representation_item
    }
    pub fn measure_with_unit_holders(&self) -> &HashMap<u64, as_holder!(MeasureWithUnit)> {
        &self.measure_with_unit
    }
    pub fn mechanical_context_holders(&self) -> &HashMap<u64, as_holder!(MechanicalContext)> {
        &self.mechanical_context
    }
    pub fn mechanical_design_and_draughting_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(MechanicalDesignAndDraughtingRelationship)> {
        &self.mechanical_design_and_draughting_relationship
    }
    pub fn mechanical_design_geometric_presentation_area_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(MechanicalDesignGeometricPresentationArea)> {
        &self.mechanical_design_geometric_presentation_area
    }
    pub fn mechanical_design_geometric_presentation_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(MechanicalDesignGeometricPresentationRepresentation)> {
        &self.mechanical_design_geometric_presentation_representation
    }
    pub fn mechanical_design_presentation_representation_with_draughting_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(MechanicalDesignPresentationRepresentationWithDraughting)> {
        &self.mechanical_design_presentation_representation_with_draughting
    }
    pub fn mechanical_design_shaded_presentation_area_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(MechanicalDesignShadedPresentationArea)> {
        &self.mechanical_design_shaded_presentation_area
    }
    pub fn mechanical_design_shaded_presentation_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(MechanicalDesignShadedPresentationRepresentation)> {
        &self.mechanical_design_shaded_presentation_representation
    }
    pub fn min_and_major_ply_orientation_basis_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(MinAndMajorPlyOrientationBasis)> {
        &self.min_and_major_ply_orientation_basis
    }
    pub fn modified_geometric_tolerance_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ModifiedGeometricTolerance)> {
        &self.modified_geometric_tolerance
    }
    pub fn modified_solid_holders(&self) -> &HashMap<u64, as_holder!(ModifiedSolid)> {
        &self.modified_solid
    }
    pub fn modified_solid_with_placed_configuration_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ModifiedSolidWithPlacedConfiguration)> {
        &self.modified_solid_with_placed_configuration
    }
    pub fn moments_of_inertia_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(MomentsOfInertiaRepresentation)> {
        &self.moments_of_inertia_representation
    }
    pub fn multi_language_attribute_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(MultiLanguageAttributeAssignment)> {
        &self.multi_language_attribute_assignment
    }
    pub fn multiple_arity_boolean_expression_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(MultipleArityBooleanExpression)> {
        &self.multiple_arity_boolean_expression
    }
    pub fn multiple_arity_generic_expression_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(MultipleArityGenericExpression)> {
        &self.multiple_arity_generic_expression
    }
    pub fn multiple_arity_numeric_expression_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(MultipleArityNumericExpression)> {
        &self.multiple_arity_numeric_expression
    }
    pub fn name_assignment_holders(&self) -> &HashMap<u64, as_holder!(NameAssignment)> {
        &self.name_assignment
    }
    pub fn name_attribute_holders(&self) -> &HashMap<u64, as_holder!(NameAttribute)> {
        &self.name_attribute
    }
    pub fn named_unit_holders(&self) -> &HashMap<u64, as_holder!(NamedUnit)> {
        &self.named_unit
    }
    pub fn next_assembly_usage_occurrence_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(NextAssemblyUsageOccurrence)> {
        &self.next_assembly_usage_occurrence
    }
    pub fn non_manifold_surface_shape_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(NonManifoldSurfaceShapeRepresentation)> {
        &self.non_manifold_surface_shape_representation
    }
    pub fn null_representation_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(NullRepresentationItem)> {
        &self.null_representation_item
    }
    pub fn numeric_expression_holders(&self) -> &HashMap<u64, as_holder!(NumericExpression)> {
        &self.numeric_expression
    }
    pub fn object_role_holders(&self) -> &HashMap<u64, as_holder!(ObjectRole)> {
        &self.object_role
    }
    pub fn offset_curve_2d_holders(&self) -> &HashMap<u64, as_holder!(OffsetCurve2D)> {
        &self.offset_curve_2d
    }
    pub fn offset_curve_3d_holders(&self) -> &HashMap<u64, as_holder!(OffsetCurve3D)> {
        &self.offset_curve_3d
    }
    pub fn offset_surface_holders(&self) -> &HashMap<u64, as_holder!(OffsetSurface)> {
        &self.offset_surface
    }
    pub fn one_direction_repeat_factor_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(OneDirectionRepeatFactor)> {
        &self.one_direction_repeat_factor
    }
    pub fn open_shell_holders(&self) -> &HashMap<u64, as_holder!(OpenShell)> {
        &self.open_shell
    }
    pub fn ordinal_date_holders(&self) -> &HashMap<u64, as_holder!(OrdinalDate)> {
        &self.ordinal_date
    }
    pub fn ordinate_dimension_holders(&self) -> &HashMap<u64, as_holder!(OrdinateDimension)> {
        &self.ordinate_dimension
    }
    pub fn organization_holders(&self) -> &HashMap<u64, as_holder!(Organization)> {
        &self.organization
    }
    pub fn organization_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(OrganizationAssignment)> {
        &self.organization_assignment
    }
    pub fn organization_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(OrganizationRelationship)> {
        &self.organization_relationship
    }
    pub fn organization_role_holders(&self) -> &HashMap<u64, as_holder!(OrganizationRole)> {
        &self.organization_role
    }
    pub fn organizational_address_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(OrganizationalAddress)> {
        &self.organizational_address
    }
    pub fn organizational_project_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(OrganizationalProject)> {
        &self.organizational_project
    }
    pub fn organizational_project_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(OrganizationalProjectAssignment)> {
        &self.organizational_project_assignment
    }
    pub fn organizational_project_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(OrganizationalProjectRelationship)> {
        &self.organizational_project_relationship
    }
    pub fn organizational_project_role_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(OrganizationalProjectRole)> {
        &self.organizational_project_role
    }
    pub fn oriented_closed_shell_holders(&self) -> &HashMap<u64, as_holder!(OrientedClosedShell)> {
        &self.oriented_closed_shell
    }
    pub fn oriented_edge_holders(&self) -> &HashMap<u64, as_holder!(OrientedEdge)> {
        &self.oriented_edge
    }
    pub fn oriented_face_holders(&self) -> &HashMap<u64, as_holder!(OrientedFace)> {
        &self.oriented_face
    }
    pub fn oriented_open_shell_holders(&self) -> &HashMap<u64, as_holder!(OrientedOpenShell)> {
        &self.oriented_open_shell
    }
    pub fn oriented_path_holders(&self) -> &HashMap<u64, as_holder!(OrientedPath)> {
        &self.oriented_path
    }
    pub fn oriented_surface_holders(&self) -> &HashMap<u64, as_holder!(OrientedSurface)> {
        &self.oriented_surface
    }
    pub fn outer_boundary_curve_holders(&self) -> &HashMap<u64, as_holder!(OuterBoundaryCurve)> {
        &self.outer_boundary_curve
    }
    pub fn over_riding_styled_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(OverRidingStyledItem)> {
        &self.over_riding_styled_item
    }
    pub fn package_product_concept_feature_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PackageProductConceptFeature)> {
        &self.package_product_concept_feature
    }
    pub fn parabola_holders(&self) -> &HashMap<u64, as_holder!(Parabola)> {
        &self.parabola
    }
    pub fn parallel_offset_holders(&self) -> &HashMap<u64, as_holder!(ParallelOffset)> {
        &self.parallel_offset
    }
    pub fn parallelism_tolerance_holders(&self) -> &HashMap<u64, as_holder!(ParallelismTolerance)> {
        &self.parallelism_tolerance
    }
    pub fn parametric_representation_context_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ParametricRepresentationContext)> {
        &self.parametric_representation_context
    }
    pub fn part_laminate_table_holders(&self) -> &HashMap<u64, as_holder!(PartLaminateTable)> {
        &self.part_laminate_table
    }
    pub fn partial_document_with_structured_text_representation_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PartialDocumentWithStructuredTextRepresentationAssignment)> {
        &self.partial_document_with_structured_text_representation_assignment
    }
    pub fn path_holders(&self) -> &HashMap<u64, as_holder!(Path)> {
        &self.path
    }
    pub fn pcurve_holders(&self) -> &HashMap<u64, as_holder!(Pcurve)> {
        &self.pcurve
    }
    pub fn percentage_laminate_definition_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PercentageLaminateDefinition)> {
        &self.percentage_laminate_definition
    }
    pub fn percentage_laminate_table_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PercentageLaminateTable)> {
        &self.percentage_laminate_table
    }
    pub fn percentage_ply_definition_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PercentagePlyDefinition)> {
        &self.percentage_ply_definition
    }
    pub fn perpendicular_to_holders(&self) -> &HashMap<u64, as_holder!(PerpendicularTo)> {
        &self.perpendicular_to
    }
    pub fn perpendicularity_tolerance_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PerpendicularityTolerance)> {
        &self.perpendicularity_tolerance
    }
    pub fn person_holders(&self) -> &HashMap<u64, as_holder!(Person)> {
        &self.person
    }
    pub fn person_and_organization_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PersonAndOrganization)> {
        &self.person_and_organization
    }
    pub fn person_and_organization_address_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PersonAndOrganizationAddress)> {
        &self.person_and_organization_address
    }
    pub fn person_and_organization_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PersonAndOrganizationAssignment)> {
        &self.person_and_organization_assignment
    }
    pub fn person_and_organization_role_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PersonAndOrganizationRole)> {
        &self.person_and_organization_role
    }
    pub fn personal_address_holders(&self) -> &HashMap<u64, as_holder!(PersonalAddress)> {
        &self.personal_address
    }
    pub fn physical_breakdown_context_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PhysicalBreakdownContext)> {
        &self.physical_breakdown_context
    }
    pub fn physical_element_usage_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PhysicalElementUsage)> {
        &self.physical_element_usage
    }
    pub fn picture_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PictureRepresentation)> {
        &self.picture_representation
    }
    pub fn picture_representation_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PictureRepresentationItem)> {
        &self.picture_representation_item
    }
    pub fn placed_datum_target_feature_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PlacedDatumTargetFeature)> {
        &self.placed_datum_target_feature
    }
    pub fn placed_feature_holders(&self) -> &HashMap<u64, as_holder!(PlacedFeature)> {
        &self.placed_feature
    }
    pub fn placement_holders(&self) -> &HashMap<u64, as_holder!(Placement)> {
        &self.placement
    }
    pub fn planar_box_holders(&self) -> &HashMap<u64, as_holder!(PlanarBox)> {
        &self.planar_box
    }
    pub fn planar_extent_holders(&self) -> &HashMap<u64, as_holder!(PlanarExtent)> {
        &self.planar_extent
    }
    pub fn plane_holders(&self) -> &HashMap<u64, as_holder!(Plane)> {
        &self.plane
    }
    pub fn plane_angle_measure_with_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PlaneAngleMeasureWithUnit)> {
        &self.plane_angle_measure_with_unit
    }
    pub fn plane_angle_unit_holders(&self) -> &HashMap<u64, as_holder!(PlaneAngleUnit)> {
        &self.plane_angle_unit
    }
    pub fn plus_minus_tolerance_holders(&self) -> &HashMap<u64, as_holder!(PlusMinusTolerance)> {
        &self.plus_minus_tolerance
    }
    pub fn ply_laminate_definition_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PlyLaminateDefinition)> {
        &self.ply_laminate_definition
    }
    pub fn ply_laminate_sequence_definition_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PlyLaminateSequenceDefinition)> {
        &self.ply_laminate_sequence_definition
    }
    pub fn ply_laminate_table_holders(&self) -> &HashMap<u64, as_holder!(PlyLaminateTable)> {
        &self.ply_laminate_table
    }
    pub fn point_holders(&self) -> &HashMap<u64, as_holder!(Point)> {
        &self.point
    }
    pub fn point_and_vector_holders(&self) -> &HashMap<u64, as_holder!(PointAndVector)> {
        &self.point_and_vector
    }
    pub fn point_on_curve_holders(&self) -> &HashMap<u64, as_holder!(PointOnCurve)> {
        &self.point_on_curve
    }
    pub fn point_on_surface_holders(&self) -> &HashMap<u64, as_holder!(PointOnSurface)> {
        &self.point_on_surface
    }
    pub fn point_path_holders(&self) -> &HashMap<u64, as_holder!(PointPath)> {
        &self.point_path
    }
    pub fn point_replica_holders(&self) -> &HashMap<u64, as_holder!(PointReplica)> {
        &self.point_replica
    }
    pub fn point_style_holders(&self) -> &HashMap<u64, as_holder!(PointStyle)> {
        &self.point_style
    }
    pub fn polar_complex_number_literal_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PolarComplexNumberLiteral)> {
        &self.polar_complex_number_literal
    }
    pub fn poly_loop_holders(&self) -> &HashMap<u64, as_holder!(PolyLoop)> {
        &self.poly_loop
    }
    pub fn polyline_holders(&self) -> &HashMap<u64, as_holder!(Polyline)> {
        &self.polyline
    }
    pub fn position_tolerance_holders(&self) -> &HashMap<u64, as_holder!(PositionTolerance)> {
        &self.position_tolerance
    }
    pub fn positioned_sketch_holders(&self) -> &HashMap<u64, as_holder!(PositionedSketch)> {
        &self.positioned_sketch
    }
    pub fn power_measure_with_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PowerMeasureWithUnit)> {
        &self.power_measure_with_unit
    }
    pub fn power_unit_holders(&self) -> &HashMap<u64, as_holder!(PowerUnit)> {
        &self.power_unit
    }
    pub fn pre_defined_colour_holders(&self) -> &HashMap<u64, as_holder!(PreDefinedColour)> {
        &self.pre_defined_colour
    }
    pub fn pre_defined_curve_font_holders(&self) -> &HashMap<u64, as_holder!(PreDefinedCurveFont)> {
        &self.pre_defined_curve_font
    }
    pub fn pre_defined_dimension_symbol_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PreDefinedDimensionSymbol)> {
        &self.pre_defined_dimension_symbol
    }
    pub fn pre_defined_geometrical_tolerance_symbol_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PreDefinedGeometricalToleranceSymbol)> {
        &self.pre_defined_geometrical_tolerance_symbol
    }
    pub fn pre_defined_item_holders(&self) -> &HashMap<u64, as_holder!(PreDefinedItem)> {
        &self.pre_defined_item
    }
    pub fn pre_defined_marker_holders(&self) -> &HashMap<u64, as_holder!(PreDefinedMarker)> {
        &self.pre_defined_marker
    }
    pub fn pre_defined_point_marker_symbol_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PreDefinedPointMarkerSymbol)> {
        &self.pre_defined_point_marker_symbol
    }
    pub fn pre_defined_surface_condition_symbol_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PreDefinedSurfaceConditionSymbol)> {
        &self.pre_defined_surface_condition_symbol
    }
    pub fn pre_defined_surface_side_style_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PreDefinedSurfaceSideStyle)> {
        &self.pre_defined_surface_side_style
    }
    pub fn pre_defined_symbol_holders(&self) -> &HashMap<u64, as_holder!(PreDefinedSymbol)> {
        &self.pre_defined_symbol
    }
    pub fn pre_defined_terminator_symbol_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PreDefinedTerminatorSymbol)> {
        &self.pre_defined_terminator_symbol
    }
    pub fn pre_defined_text_font_holders(&self) -> &HashMap<u64, as_holder!(PreDefinedTextFont)> {
        &self.pre_defined_text_font
    }
    pub fn pre_defined_tile_holders(&self) -> &HashMap<u64, as_holder!(PreDefinedTile)> {
        &self.pre_defined_tile
    }
    pub fn precision_qualifier_holders(&self) -> &HashMap<u64, as_holder!(PrecisionQualifier)> {
        &self.precision_qualifier
    }
    pub fn predefined_picture_representation_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PredefinedPictureRepresentationItem)> {
        &self.predefined_picture_representation_item
    }
    pub fn presentation_area_holders(&self) -> &HashMap<u64, as_holder!(PresentationArea)> {
        &self.presentation_area
    }
    pub fn presentation_layer_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PresentationLayerAssignment)> {
        &self.presentation_layer_assignment
    }
    pub fn presentation_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PresentationRepresentation)> {
        &self.presentation_representation
    }
    pub fn presentation_set_holders(&self) -> &HashMap<u64, as_holder!(PresentationSet)> {
        &self.presentation_set
    }
    pub fn presentation_size_holders(&self) -> &HashMap<u64, as_holder!(PresentationSize)> {
        &self.presentation_size
    }
    pub fn presentation_style_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PresentationStyleAssignment)> {
        &self.presentation_style_assignment
    }
    pub fn presentation_style_by_context_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PresentationStyleByContext)> {
        &self.presentation_style_by_context
    }
    pub fn presentation_view_holders(&self) -> &HashMap<u64, as_holder!(PresentationView)> {
        &self.presentation_view
    }
    pub fn presented_item_holders(&self) -> &HashMap<u64, as_holder!(PresentedItem)> {
        &self.presented_item
    }
    pub fn presented_item_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PresentedItemRepresentation)> {
        &self.presented_item_representation
    }
    pub fn pressure_measure_with_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PressureMeasureWithUnit)> {
        &self.pressure_measure_with_unit
    }
    pub fn pressure_unit_holders(&self) -> &HashMap<u64, as_holder!(PressureUnit)> {
        &self.pressure_unit
    }
    pub fn procedural_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ProceduralRepresentation)> {
        &self.procedural_representation
    }
    pub fn procedural_representation_sequence_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ProceduralRepresentationSequence)> {
        &self.procedural_representation_sequence
    }
    pub fn procedural_shape_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ProceduralShapeRepresentation)> {
        &self.procedural_shape_representation
    }
    pub fn procedural_shape_representation_sequence_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ProceduralShapeRepresentationSequence)> {
        &self.procedural_shape_representation_sequence
    }
    pub fn product_holders(&self) -> &HashMap<u64, as_holder!(Product)> {
        &self.product
    }
    pub fn product_category_holders(&self) -> &HashMap<u64, as_holder!(ProductCategory)> {
        &self.product_category
    }
    pub fn product_class_holders(&self) -> &HashMap<u64, as_holder!(ProductClass)> {
        &self.product_class
    }
    pub fn product_concept_holders(&self) -> &HashMap<u64, as_holder!(ProductConcept)> {
        &self.product_concept
    }
    pub fn product_concept_context_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ProductConceptContext)> {
        &self.product_concept_context
    }
    pub fn product_concept_feature_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ProductConceptFeature)> {
        &self.product_concept_feature
    }
    pub fn product_concept_feature_association_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ProductConceptFeatureAssociation)> {
        &self.product_concept_feature_association
    }
    pub fn product_concept_feature_category_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ProductConceptFeatureCategory)> {
        &self.product_concept_feature_category
    }
    pub fn product_concept_feature_category_usage_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ProductConceptFeatureCategoryUsage)> {
        &self.product_concept_feature_category_usage
    }
    pub fn product_concept_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ProductConceptRelationship)> {
        &self.product_concept_relationship
    }
    pub fn product_context_holders(&self) -> &HashMap<u64, as_holder!(ProductContext)> {
        &self.product_context
    }
    pub fn product_definition_holders(&self) -> &HashMap<u64, as_holder!(ProductDefinition)> {
        &self.product_definition
    }
    pub fn product_definition_context_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ProductDefinitionContext)> {
        &self.product_definition_context
    }
    pub fn product_definition_context_association_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ProductDefinitionContextAssociation)> {
        &self.product_definition_context_association
    }
    pub fn product_definition_context_role_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ProductDefinitionContextRole)> {
        &self.product_definition_context_role
    }
    pub fn product_definition_effectivity_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ProductDefinitionEffectivity)> {
        &self.product_definition_effectivity
    }
    pub fn product_definition_element_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ProductDefinitionElementRelationship)> {
        &self.product_definition_element_relationship
    }
    pub fn product_definition_formation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ProductDefinitionFormation)> {
        &self.product_definition_formation
    }
    pub fn product_definition_formation_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ProductDefinitionFormationRelationship)> {
        &self.product_definition_formation_relationship
    }
    pub fn product_definition_formation_with_specified_source_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ProductDefinitionFormationWithSpecifiedSource)> {
        &self.product_definition_formation_with_specified_source
    }
    pub fn product_definition_group_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ProductDefinitionGroupAssignment)> {
        &self.product_definition_group_assignment
    }
    pub fn product_definition_occurrence_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ProductDefinitionOccurrenceRelationship)> {
        &self.product_definition_occurrence_relationship
    }
    pub fn product_definition_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ProductDefinitionRelationship)> {
        &self.product_definition_relationship
    }
    pub fn product_definition_shape_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ProductDefinitionShape)> {
        &self.product_definition_shape
    }
    pub fn product_definition_substitute_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ProductDefinitionSubstitute)> {
        &self.product_definition_substitute
    }
    pub fn product_definition_usage_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ProductDefinitionUsage)> {
        &self.product_definition_usage
    }
    pub fn product_definition_with_associated_documents_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ProductDefinitionWithAssociatedDocuments)> {
        &self.product_definition_with_associated_documents
    }
    pub fn product_identification_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ProductIdentification)> {
        &self.product_identification
    }
    pub fn product_material_composition_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ProductMaterialCompositionRelationship)> {
        &self.product_material_composition_relationship
    }
    pub fn product_related_product_category_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ProductRelatedProductCategory)> {
        &self.product_related_product_category
    }
    pub fn product_specification_holders(&self) -> &HashMap<u64, as_holder!(ProductSpecification)> {
        &self.product_specification
    }
    pub fn projected_zone_definition_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ProjectedZoneDefinition)> {
        &self.projected_zone_definition
    }
    pub fn projection_curve_holders(&self) -> &HashMap<u64, as_holder!(ProjectionCurve)> {
        &self.projection_curve
    }
    pub fn projection_directed_callout_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ProjectionDirectedCallout)> {
        &self.projection_directed_callout
    }
    pub fn promissory_usage_occurrence_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PromissoryUsageOccurrence)> {
        &self.promissory_usage_occurrence
    }
    pub fn property_definition_holders(&self) -> &HashMap<u64, as_holder!(PropertyDefinition)> {
        &self.property_definition
    }
    pub fn property_definition_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PropertyDefinitionRelationship)> {
        &self.property_definition_relationship
    }
    pub fn property_definition_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PropertyDefinitionRepresentation)> {
        &self.property_definition_representation
    }
    pub fn qualified_representation_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(QualifiedRepresentationItem)> {
        &self.qualified_representation_item
    }
    pub fn qualitative_uncertainty_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(QualitativeUncertainty)> {
        &self.qualitative_uncertainty
    }
    pub fn quantified_assembly_component_usage_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(QuantifiedAssemblyComponentUsage)> {
        &self.quantified_assembly_component_usage
    }
    pub fn quasi_uniform_curve_holders(&self) -> &HashMap<u64, as_holder!(QuasiUniformCurve)> {
        &self.quasi_uniform_curve
    }
    pub fn quasi_uniform_surface_holders(&self) -> &HashMap<u64, as_holder!(QuasiUniformSurface)> {
        &self.quasi_uniform_surface
    }
    pub fn radioactivity_measure_with_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(RadioactivityMeasureWithUnit)> {
        &self.radioactivity_measure_with_unit
    }
    pub fn radioactivity_unit_holders(&self) -> &HashMap<u64, as_holder!(RadioactivityUnit)> {
        &self.radioactivity_unit
    }
    pub fn radius_dimension_holders(&self) -> &HashMap<u64, as_holder!(RadiusDimension)> {
        &self.radius_dimension
    }
    pub fn range_characteristic_holders(&self) -> &HashMap<u64, as_holder!(RangeCharacteristic)> {
        &self.range_characteristic
    }
    pub fn ratio_measure_with_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(RatioMeasureWithUnit)> {
        &self.ratio_measure_with_unit
    }
    pub fn ratio_unit_holders(&self) -> &HashMap<u64, as_holder!(RatioUnit)> {
        &self.ratio_unit
    }
    pub fn rational_b_spline_curve_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(RationalBSplineCurve)> {
        &self.rational_b_spline_curve
    }
    pub fn rational_b_spline_surface_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(RationalBSplineSurface)> {
        &self.rational_b_spline_surface
    }
    pub fn rational_representation_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(RationalRepresentationItem)> {
        &self.rational_representation_item
    }
    pub fn real_literal_holders(&self) -> &HashMap<u64, as_holder!(RealLiteral)> {
        &self.real_literal
    }
    pub fn real_representation_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(RealRepresentationItem)> {
        &self.real_representation_item
    }
    pub fn rectangular_composite_surface_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(RectangularCompositeSurface)> {
        &self.rectangular_composite_surface
    }
    pub fn rectangular_trimmed_surface_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(RectangularTrimmedSurface)> {
        &self.rectangular_trimmed_surface
    }
    pub fn referenced_modified_datum_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ReferencedModifiedDatum)> {
        &self.referenced_modified_datum
    }
    pub fn relative_event_occurrence_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(RelativeEventOccurrence)> {
        &self.relative_event_occurrence
    }
    pub fn rep_item_group_holders(&self) -> &HashMap<u64, as_holder!(RepItemGroup)> {
        &self.rep_item_group
    }
    pub fn reparametrised_composite_curve_segment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ReparametrisedCompositeCurveSegment)> {
        &self.reparametrised_composite_curve_segment
    }
    pub fn representation_holders(&self) -> &HashMap<u64, as_holder!(Representation)> {
        &self.representation
    }
    pub fn representation_context_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(RepresentationContext)> {
        &self.representation_context
    }
    pub fn representation_item_holders(&self) -> &HashMap<u64, as_holder!(RepresentationItem)> {
        &self.representation_item
    }
    pub fn representation_item_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(RepresentationItemRelationship)> {
        &self.representation_item_relationship
    }
    pub fn representation_map_holders(&self) -> &HashMap<u64, as_holder!(RepresentationMap)> {
        &self.representation_map
    }
    pub fn representation_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(RepresentationRelationship)> {
        &self.representation_relationship
    }
    pub fn representation_relationship_with_transformation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(RepresentationRelationshipWithTransformation)> {
        &self.representation_relationship_with_transformation
    }
    pub fn requirement_assigned_object_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(RequirementAssignedObject)> {
        &self.requirement_assigned_object
    }
    pub fn requirement_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(RequirementAssignment)> {
        &self.requirement_assignment
    }
    pub fn requirement_source_holders(&self) -> &HashMap<u64, as_holder!(RequirementSource)> {
        &self.requirement_source
    }
    pub fn requirement_view_definition_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(RequirementViewDefinitionRelationship)> {
        &self.requirement_view_definition_relationship
    }
    pub fn resistance_measure_with_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ResistanceMeasureWithUnit)> {
        &self.resistance_measure_with_unit
    }
    pub fn resistance_unit_holders(&self) -> &HashMap<u64, as_holder!(ResistanceUnit)> {
        &self.resistance_unit
    }
    pub fn revolved_area_solid_holders(&self) -> &HashMap<u64, as_holder!(RevolvedAreaSolid)> {
        &self.revolved_area_solid
    }
    pub fn revolved_face_solid_holders(&self) -> &HashMap<u64, as_holder!(RevolvedFaceSolid)> {
        &self.revolved_face_solid
    }
    pub fn revolved_face_solid_with_trim_conditions_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(RevolvedFaceSolidWithTrimConditions)> {
        &self.revolved_face_solid_with_trim_conditions
    }
    pub fn right_angular_wedge_holders(&self) -> &HashMap<u64, as_holder!(RightAngularWedge)> {
        &self.right_angular_wedge
    }
    pub fn right_circular_cone_holders(&self) -> &HashMap<u64, as_holder!(RightCircularCone)> {
        &self.right_circular_cone
    }
    pub fn right_circular_cylinder_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(RightCircularCylinder)> {
        &self.right_circular_cylinder
    }
    pub fn right_to_usage_association_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(RightToUsageAssociation)> {
        &self.right_to_usage_association
    }
    pub fn role_association_holders(&self) -> &HashMap<u64, as_holder!(RoleAssociation)> {
        &self.role_association
    }
    pub fn roundness_tolerance_holders(&self) -> &HashMap<u64, as_holder!(RoundnessTolerance)> {
        &self.roundness_tolerance
    }
    pub fn row_representation_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(RowRepresentationItem)> {
        &self.row_representation_item
    }
    pub fn row_value_holders(&self) -> &HashMap<u64, as_holder!(RowValue)> {
        &self.row_value
    }
    pub fn row_variable_holders(&self) -> &HashMap<u64, as_holder!(RowVariable)> {
        &self.row_variable
    }
    pub fn rule_action_holders(&self) -> &HashMap<u64, as_holder!(RuleAction)> {
        &self.rule_action
    }
    pub fn rule_condition_holders(&self) -> &HashMap<u64, as_holder!(RuleCondition)> {
        &self.rule_condition
    }
    pub fn rule_definition_holders(&self) -> &HashMap<u64, as_holder!(RuleDefinition)> {
        &self.rule_definition
    }
    pub fn rule_set_holders(&self) -> &HashMap<u64, as_holder!(RuleSet)> {
        &self.rule_set
    }
    pub fn rule_set_group_holders(&self) -> &HashMap<u64, as_holder!(RuleSetGroup)> {
        &self.rule_set_group
    }
    pub fn rule_software_definition_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(RuleSoftwareDefinition)> {
        &self.rule_software_definition
    }
    pub fn rule_superseded_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(RuleSupersededAssignment)> {
        &self.rule_superseded_assignment
    }
    pub fn rule_supersedence_holders(&self) -> &HashMap<u64, as_holder!(RuleSupersedence)> {
        &self.rule_supersedence
    }
    pub fn ruled_surface_swept_area_solid_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(RuledSurfaceSweptAreaSolid)> {
        &self.ruled_surface_swept_area_solid
    }
    pub fn runout_zone_definition_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(RunoutZoneDefinition)> {
        &self.runout_zone_definition
    }
    pub fn runout_zone_orientation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(RunoutZoneOrientation)> {
        &self.runout_zone_orientation
    }
    pub fn runout_zone_orientation_reference_direction_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(RunoutZoneOrientationReferenceDirection)> {
        &self.runout_zone_orientation_reference_direction
    }
    pub fn satisfied_requirement_holders(&self) -> &HashMap<u64, as_holder!(SatisfiedRequirement)> {
        &self.satisfied_requirement
    }
    pub fn satisfies_requirement_holders(&self) -> &HashMap<u64, as_holder!(SatisfiesRequirement)> {
        &self.satisfies_requirement
    }
    pub fn satisfying_item_holders(&self) -> &HashMap<u64, as_holder!(SatisfyingItem)> {
        &self.satisfying_item
    }
    pub fn scalar_variable_holders(&self) -> &HashMap<u64, as_holder!(ScalarVariable)> {
        &self.scalar_variable
    }
    pub fn scattering_parameter_holders(&self) -> &HashMap<u64, as_holder!(ScatteringParameter)> {
        &self.scattering_parameter
    }
    pub fn sculptured_solid_holders(&self) -> &HashMap<u64, as_holder!(SculpturedSolid)> {
        &self.sculptured_solid
    }
    pub fn seam_curve_holders(&self) -> &HashMap<u64, as_holder!(SeamCurve)> {
        &self.seam_curve
    }
    pub fn security_classification_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SecurityClassification)> {
        &self.security_classification
    }
    pub fn security_classification_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SecurityClassificationAssignment)> {
        &self.security_classification_assignment
    }
    pub fn security_classification_level_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SecurityClassificationLevel)> {
        &self.security_classification_level
    }
    pub fn serial_numbered_effectivity_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SerialNumberedEffectivity)> {
        &self.serial_numbered_effectivity
    }
    pub fn shape_aspect_holders(&self) -> &HashMap<u64, as_holder!(ShapeAspect)> {
        &self.shape_aspect
    }
    pub fn shape_aspect_associativity_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ShapeAspectAssociativity)> {
        &self.shape_aspect_associativity
    }
    pub fn shape_aspect_deriving_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ShapeAspectDerivingRelationship)> {
        &self.shape_aspect_deriving_relationship
    }
    pub fn shape_aspect_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ShapeAspectRelationship)> {
        &self.shape_aspect_relationship
    }
    pub fn shape_definition_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ShapeDefinitionRepresentation)> {
        &self.shape_definition_representation
    }
    pub fn shape_dimension_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ShapeDimensionRepresentation)> {
        &self.shape_dimension_representation
    }
    pub fn shape_feature_definition_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ShapeFeatureDefinition)> {
        &self.shape_feature_definition
    }
    pub fn shape_representation_holders(&self) -> &HashMap<u64, as_holder!(ShapeRepresentation)> {
        &self.shape_representation
    }
    pub fn shape_representation_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ShapeRepresentationRelationship)> {
        &self.shape_representation_relationship
    }
    pub fn shape_representation_with_parameters_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ShapeRepresentationWithParameters)> {
        &self.shape_representation_with_parameters
    }
    pub fn shell_based_surface_model_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ShellBasedSurfaceModel)> {
        &self.shell_based_surface_model
    }
    pub fn shell_based_wireframe_model_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ShellBasedWireframeModel)> {
        &self.shell_based_wireframe_model
    }
    pub fn shell_based_wireframe_shape_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ShellBasedWireframeShapeRepresentation)> {
        &self.shell_based_wireframe_shape_representation
    }
    pub fn shelled_solid_holders(&self) -> &HashMap<u64, as_holder!(ShelledSolid)> {
        &self.shelled_solid
    }
    pub fn si_absorbed_dose_unit_holders(&self) -> &HashMap<u64, as_holder!(SiAbsorbedDoseUnit)> {
        &self.si_absorbed_dose_unit
    }
    pub fn si_capacitance_unit_holders(&self) -> &HashMap<u64, as_holder!(SiCapacitanceUnit)> {
        &self.si_capacitance_unit
    }
    pub fn si_conductance_unit_holders(&self) -> &HashMap<u64, as_holder!(SiConductanceUnit)> {
        &self.si_conductance_unit
    }
    pub fn si_dose_equivalent_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SiDoseEquivalentUnit)> {
        &self.si_dose_equivalent_unit
    }
    pub fn si_electric_charge_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SiElectricChargeUnit)> {
        &self.si_electric_charge_unit
    }
    pub fn si_electric_potential_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SiElectricPotentialUnit)> {
        &self.si_electric_potential_unit
    }
    pub fn si_energy_unit_holders(&self) -> &HashMap<u64, as_holder!(SiEnergyUnit)> {
        &self.si_energy_unit
    }
    pub fn si_force_unit_holders(&self) -> &HashMap<u64, as_holder!(SiForceUnit)> {
        &self.si_force_unit
    }
    pub fn si_frequency_unit_holders(&self) -> &HashMap<u64, as_holder!(SiFrequencyUnit)> {
        &self.si_frequency_unit
    }
    pub fn si_illuminance_unit_holders(&self) -> &HashMap<u64, as_holder!(SiIlluminanceUnit)> {
        &self.si_illuminance_unit
    }
    pub fn si_inductance_unit_holders(&self) -> &HashMap<u64, as_holder!(SiInductanceUnit)> {
        &self.si_inductance_unit
    }
    pub fn si_magnetic_flux_density_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SiMagneticFluxDensityUnit)> {
        &self.si_magnetic_flux_density_unit
    }
    pub fn si_magnetic_flux_unit_holders(&self) -> &HashMap<u64, as_holder!(SiMagneticFluxUnit)> {
        &self.si_magnetic_flux_unit
    }
    pub fn si_power_unit_holders(&self) -> &HashMap<u64, as_holder!(SiPowerUnit)> {
        &self.si_power_unit
    }
    pub fn si_pressure_unit_holders(&self) -> &HashMap<u64, as_holder!(SiPressureUnit)> {
        &self.si_pressure_unit
    }
    pub fn si_radioactivity_unit_holders(&self) -> &HashMap<u64, as_holder!(SiRadioactivityUnit)> {
        &self.si_radioactivity_unit
    }
    pub fn si_resistance_unit_holders(&self) -> &HashMap<u64, as_holder!(SiResistanceUnit)> {
        &self.si_resistance_unit
    }
    pub fn si_unit_holders(&self) -> &HashMap<u64, as_holder!(SiUnit)> {
        &self.si_unit
    }
    pub fn simple_boolean_expression_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SimpleBooleanExpression)> {
        &self.simple_boolean_expression
    }
    pub fn simple_clause_holders(&self) -> &HashMap<u64, as_holder!(SimpleClause)> {
        &self.simple_clause
    }
    pub fn simple_generic_expression_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SimpleGenericExpression)> {
        &self.simple_generic_expression
    }
    pub fn simple_numeric_expression_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SimpleNumericExpression)> {
        &self.simple_numeric_expression
    }
    pub fn slash_expression_holders(&self) -> &HashMap<u64, as_holder!(SlashExpression)> {
        &self.slash_expression
    }
    pub fn smeared_material_definition_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SmearedMaterialDefinition)> {
        &self.smeared_material_definition
    }
    pub fn solid_angle_measure_with_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SolidAngleMeasureWithUnit)> {
        &self.solid_angle_measure_with_unit
    }
    pub fn solid_angle_unit_holders(&self) -> &HashMap<u64, as_holder!(SolidAngleUnit)> {
        &self.solid_angle_unit
    }
    pub fn solid_curve_font_holders(&self) -> &HashMap<u64, as_holder!(SolidCurveFont)> {
        &self.solid_curve_font
    }
    pub fn solid_model_holders(&self) -> &HashMap<u64, as_holder!(SolidModel)> {
        &self.solid_model
    }
    pub fn solid_replica_holders(&self) -> &HashMap<u64, as_holder!(SolidReplica)> {
        &self.solid_replica
    }
    pub fn solid_with_angle_based_chamfer_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SolidWithAngleBasedChamfer)> {
        &self.solid_with_angle_based_chamfer
    }
    pub fn solid_with_chamfered_edges_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SolidWithChamferedEdges)> {
        &self.solid_with_chamfered_edges
    }
    pub fn solid_with_circular_pattern_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SolidWithCircularPattern)> {
        &self.solid_with_circular_pattern
    }
    pub fn solid_with_circular_pocket_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SolidWithCircularPocket)> {
        &self.solid_with_circular_pocket
    }
    pub fn solid_with_circular_protrusion_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SolidWithCircularProtrusion)> {
        &self.solid_with_circular_protrusion
    }
    pub fn solid_with_conical_bottom_round_hole_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SolidWithConicalBottomRoundHole)> {
        &self.solid_with_conical_bottom_round_hole
    }
    pub fn solid_with_constant_radius_edge_blend_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SolidWithConstantRadiusEdgeBlend)> {
        &self.solid_with_constant_radius_edge_blend
    }
    pub fn solid_with_curved_slot_holders(&self) -> &HashMap<u64, as_holder!(SolidWithCurvedSlot)> {
        &self.solid_with_curved_slot
    }
    pub fn solid_with_depression_holders(&self) -> &HashMap<u64, as_holder!(SolidWithDepression)> {
        &self.solid_with_depression
    }
    pub fn solid_with_double_offset_chamfer_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SolidWithDoubleOffsetChamfer)> {
        &self.solid_with_double_offset_chamfer
    }
    pub fn solid_with_flat_bottom_round_hole_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SolidWithFlatBottomRoundHole)> {
        &self.solid_with_flat_bottom_round_hole
    }
    pub fn solid_with_general_pocket_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SolidWithGeneralPocket)> {
        &self.solid_with_general_pocket
    }
    pub fn solid_with_general_protrusion_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SolidWithGeneralProtrusion)> {
        &self.solid_with_general_protrusion
    }
    pub fn solid_with_groove_holders(&self) -> &HashMap<u64, as_holder!(SolidWithGroove)> {
        &self.solid_with_groove
    }
    pub fn solid_with_hole_holders(&self) -> &HashMap<u64, as_holder!(SolidWithHole)> {
        &self.solid_with_hole
    }
    pub fn solid_with_incomplete_circular_pattern_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SolidWithIncompleteCircularPattern)> {
        &self.solid_with_incomplete_circular_pattern
    }
    pub fn solid_with_incomplete_rectangular_pattern_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SolidWithIncompleteRectangularPattern)> {
        &self.solid_with_incomplete_rectangular_pattern
    }
    pub fn solid_with_pocket_holders(&self) -> &HashMap<u64, as_holder!(SolidWithPocket)> {
        &self.solid_with_pocket
    }
    pub fn solid_with_protrusion_holders(&self) -> &HashMap<u64, as_holder!(SolidWithProtrusion)> {
        &self.solid_with_protrusion
    }
    pub fn solid_with_rectangular_pattern_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SolidWithRectangularPattern)> {
        &self.solid_with_rectangular_pattern
    }
    pub fn solid_with_rectangular_pocket_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SolidWithRectangularPocket)> {
        &self.solid_with_rectangular_pocket
    }
    pub fn solid_with_rectangular_protrusion_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SolidWithRectangularProtrusion)> {
        &self.solid_with_rectangular_protrusion
    }
    pub fn solid_with_shape_element_pattern_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SolidWithShapeElementPattern)> {
        &self.solid_with_shape_element_pattern
    }
    pub fn solid_with_single_offset_chamfer_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SolidWithSingleOffsetChamfer)> {
        &self.solid_with_single_offset_chamfer
    }
    pub fn solid_with_slot_holders(&self) -> &HashMap<u64, as_holder!(SolidWithSlot)> {
        &self.solid_with_slot
    }
    pub fn solid_with_spherical_bottom_round_hole_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SolidWithSphericalBottomRoundHole)> {
        &self.solid_with_spherical_bottom_round_hole
    }
    pub fn solid_with_stepped_round_hole_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SolidWithSteppedRoundHole)> {
        &self.solid_with_stepped_round_hole
    }
    pub fn solid_with_stepped_round_hole_and_conical_transitions_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SolidWithSteppedRoundHoleAndConicalTransitions)> {
        &self.solid_with_stepped_round_hole_and_conical_transitions
    }
    pub fn solid_with_straight_slot_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SolidWithStraightSlot)> {
        &self.solid_with_straight_slot
    }
    pub fn solid_with_tee_section_slot_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SolidWithTeeSectionSlot)> {
        &self.solid_with_tee_section_slot
    }
    pub fn solid_with_through_depression_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SolidWithThroughDepression)> {
        &self.solid_with_through_depression
    }
    pub fn solid_with_trapezoidal_section_slot_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SolidWithTrapezoidalSectionSlot)> {
        &self.solid_with_trapezoidal_section_slot
    }
    pub fn solid_with_variable_radius_edge_blend_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SolidWithVariableRadiusEdgeBlend)> {
        &self.solid_with_variable_radius_edge_blend
    }
    pub fn source_for_requirement_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SourceForRequirement)> {
        &self.source_for_requirement
    }
    pub fn sourced_requirement_holders(&self) -> &HashMap<u64, as_holder!(SourcedRequirement)> {
        &self.sourced_requirement
    }
    pub fn specification_definition_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SpecificationDefinition)> {
        &self.specification_definition
    }
    pub fn specified_higher_usage_occurrence_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SpecifiedHigherUsageOccurrence)> {
        &self.specified_higher_usage_occurrence
    }
    pub fn sphere_holders(&self) -> &HashMap<u64, as_holder!(Sphere)> {
        &self.sphere
    }
    pub fn spherical_surface_holders(&self) -> &HashMap<u64, as_holder!(SphericalSurface)> {
        &self.spherical_surface
    }
    pub fn standard_uncertainty_holders(&self) -> &HashMap<u64, as_holder!(StandardUncertainty)> {
        &self.standard_uncertainty
    }
    pub fn start_request_holders(&self) -> &HashMap<u64, as_holder!(StartRequest)> {
        &self.start_request
    }
    pub fn start_work_holders(&self) -> &HashMap<u64, as_holder!(StartWork)> {
        &self.start_work
    }
    pub fn straightness_tolerance_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(StraightnessTolerance)> {
        &self.straightness_tolerance
    }
    pub fn structured_dimension_callout_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(StructuredDimensionCallout)> {
        &self.structured_dimension_callout
    }
    pub fn structured_text_composition_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(StructuredTextComposition)> {
        &self.structured_text_composition
    }
    pub fn structured_text_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(StructuredTextRepresentation)> {
        &self.structured_text_representation
    }
    pub fn styled_item_holders(&self) -> &HashMap<u64, as_holder!(StyledItem)> {
        &self.styled_item
    }
    pub fn subedge_holders(&self) -> &HashMap<u64, as_holder!(Subedge)> {
        &self.subedge
    }
    pub fn subface_holders(&self) -> &HashMap<u64, as_holder!(Subface)> {
        &self.subface
    }
    pub fn supplied_part_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SuppliedPartRelationship)> {
        &self.supplied_part_relationship
    }
    pub fn surface_holders(&self) -> &HashMap<u64, as_holder!(Surface)> {
        &self.surface
    }
    pub fn surface_condition_callout_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SurfaceConditionCallout)> {
        &self.surface_condition_callout
    }
    pub fn surface_curve_holders(&self) -> &HashMap<u64, as_holder!(SurfaceCurve)> {
        &self.surface_curve
    }
    pub fn surface_curve_swept_area_solid_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SurfaceCurveSweptAreaSolid)> {
        &self.surface_curve_swept_area_solid
    }
    pub fn surface_of_linear_extrusion_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SurfaceOfLinearExtrusion)> {
        &self.surface_of_linear_extrusion
    }
    pub fn surface_of_revolution_holders(&self) -> &HashMap<u64, as_holder!(SurfaceOfRevolution)> {
        &self.surface_of_revolution
    }
    pub fn surface_patch_holders(&self) -> &HashMap<u64, as_holder!(SurfacePatch)> {
        &self.surface_patch
    }
    pub fn surface_profile_tolerance_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SurfaceProfileTolerance)> {
        &self.surface_profile_tolerance
    }
    pub fn surface_rendering_properties_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SurfaceRenderingProperties)> {
        &self.surface_rendering_properties
    }
    pub fn surface_replica_holders(&self) -> &HashMap<u64, as_holder!(SurfaceReplica)> {
        &self.surface_replica
    }
    pub fn surface_side_style_holders(&self) -> &HashMap<u64, as_holder!(SurfaceSideStyle)> {
        &self.surface_side_style
    }
    pub fn surface_style_boundary_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SurfaceStyleBoundary)> {
        &self.surface_style_boundary
    }
    pub fn surface_style_control_grid_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SurfaceStyleControlGrid)> {
        &self.surface_style_control_grid
    }
    pub fn surface_style_fill_area_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SurfaceStyleFillArea)> {
        &self.surface_style_fill_area
    }
    pub fn surface_style_parameter_line_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SurfaceStyleParameterLine)> {
        &self.surface_style_parameter_line
    }
    pub fn surface_style_reflectance_ambient_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SurfaceStyleReflectanceAmbient)> {
        &self.surface_style_reflectance_ambient
    }
    pub fn surface_style_reflectance_ambient_diffuse_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SurfaceStyleReflectanceAmbientDiffuse)> {
        &self.surface_style_reflectance_ambient_diffuse
    }
    pub fn surface_style_reflectance_ambient_diffuse_specular_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SurfaceStyleReflectanceAmbientDiffuseSpecular)> {
        &self.surface_style_reflectance_ambient_diffuse_specular
    }
    pub fn surface_style_rendering_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SurfaceStyleRendering)> {
        &self.surface_style_rendering
    }
    pub fn surface_style_rendering_with_properties_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SurfaceStyleRenderingWithProperties)> {
        &self.surface_style_rendering_with_properties
    }
    pub fn surface_style_segmentation_curve_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SurfaceStyleSegmentationCurve)> {
        &self.surface_style_segmentation_curve
    }
    pub fn surface_style_silhouette_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SurfaceStyleSilhouette)> {
        &self.surface_style_silhouette
    }
    pub fn surface_style_transparent_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SurfaceStyleTransparent)> {
        &self.surface_style_transparent
    }
    pub fn surface_style_usage_holders(&self) -> &HashMap<u64, as_holder!(SurfaceStyleUsage)> {
        &self.surface_style_usage
    }
    pub fn surface_texture_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SurfaceTextureRepresentation)> {
        &self.surface_texture_representation
    }
    pub fn surfaced_open_shell_holders(&self) -> &HashMap<u64, as_holder!(SurfacedOpenShell)> {
        &self.surfaced_open_shell
    }
    pub fn swept_area_solid_holders(&self) -> &HashMap<u64, as_holder!(SweptAreaSolid)> {
        &self.swept_area_solid
    }
    pub fn swept_disk_solid_holders(&self) -> &HashMap<u64, as_holder!(SweptDiskSolid)> {
        &self.swept_disk_solid
    }
    pub fn swept_face_solid_holders(&self) -> &HashMap<u64, as_holder!(SweptFaceSolid)> {
        &self.swept_face_solid
    }
    pub fn swept_surface_holders(&self) -> &HashMap<u64, as_holder!(SweptSurface)> {
        &self.swept_surface
    }
    pub fn symbol_holders(&self) -> &HashMap<u64, as_holder!(Symbol)> {
        &self.symbol
    }
    pub fn symbol_colour_holders(&self) -> &HashMap<u64, as_holder!(SymbolColour)> {
        &self.symbol_colour
    }
    pub fn symbol_representation_holders(&self) -> &HashMap<u64, as_holder!(SymbolRepresentation)> {
        &self.symbol_representation
    }
    pub fn symbol_representation_map_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SymbolRepresentationMap)> {
        &self.symbol_representation_map
    }
    pub fn symbol_style_holders(&self) -> &HashMap<u64, as_holder!(SymbolStyle)> {
        &self.symbol_style
    }
    pub fn symbol_target_holders(&self) -> &HashMap<u64, as_holder!(SymbolTarget)> {
        &self.symbol_target
    }
    pub fn symmetric_shape_aspect_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SymmetricShapeAspect)> {
        &self.symmetric_shape_aspect
    }
    pub fn symmetry_tolerance_holders(&self) -> &HashMap<u64, as_holder!(SymmetryTolerance)> {
        &self.symmetry_tolerance
    }
    pub fn table_representation_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(TableRepresentationItem)> {
        &self.table_representation_item
    }
    pub fn tactile_appearance_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(TactileAppearanceRepresentation)> {
        &self.tactile_appearance_representation
    }
    pub fn tagged_text_format_holders(&self) -> &HashMap<u64, as_holder!(TaggedTextFormat)> {
        &self.tagged_text_format
    }
    pub fn tagged_text_item_holders(&self) -> &HashMap<u64, as_holder!(TaggedTextItem)> {
        &self.tagged_text_item
    }
    pub fn tangent_holders(&self) -> &HashMap<u64, as_holder!(Tangent)> {
        &self.tangent
    }
    pub fn terminator_symbol_holders(&self) -> &HashMap<u64, as_holder!(TerminatorSymbol)> {
        &self.terminator_symbol
    }
    pub fn text_font_holders(&self) -> &HashMap<u64, as_holder!(TextFont)> {
        &self.text_font
    }
    pub fn text_font_family_holders(&self) -> &HashMap<u64, as_holder!(TextFontFamily)> {
        &self.text_font_family
    }
    pub fn text_font_in_family_holders(&self) -> &HashMap<u64, as_holder!(TextFontInFamily)> {
        &self.text_font_in_family
    }
    pub fn text_literal_holders(&self) -> &HashMap<u64, as_holder!(TextLiteral)> {
        &self.text_literal
    }
    pub fn text_literal_with_associated_curves_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(TextLiteralWithAssociatedCurves)> {
        &self.text_literal_with_associated_curves
    }
    pub fn text_literal_with_blanking_box_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(TextLiteralWithBlankingBox)> {
        &self.text_literal_with_blanking_box
    }
    pub fn text_literal_with_delineation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(TextLiteralWithDelineation)> {
        &self.text_literal_with_delineation
    }
    pub fn text_literal_with_extent_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(TextLiteralWithExtent)> {
        &self.text_literal_with_extent
    }
    pub fn text_string_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(TextStringRepresentation)> {
        &self.text_string_representation
    }
    pub fn text_style_holders(&self) -> &HashMap<u64, as_holder!(TextStyle)> {
        &self.text_style
    }
    pub fn text_style_for_defined_font_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(TextStyleForDefinedFont)> {
        &self.text_style_for_defined_font
    }
    pub fn text_style_with_box_characteristics_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(TextStyleWithBoxCharacteristics)> {
        &self.text_style_with_box_characteristics
    }
    pub fn text_style_with_mirror_holders(&self) -> &HashMap<u64, as_holder!(TextStyleWithMirror)> {
        &self.text_style_with_mirror
    }
    pub fn text_style_with_spacing_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(TextStyleWithSpacing)> {
        &self.text_style_with_spacing
    }
    pub fn thermal_resistance_measure_with_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ThermalResistanceMeasureWithUnit)> {
        &self.thermal_resistance_measure_with_unit
    }
    pub fn thermal_resistance_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ThermalResistanceUnit)> {
        &self.thermal_resistance_unit
    }
    pub fn thermodynamic_temperature_measure_with_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ThermodynamicTemperatureMeasureWithUnit)> {
        &self.thermodynamic_temperature_measure_with_unit
    }
    pub fn thermodynamic_temperature_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ThermodynamicTemperatureUnit)> {
        &self.thermodynamic_temperature_unit
    }
    pub fn thickened_face_solid_holders(&self) -> &HashMap<u64, as_holder!(ThickenedFaceSolid)> {
        &self.thickened_face_solid
    }
    pub fn thickness_laminate_definition_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ThicknessLaminateDefinition)> {
        &self.thickness_laminate_definition
    }
    pub fn thickness_laminate_table_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ThicknessLaminateTable)> {
        &self.thickness_laminate_table
    }
    pub fn time_interval_holders(&self) -> &HashMap<u64, as_holder!(TimeInterval)> {
        &self.time_interval
    }
    pub fn time_interval_assignment_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(TimeIntervalAssignment)> {
        &self.time_interval_assignment
    }
    pub fn time_interval_based_effectivity_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(TimeIntervalBasedEffectivity)> {
        &self.time_interval_based_effectivity
    }
    pub fn time_interval_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(TimeIntervalRelationship)> {
        &self.time_interval_relationship
    }
    pub fn time_interval_role_holders(&self) -> &HashMap<u64, as_holder!(TimeIntervalRole)> {
        &self.time_interval_role
    }
    pub fn time_interval_with_bounds_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(TimeIntervalWithBounds)> {
        &self.time_interval_with_bounds
    }
    pub fn time_measure_with_unit_holders(&self) -> &HashMap<u64, as_holder!(TimeMeasureWithUnit)> {
        &self.time_measure_with_unit
    }
    pub fn time_unit_holders(&self) -> &HashMap<u64, as_holder!(TimeUnit)> {
        &self.time_unit
    }
    pub fn tolerance_value_holders(&self) -> &HashMap<u64, as_holder!(ToleranceValue)> {
        &self.tolerance_value
    }
    pub fn tolerance_zone_holders(&self) -> &HashMap<u64, as_holder!(ToleranceZone)> {
        &self.tolerance_zone
    }
    pub fn tolerance_zone_definition_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ToleranceZoneDefinition)> {
        &self.tolerance_zone_definition
    }
    pub fn tolerance_zone_form_holders(&self) -> &HashMap<u64, as_holder!(ToleranceZoneForm)> {
        &self.tolerance_zone_form
    }
    pub fn topological_representation_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(TopologicalRepresentationItem)> {
        &self.topological_representation_item
    }
    pub fn toroidal_surface_holders(&self) -> &HashMap<u64, as_holder!(ToroidalSurface)> {
        &self.toroidal_surface
    }
    pub fn torus_holders(&self) -> &HashMap<u64, as_holder!(Torus)> {
        &self.torus
    }
    pub fn total_runout_tolerance_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(TotalRunoutTolerance)> {
        &self.total_runout_tolerance
    }
    pub fn track_blended_solid_holders(&self) -> &HashMap<u64, as_holder!(TrackBlendedSolid)> {
        &self.track_blended_solid
    }
    pub fn track_blended_solid_with_end_conditions_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(TrackBlendedSolidWithEndConditions)> {
        &self.track_blended_solid_with_end_conditions
    }
    pub fn transformation_with_derived_angle_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(TransformationWithDerivedAngle)> {
        &self.transformation_with_derived_angle
    }
    pub fn trimmed_curve_holders(&self) -> &HashMap<u64, as_holder!(TrimmedCurve)> {
        &self.trimmed_curve
    }
    pub fn two_direction_repeat_factor_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(TwoDirectionRepeatFactor)> {
        &self.two_direction_repeat_factor
    }
    pub fn type_qualifier_holders(&self) -> &HashMap<u64, as_holder!(TypeQualifier)> {
        &self.type_qualifier
    }
    pub fn unary_generic_expression_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(UnaryGenericExpression)> {
        &self.unary_generic_expression
    }
    pub fn unary_numeric_expression_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(UnaryNumericExpression)> {
        &self.unary_numeric_expression
    }
    pub fn uncertainty_assigned_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(UncertaintyAssignedRepresentation)> {
        &self.uncertainty_assigned_representation
    }
    pub fn uncertainty_measure_with_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(UncertaintyMeasureWithUnit)> {
        &self.uncertainty_measure_with_unit
    }
    pub fn uncertainty_qualifier_holders(&self) -> &HashMap<u64, as_holder!(UncertaintyQualifier)> {
        &self.uncertainty_qualifier
    }
    pub fn uniform_curve_holders(&self) -> &HashMap<u64, as_holder!(UniformCurve)> {
        &self.uniform_curve
    }
    pub fn uniform_resource_identifier_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(UniformResourceIdentifier)> {
        &self.uniform_resource_identifier
    }
    pub fn uniform_surface_holders(&self) -> &HashMap<u64, as_holder!(UniformSurface)> {
        &self.uniform_surface
    }
    pub fn usage_association_holders(&self) -> &HashMap<u64, as_holder!(UsageAssociation)> {
        &self.usage_association
    }
    pub fn user_defined_curve_font_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(UserDefinedCurveFont)> {
        &self.user_defined_curve_font
    }
    pub fn user_defined_marker_holders(&self) -> &HashMap<u64, as_holder!(UserDefinedMarker)> {
        &self.user_defined_marker
    }
    pub fn user_defined_terminator_symbol_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(UserDefinedTerminatorSymbol)> {
        &self.user_defined_terminator_symbol
    }
    pub fn user_selected_elements_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(UserSelectedElements)> {
        &self.user_selected_elements
    }
    pub fn user_selected_shape_elements_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(UserSelectedShapeElements)> {
        &self.user_selected_shape_elements
    }
    pub fn value_range_holders(&self) -> &HashMap<u64, as_holder!(ValueRange)> {
        &self.value_range
    }
    pub fn value_representation_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ValueRepresentationItem)> {
        &self.value_representation_item
    }
    pub fn variable_semantics_holders(&self) -> &HashMap<u64, as_holder!(VariableSemantics)> {
        &self.variable_semantics
    }
    pub fn variational_representation_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(VariationalRepresentationItem)> {
        &self.variational_representation_item
    }
    pub fn vector_holders(&self) -> &HashMap<u64, as_holder!(Vector)> {
        &self.vector
    }
    pub fn vector_style_holders(&self) -> &HashMap<u64, as_holder!(VectorStyle)> {
        &self.vector_style
    }
    pub fn velocity_measure_with_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(VelocityMeasureWithUnit)> {
        &self.velocity_measure_with_unit
    }
    pub fn velocity_unit_holders(&self) -> &HashMap<u64, as_holder!(VelocityUnit)> {
        &self.velocity_unit
    }
    pub fn versioned_action_request_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(VersionedActionRequest)> {
        &self.versioned_action_request
    }
    pub fn vertex_holders(&self) -> &HashMap<u64, as_holder!(Vertex)> {
        &self.vertex
    }
    pub fn vertex_loop_holders(&self) -> &HashMap<u64, as_holder!(VertexLoop)> {
        &self.vertex_loop
    }
    pub fn vertex_point_holders(&self) -> &HashMap<u64, as_holder!(VertexPoint)> {
        &self.vertex_point
    }
    pub fn vertex_shell_holders(&self) -> &HashMap<u64, as_holder!(VertexShell)> {
        &self.vertex_shell
    }
    pub fn view_volume_holders(&self) -> &HashMap<u64, as_holder!(ViewVolume)> {
        &self.view_volume
    }
    pub fn visual_appearance_representation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(VisualAppearanceRepresentation)> {
        &self.visual_appearance_representation
    }
    pub fn volume_measure_with_unit_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(VolumeMeasureWithUnit)> {
        &self.volume_measure_with_unit
    }
    pub fn volume_unit_holders(&self) -> &HashMap<u64, as_holder!(VolumeUnit)> {
        &self.volume_unit
    }
    pub fn week_of_year_and_day_date_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(WeekOfYearAndDayDate)> {
        &self.week_of_year_and_day_date
    }
    pub fn wire_shell_holders(&self) -> &HashMap<u64, as_holder!(WireShell)> {
        &self.wire_shell
    }
    pub fn year_month_holders(&self) -> &HashMap<u64, as_holder!(YearMonth)> {
        &self.year_month
    }
    pub fn zone_structural_makeup_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ZoneStructuralMakeup)> {
        &self.zone_structural_makeup
    }
    pub fn absorbed_dose_measure_holders(&self) -> &HashMap<u64, as_holder!(AbsorbedDoseMeasure)> {
        &self.absorbed_dose_measure
    }
    pub fn acceleration_measure_holders(&self) -> &HashMap<u64, as_holder!(AccelerationMeasure)> {
        &self.acceleration_measure
    }
    pub fn action_items_holders(&self) -> &HashMap<u64, as_holder!(ActionItems)> {
        &self.action_items
    }
    pub fn action_method_items_holders(&self) -> &HashMap<u64, as_holder!(ActionMethodItems)> {
        &self.action_method_items
    }
    pub fn action_request_item_holders(&self) -> &HashMap<u64, as_holder!(ActionRequestItem)> {
        &self.action_request_item
    }
    pub fn amount_of_substance_measure_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AmountOfSubstanceMeasure)> {
        &self.amount_of_substance_measure
    }
    pub fn angle_direction_reference_select_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AngleDirectionReferenceSelect)> {
        &self.angle_direction_reference_select
    }
    pub fn angle_direction_reference_with_a2p3d_select_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AngleDirectionReferenceWithA2P3DSelect)> {
        &self.angle_direction_reference_with_a2p3d_select
    }
    pub fn annotation_plane_element_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AnnotationPlaneElement)> {
        &self.annotation_plane_element
    }
    pub fn annotation_representation_select_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AnnotationRepresentationSelect)> {
        &self.annotation_representation_select
    }
    pub fn annotation_symbol_occurrence_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AnnotationSymbolOccurrenceItem)> {
        &self.annotation_symbol_occurrence_item
    }
    pub fn annotation_text_occurrence_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AnnotationTextOccurrenceItem)> {
        &self.annotation_text_occurrence_item
    }
    pub fn approval_item_holders(&self) -> &HashMap<u64, as_holder!(ApprovalItem)> {
        &self.approval_item
    }
    pub fn approved_item_holders(&self) -> &HashMap<u64, as_holder!(ApprovedItem)> {
        &self.approved_item
    }
    pub fn area_measure_holders(&self) -> &HashMap<u64, as_holder!(AreaMeasure)> {
        &self.area_measure
    }
    pub fn area_or_view_holders(&self) -> &HashMap<u64, as_holder!(AreaOrView)> {
        &self.area_or_view
    }
    pub fn attribute_classification_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AttributeClassificationItem)> {
        &self.attribute_classification_item
    }
    pub fn attribute_language_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(AttributeLanguageItem)> {
        &self.attribute_language_item
    }
    pub fn attribute_type_holders(&self) -> &HashMap<u64, as_holder!(AttributeType)> {
        &self.attribute_type
    }
    pub fn axis2_placement_holders(&self) -> &HashMap<u64, as_holder!(Axis2Placement)> {
        &self.axis2_placement
    }
    pub fn base_solid_select_holders(&self) -> &HashMap<u64, as_holder!(BaseSolidSelect)> {
        &self.base_solid_select
    }
    pub fn blend_end_condition_select_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(BlendEndConditionSelect)> {
        &self.blend_end_condition_select
    }
    pub fn boolean_operand_holders(&self) -> &HashMap<u64, as_holder!(BooleanOperand)> {
        &self.boolean_operand
    }
    pub fn box_characteristic_select_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(BoxCharacteristicSelect)> {
        &self.box_characteristic_select
    }
    pub fn box_height_holders(&self) -> &HashMap<u64, as_holder!(BoxHeight)> {
        &self.box_height
    }
    pub fn box_rotate_angle_holders(&self) -> &HashMap<u64, as_holder!(BoxRotateAngle)> {
        &self.box_rotate_angle
    }
    pub fn box_slant_angle_holders(&self) -> &HashMap<u64, as_holder!(BoxSlantAngle)> {
        &self.box_slant_angle
    }
    pub fn box_width_holders(&self) -> &HashMap<u64, as_holder!(BoxWidth)> {
        &self.box_width
    }
    pub fn camera_model_d3_multi_clipping_interection_select_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CameraModelD3MultiClippingInterectionSelect)> {
        &self.camera_model_d3_multi_clipping_interection_select
    }
    pub fn camera_model_d3_multi_clipping_union_select_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CameraModelD3MultiClippingUnionSelect)> {
        &self.camera_model_d3_multi_clipping_union_select
    }
    pub fn capacitance_measure_holders(&self) -> &HashMap<u64, as_holder!(CapacitanceMeasure)> {
        &self.capacitance_measure
    }
    pub fn category_usage_item_holders(&self) -> &HashMap<u64, as_holder!(CategoryUsageItem)> {
        &self.category_usage_item
    }
    pub fn cc_classified_item_holders(&self) -> &HashMap<u64, as_holder!(CcClassifiedItem)> {
        &self.cc_classified_item
    }
    pub fn cc_person_organization_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CcPersonOrganizationItem)> {
        &self.cc_person_organization_item
    }
    pub fn cc_specified_item_holders(&self) -> &HashMap<u64, as_holder!(CcSpecifiedItem)> {
        &self.cc_specified_item
    }
    pub fn celsius_temperature_measure_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CelsiusTemperatureMeasure)> {
        &self.celsius_temperature_measure
    }
    pub fn certification_item_holders(&self) -> &HashMap<u64, as_holder!(CertificationItem)> {
        &self.certification_item
    }
    pub fn certified_item_holders(&self) -> &HashMap<u64, as_holder!(CertifiedItem)> {
        &self.certified_item
    }
    pub fn change_request_item_holders(&self) -> &HashMap<u64, as_holder!(ChangeRequestItem)> {
        &self.change_request_item
    }
    pub fn character_spacing_select_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CharacterSpacingSelect)> {
        &self.character_spacing_select
    }
    pub fn character_style_select_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CharacterStyleSelect)> {
        &self.character_style_select
    }
    pub fn characterized_action_definition_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CharacterizedActionDefinition)> {
        &self.characterized_action_definition
    }
    pub fn characterized_definition_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CharacterizedDefinition)> {
        &self.characterized_definition
    }
    pub fn characterized_material_property_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CharacterizedMaterialProperty)> {
        &self.characterized_material_property
    }
    pub fn characterized_product_composition_value_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CharacterizedProductCompositionValue)> {
        &self.characterized_product_composition_value
    }
    pub fn characterized_product_definition_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CharacterizedProductDefinition)> {
        &self.characterized_product_definition
    }
    pub fn class_usage_effectivity_context_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ClassUsageEffectivityContextItem)> {
        &self.class_usage_effectivity_context_item
    }
    pub fn classification_item_holders(&self) -> &HashMap<u64, as_holder!(ClassificationItem)> {
        &self.classification_item
    }
    pub fn classified_item_holders(&self) -> &HashMap<u64, as_holder!(ClassifiedItem)> {
        &self.classified_item
    }
    pub fn compound_item_definition_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CompoundItemDefinition)> {
        &self.compound_item_definition
    }
    pub fn conductance_measure_holders(&self) -> &HashMap<u64, as_holder!(ConductanceMeasure)> {
        &self.conductance_measure
    }
    pub fn configuration_design_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ConfigurationDesignItem)> {
        &self.configuration_design_item
    }
    pub fn configured_effectivity_context_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ConfiguredEffectivityContextItem)> {
        &self.configured_effectivity_context_item
    }
    pub fn configured_effectivity_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ConfiguredEffectivityItem)> {
        &self.configured_effectivity_item
    }
    pub fn constructive_geometry_representation_or_shape_represenation_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ConstructiveGeometryRepresentationOrShapeRepresenation)> {
        &self.constructive_geometry_representation_or_shape_represenation
    }
    pub fn context_dependent_measure_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ContextDependentMeasure)> {
        &self.context_dependent_measure
    }
    pub fn contract_item_holders(&self) -> &HashMap<u64, as_holder!(ContractItem)> {
        &self.contract_item
    }
    pub fn contracted_item_holders(&self) -> &HashMap<u64, as_holder!(ContractedItem)> {
        &self.contracted_item
    }
    pub fn count_measure_holders(&self) -> &HashMap<u64, as_holder!(CountMeasure)> {
        &self.count_measure
    }
    pub fn csg_primitive_holders(&self) -> &HashMap<u64, as_holder!(CsgPrimitive)> {
        &self.csg_primitive
    }
    pub fn csg_select_holders(&self) -> &HashMap<u64, as_holder!(CsgSelect)> {
        &self.csg_select
    }
    pub fn curve_font_or_scaled_curve_font_select_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CurveFontOrScaledCurveFontSelect)> {
        &self.curve_font_or_scaled_curve_font_select
    }
    pub fn curve_on_surface_holders(&self) -> &HashMap<u64, as_holder!(CurveOnSurface)> {
        &self.curve_on_surface
    }
    pub fn curve_or_annotation_curve_occurrence_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CurveOrAnnotationCurveOccurrence)> {
        &self.curve_or_annotation_curve_occurrence
    }
    pub fn curve_or_render_holders(&self) -> &HashMap<u64, as_holder!(CurveOrRender)> {
        &self.curve_or_render
    }
    pub fn curve_style_font_select_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(CurveStyleFontSelect)> {
        &self.curve_style_font_select
    }
    pub fn date_and_time_item_holders(&self) -> &HashMap<u64, as_holder!(DateAndTimeItem)> {
        &self.date_and_time_item
    }
    pub fn date_item_holders(&self) -> &HashMap<u64, as_holder!(DateItem)> {
        &self.date_item
    }
    pub fn date_time_item_holders(&self) -> &HashMap<u64, as_holder!(DateTimeItem)> {
        &self.date_time_item
    }
    pub fn date_time_or_event_occurrence_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DateTimeOrEventOccurrence)> {
        &self.date_time_or_event_occurrence
    }
    pub fn date_time_select_holders(&self) -> &HashMap<u64, as_holder!(DateTimeSelect)> {
        &self.date_time_select
    }
    pub fn day_in_month_number_holders(&self) -> &HashMap<u64, as_holder!(DayInMonthNumber)> {
        &self.day_in_month_number
    }
    pub fn day_in_week_number_holders(&self) -> &HashMap<u64, as_holder!(DayInWeekNumber)> {
        &self.day_in_week_number
    }
    pub fn day_in_year_number_holders(&self) -> &HashMap<u64, as_holder!(DayInYearNumber)> {
        &self.day_in_year_number
    }
    pub fn defined_symbol_select_holders(&self) -> &HashMap<u64, as_holder!(DefinedSymbolSelect)> {
        &self.defined_symbol_select
    }
    pub fn derived_property_select_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DerivedPropertySelect)> {
        &self.derived_property_select
    }
    pub fn description_attribute_select_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DescriptionAttributeSelect)> {
        &self.description_attribute_select
    }
    pub fn descriptive_measure_holders(&self) -> &HashMap<u64, as_holder!(DescriptiveMeasure)> {
        &self.descriptive_measure
    }
    pub fn dimension_count_holders(&self) -> &HashMap<u64, as_holder!(DimensionCount)> {
        &self.dimension_count
    }
    pub fn dimensional_characteristic_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DimensionalCharacteristic)> {
        &self.dimensional_characteristic
    }
    pub fn direction_count_select_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DirectionCountSelect)> {
        &self.direction_count_select
    }
    pub fn document_identifier_assigned_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DocumentIdentifierAssignedItem)> {
        &self.document_identifier_assigned_item
    }
    pub fn document_reference_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DocumentReferenceItem)> {
        &self.document_reference_item
    }
    pub fn dose_equivalent_measure_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DoseEquivalentMeasure)> {
        &self.dose_equivalent_measure
    }
    pub fn draughting_callout_element_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DraughtingCalloutElement)> {
        &self.draughting_callout_element
    }
    pub fn draughting_model_item_association_select_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DraughtingModelItemAssociationSelect)> {
        &self.draughting_model_item_association_select
    }
    pub fn draughting_model_item_select_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DraughtingModelItemSelect)> {
        &self.draughting_model_item_select
    }
    pub fn draughting_titled_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(DraughtingTitledItem)> {
        &self.draughting_titled_item
    }
    pub fn effectivity_item_holders(&self) -> &HashMap<u64, as_holder!(EffectivityItem)> {
        &self.effectivity_item
    }
    pub fn electric_charge_measure_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ElectricChargeMeasure)> {
        &self.electric_charge_measure
    }
    pub fn electric_current_measure_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ElectricCurrentMeasure)> {
        &self.electric_current_measure
    }
    pub fn electric_potential_measure_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ElectricPotentialMeasure)> {
        &self.electric_potential_measure
    }
    pub fn energy_measure_holders(&self) -> &HashMap<u64, as_holder!(EnergyMeasure)> {
        &self.energy_measure
    }
    pub fn event_occurrence_item_holders(&self) -> &HashMap<u64, as_holder!(EventOccurrenceItem)> {
        &self.event_occurrence_item
    }
    pub fn external_identification_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ExternalIdentificationItem)> {
        &self.external_identification_item
    }
    pub fn fill_area_style_tile_shape_select_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(FillAreaStyleTileShapeSelect)> {
        &self.fill_area_style_tile_shape_select
    }
    pub fn fill_style_select_holders(&self) -> &HashMap<u64, as_holder!(FillStyleSelect)> {
        &self.fill_style_select
    }
    pub fn font_select_holders(&self) -> &HashMap<u64, as_holder!(FontSelect)> {
        &self.font_select
    }
    pub fn force_measure_holders(&self) -> &HashMap<u64, as_holder!(ForceMeasure)> {
        &self.force_measure
    }
    pub fn founded_item_select_holders(&self) -> &HashMap<u64, as_holder!(FoundedItemSelect)> {
        &self.founded_item_select
    }
    pub fn frequency_measure_holders(&self) -> &HashMap<u64, as_holder!(FrequencyMeasure)> {
        &self.frequency_measure
    }
    pub fn generalized_surface_select_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(GeneralizedSurfaceSelect)> {
        &self.generalized_surface_select
    }
    pub fn geometric_item_specific_usage_select_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(GeometricItemSpecificUsageSelect)> {
        &self.geometric_item_specific_usage_select
    }
    pub fn geometric_set_select_holders(&self) -> &HashMap<u64, as_holder!(GeometricSetSelect)> {
        &self.geometric_set_select
    }
    pub fn groupable_item_holders(&self) -> &HashMap<u64, as_holder!(GroupableItem)> {
        &self.groupable_item
    }
    pub fn hour_in_day_holders(&self) -> &HashMap<u64, as_holder!(HourInDay)> {
        &self.hour_in_day
    }
    pub fn id_attribute_select_holders(&self) -> &HashMap<u64, as_holder!(IdAttributeSelect)> {
        &self.id_attribute_select
    }
    pub fn identification_item_holders(&self) -> &HashMap<u64, as_holder!(IdentificationItem)> {
        &self.identification_item
    }
    pub fn identifier_holders(&self) -> &HashMap<u64, as_holder!(Identifier)> {
        &self.identifier
    }
    pub fn illuminance_measure_holders(&self) -> &HashMap<u64, as_holder!(IlluminanceMeasure)> {
        &self.illuminance_measure
    }
    pub fn inductance_measure_holders(&self) -> &HashMap<u64, as_holder!(InductanceMeasure)> {
        &self.inductance_measure
    }
    pub fn instance_usage_context_select_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(InstanceUsageContextSelect)> {
        &self.instance_usage_context_select
    }
    pub fn invisibility_context_holders(&self) -> &HashMap<u64, as_holder!(InvisibilityContext)> {
        &self.invisibility_context
    }
    pub fn invisible_item_holders(&self) -> &HashMap<u64, as_holder!(InvisibleItem)> {
        &self.invisible_item
    }
    pub fn ir_usage_item_holders(&self) -> &HashMap<u64, as_holder!(IrUsageItem)> {
        &self.ir_usage_item
    }
    pub fn label_holders(&self) -> &HashMap<u64, as_holder!(Label)> {
        &self.label
    }
    pub fn layered_item_holders(&self) -> &HashMap<u64, as_holder!(LayeredItem)> {
        &self.layered_item
    }
    pub fn length_measure_holders(&self) -> &HashMap<u64, as_holder!(LengthMeasure)> {
        &self.length_measure
    }
    pub fn list_of_reversible_topology_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ListOfReversibleTopologyItem)> {
        &self.list_of_reversible_topology_item
    }
    pub fn list_representation_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ListRepresentationItem)> {
        &self.list_representation_item
    }
    pub fn luminous_flux_measure_holders(&self) -> &HashMap<u64, as_holder!(LuminousFluxMeasure)> {
        &self.luminous_flux_measure
    }
    pub fn luminous_intensity_measure_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(LuminousIntensityMeasure)> {
        &self.luminous_intensity_measure
    }
    pub fn magnetic_flux_density_measure_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(MagneticFluxDensityMeasure)> {
        &self.magnetic_flux_density_measure
    }
    pub fn magnetic_flux_measure_holders(&self) -> &HashMap<u64, as_holder!(MagneticFluxMeasure)> {
        &self.magnetic_flux_measure
    }
    pub fn marker_select_holders(&self) -> &HashMap<u64, as_holder!(MarkerSelect)> {
        &self.marker_select
    }
    pub fn mass_measure_holders(&self) -> &HashMap<u64, as_holder!(MassMeasure)> {
        &self.mass_measure
    }
    pub fn measure_value_holders(&self) -> &HashMap<u64, as_holder!(MeasureValue)> {
        &self.measure_value
    }
    pub fn mechanical_design_and_draughting_relationship_select_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(MechanicalDesignAndDraughtingRelationshipSelect)> {
        &self.mechanical_design_and_draughting_relationship_select
    }
    pub fn mechanical_design_geometric_presentation_area_items_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(MechanicalDesignGeometricPresentationAreaItems)> {
        &self.mechanical_design_geometric_presentation_area_items
    }
    pub fn mechanical_design_geometric_presentation_representation_items_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(MechanicalDesignGeometricPresentationRepresentationItems)> {
        &self.mechanical_design_geometric_presentation_representation_items
    }
    pub fn message_holders(&self) -> &HashMap<u64, as_holder!(Message)> {
        &self.message
    }
    pub fn minute_in_hour_holders(&self) -> &HashMap<u64, as_holder!(MinuteInHour)> {
        &self.minute_in_hour
    }
    pub fn month_in_year_number_holders(&self) -> &HashMap<u64, as_holder!(MonthInYearNumber)> {
        &self.month_in_year_number
    }
    pub fn multi_language_attribute_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(MultiLanguageAttributeItem)> {
        &self.multi_language_attribute_item
    }
    pub fn name_attribute_select_holders(&self) -> &HashMap<u64, as_holder!(NameAttributeSelect)> {
        &self.name_attribute_select
    }
    pub fn name_item_holders(&self) -> &HashMap<u64, as_holder!(NameItem)> {
        &self.name_item
    }
    pub fn non_negative_length_measure_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(NonNegativeLengthMeasure)> {
        &self.non_negative_length_measure
    }
    pub fn nonnegative_integer_holders(&self) -> &HashMap<u64, as_holder!(NonnegativeInteger)> {
        &self.nonnegative_integer
    }
    pub fn numeric_measure_holders(&self) -> &HashMap<u64, as_holder!(NumericMeasure)> {
        &self.numeric_measure
    }
    pub fn organization_item_holders(&self) -> &HashMap<u64, as_holder!(OrganizationItem)> {
        &self.organization_item
    }
    pub fn orientation_basis_select_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(OrientationBasisSelect)> {
        &self.orientation_basis_select
    }
    pub fn parameter_value_holders(&self) -> &HashMap<u64, as_holder!(ParameterValue)> {
        &self.parameter_value
    }
    pub fn pcurve_or_surface_holders(&self) -> &HashMap<u64, as_holder!(PcurveOrSurface)> {
        &self.pcurve_or_surface
    }
    pub fn person_and_organization_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PersonAndOrganizationItem)> {
        &self.person_and_organization_item
    }
    pub fn person_organization_select_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PersonOrganizationSelect)> {
        &self.person_organization_select
    }
    pub fn picture_representation_item_select_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PictureRepresentationItemSelect)> {
        &self.picture_representation_item_select
    }
    pub fn plane_angle_measure_holders(&self) -> &HashMap<u64, as_holder!(PlaneAngleMeasure)> {
        &self.plane_angle_measure
    }
    pub fn plane_or_planar_box_holders(&self) -> &HashMap<u64, as_holder!(PlaneOrPlanarBox)> {
        &self.plane_or_planar_box
    }
    pub fn point_and_vector_member_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PointAndVectorMember)> {
        &self.point_and_vector_member
    }
    pub fn point_and_vector_members_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PointAndVectorMembers)> {
        &self.point_and_vector_members
    }
    pub fn point_path_members_holders(&self) -> &HashMap<u64, as_holder!(PointPathMembers)> {
        &self.point_path_members
    }
    pub fn positive_integer_holders(&self) -> &HashMap<u64, as_holder!(PositiveInteger)> {
        &self.positive_integer
    }
    pub fn positive_length_measure_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PositiveLengthMeasure)> {
        &self.positive_length_measure
    }
    pub fn positive_plane_angle_measure_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PositivePlaneAngleMeasure)> {
        &self.positive_plane_angle_measure
    }
    pub fn positive_ratio_measure_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PositiveRatioMeasure)> {
        &self.positive_ratio_measure
    }
    pub fn power_measure_holders(&self) -> &HashMap<u64, as_holder!(PowerMeasure)> {
        &self.power_measure
    }
    pub fn presentable_text_holders(&self) -> &HashMap<u64, as_holder!(PresentableText)> {
        &self.presentable_text
    }
    pub fn presentation_representation_select_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PresentationRepresentationSelect)> {
        &self.presentation_representation_select
    }
    pub fn presentation_size_assignment_select_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PresentationSizeAssignmentSelect)> {
        &self.presentation_size_assignment_select
    }
    pub fn presentation_style_select_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(PresentationStyleSelect)> {
        &self.presentation_style_select
    }
    pub fn presented_item_select_holders(&self) -> &HashMap<u64, as_holder!(PresentedItemSelect)> {
        &self.presented_item_select
    }
    pub fn pressure_measure_holders(&self) -> &HashMap<u64, as_holder!(PressureMeasure)> {
        &self.pressure_measure
    }
    pub fn product_definition_or_assembly_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ProductDefinitionOrAssemblyRelationship)> {
        &self.product_definition_or_assembly_relationship
    }
    pub fn product_definition_or_breakdown_element_usage_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ProductDefinitionOrBreakdownElementUsage)> {
        &self.product_definition_or_breakdown_element_usage
    }
    pub fn product_definition_or_product_definition_relationship_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ProductDefinitionOrProductDefinitionRelationship)> {
        &self.product_definition_or_product_definition_relationship
    }
    pub fn product_or_formation_or_definition_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ProductOrFormationOrDefinition)> {
        &self.product_or_formation_or_definition
    }
    pub fn project_item_holders(&self) -> &HashMap<u64, as_holder!(ProjectItem)> {
        &self.project_item
    }
    pub fn radioactivity_measure_holders(&self) -> &HashMap<u64, as_holder!(RadioactivityMeasure)> {
        &self.radioactivity_measure
    }
    pub fn ratio_measure_holders(&self) -> &HashMap<u64, as_holder!(RatioMeasure)> {
        &self.ratio_measure
    }
    pub fn rendering_properties_select_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(RenderingPropertiesSelect)> {
        &self.rendering_properties_select
    }
    pub fn represented_definition_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(RepresentedDefinition)> {
        &self.represented_definition
    }
    pub fn requirement_assigned_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(RequirementAssignedItem)> {
        &self.requirement_assigned_item
    }
    pub fn requirement_satisfaction_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(RequirementSatisfactionItem)> {
        &self.requirement_satisfaction_item
    }
    pub fn requirement_source_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(RequirementSourceItem)> {
        &self.requirement_source_item
    }
    pub fn resistance_measure_holders(&self) -> &HashMap<u64, as_holder!(ResistanceMeasure)> {
        &self.resistance_measure
    }
    pub fn reversible_topology_holders(&self) -> &HashMap<u64, as_holder!(ReversibleTopology)> {
        &self.reversible_topology
    }
    pub fn reversible_topology_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ReversibleTopologyItem)> {
        &self.reversible_topology_item
    }
    pub fn role_select_holders(&self) -> &HashMap<u64, as_holder!(RoleSelect)> {
        &self.role_select
    }
    pub fn rule_superseded_item_holders(&self) -> &HashMap<u64, as_holder!(RuleSupersededItem)> {
        &self.rule_superseded_item
    }
    pub fn second_in_minute_holders(&self) -> &HashMap<u64, as_holder!(SecondInMinute)> {
        &self.second_in_minute
    }
    pub fn security_classification_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SecurityClassificationItem)> {
        &self.security_classification_item
    }
    pub fn set_of_reversible_topology_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SetOfReversibleTopologyItem)> {
        &self.set_of_reversible_topology_item
    }
    pub fn set_representation_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SetRepresentationItem)> {
        &self.set_representation_item
    }
    pub fn shape_definition_holders(&self) -> &HashMap<u64, as_holder!(ShapeDefinition)> {
        &self.shape_definition
    }
    pub fn shell_holders(&self) -> &HashMap<u64, as_holder!(Shell)> {
        &self.shell
    }
    pub fn size_select_holders(&self) -> &HashMap<u64, as_holder!(SizeSelect)> {
        &self.size_select
    }
    pub fn sketch_basis_select_holders(&self) -> &HashMap<u64, as_holder!(SketchBasisSelect)> {
        &self.sketch_basis_select
    }
    pub fn solid_angle_measure_holders(&self) -> &HashMap<u64, as_holder!(SolidAngleMeasure)> {
        &self.solid_angle_measure
    }
    pub fn source_item_holders(&self) -> &HashMap<u64, as_holder!(SourceItem)> {
        &self.source_item
    }
    pub fn start_request_item_holders(&self) -> &HashMap<u64, as_holder!(StartRequestItem)> {
        &self.start_request_item
    }
    pub fn string_representation_item_select_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(StringRepresentationItemSelect)> {
        &self.string_representation_item_select
    }
    pub fn style_context_select_holders(&self) -> &HashMap<u64, as_holder!(StyleContextSelect)> {
        &self.style_context_select
    }
    pub fn surface_side_style_select_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SurfaceSideStyleSelect)> {
        &self.surface_side_style_select
    }
    pub fn surface_style_element_select_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(SurfaceStyleElementSelect)> {
        &self.surface_style_element_select
    }
    pub fn symbol_style_select_holders(&self) -> &HashMap<u64, as_holder!(SymbolStyleSelect)> {
        &self.symbol_style_select
    }
    pub fn text_holders(&self) -> &HashMap<u64, as_holder!(Text)> {
        &self.text
    }
    pub fn text_alignment_holders(&self) -> &HashMap<u64, as_holder!(TextAlignment)> {
        &self.text_alignment
    }
    pub fn text_delineation_holders(&self) -> &HashMap<u64, as_holder!(TextDelineation)> {
        &self.text_delineation
    }
    pub fn text_or_character_holders(&self) -> &HashMap<u64, as_holder!(TextOrCharacter)> {
        &self.text_or_character
    }
    pub fn text_string_representation_item_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(TextStringRepresentationItem)> {
        &self.text_string_representation_item
    }
    pub fn thermodynamic_temperature_measure_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ThermodynamicTemperatureMeasure)> {
        &self.thermodynamic_temperature_measure
    }
    pub fn time_interval_item_holders(&self) -> &HashMap<u64, as_holder!(TimeIntervalItem)> {
        &self.time_interval_item
    }
    pub fn time_measure_holders(&self) -> &HashMap<u64, as_holder!(TimeMeasure)> {
        &self.time_measure
    }
    pub fn tolerance_method_definition_holders(
        &self,
    ) -> &HashMap<u64, as_holder!(ToleranceMethodDefinition)> {
        &self.tolerance_method_definition
    }
    pub fn transformation_holders(&self) -> &HashMap<u64, as_holder!(Transformation)> {
        &self.transformation
    }
    pub fn trim_condition_select_holders(&self) -> &HashMap<u64, as_holder!(TrimConditionSelect)> {
        &self.trim_condition_select
    }
    pub fn trimming_select_holders(&self) -> &HashMap<u64, as_holder!(TrimmingSelect)> {
        &self.trimming_select
    }
    pub fn u_direction_count_holders(&self) -> &HashMap<u64, as_holder!(UDirectionCount)> {
        &self.u_direction_count
    }
    pub fn unit_holders(&self) -> &HashMap<u64, as_holder!(Unit)> {
        &self.unit
    }
    pub fn v_direction_count_holders(&self) -> &HashMap<u64, as_holder!(VDirectionCount)> {
        &self.v_direction_count
    }
    pub fn value_qualifier_holders(&self) -> &HashMap<u64, as_holder!(ValueQualifier)> {
        &self.value_qualifier
    }
    pub fn vector_or_direction_holders(&self) -> &HashMap<u64, as_holder!(VectorOrDirection)> {
        &self.vector_or_direction
    }
    pub fn velocity_measure_holders(&self) -> &HashMap<u64, as_holder!(VelocityMeasure)> {
        &self.velocity_measure
    }
    pub fn volume_measure_holders(&self) -> &HashMap<u64, as_holder!(VolumeMeasure)> {
        &self.volume_measure
    }
    pub fn week_in_year_number_holders(&self) -> &HashMap<u64, as_holder!(WeekInYearNumber)> {
        &self.week_in_year_number
    }
    pub fn work_item_holders(&self) -> &HashMap<u64, as_holder!(WorkItem)> {
        &self.work_item
    }
    pub fn year_number_holders(&self) -> &HashMap<u64, as_holder!(YearNumber)> {
        &self.year_number
    }
    pub fn complete_mappings(&self) -> &::phf::Map<&'static str, &'static [&'static str]> {
        &COMPLETE
    }
    pub fn partial_mappings(&self) -> &::phf::Map<&'static str, &'static [&'static str]> {
        &PARTIALS
    }
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = absorbed_dose_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct AbsorbedDoseMeasure(pub f64);
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = acceleration_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct AccelerationMeasure(pub f64);
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ActionItems {
    #[holder(use_place_holder)]
    ActionDirective(Box<ActionDirective>),
    #[holder(use_place_holder)]
    CertificationItem(Box<CertificationItem>),
    #[holder(use_place_holder)]
    CharacterizedObject(CharacterizedObjectAny),
    #[holder(use_place_holder)]
    ClassificationItem(Box<ClassificationItem>),
    #[holder(use_place_holder)]
    ConfigurationEffectivity(Box<ConfigurationEffectivity>),
    #[holder(use_place_holder)]
    DocumentReferenceItem(Box<DocumentReferenceItem>),
    #[holder(use_place_holder)]
    IdentificationItem(Box<IdentificationItem>),
    #[holder(use_place_holder)]
    Organization(Box<Organization>),
    #[holder(use_place_holder)]
    PersonAndOrganization(Box<PersonAndOrganization>),
    #[holder(use_place_holder)]
    ProductDefinition(ProductDefinitionAny),
    #[holder(use_place_holder)]
    ProductDefinitionFormation(ProductDefinitionFormationAny),
    #[holder(use_place_holder)]
    ProductDefinitionFormationRelationship(Box<ProductDefinitionFormationRelationship>),
    #[holder(use_place_holder)]
    ProductDefinitionRelationship(ProductDefinitionRelationshipAny),
    #[holder(use_place_holder)]
    RequirementAssignedItem(Box<RequirementAssignedItem>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ActionMethodItems {
    #[holder(use_place_holder)]
    Product(Box<Product>),
    #[holder(use_place_holder)]
    ProductDefinitionFormation(ProductDefinitionFormationAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ActionRequestItem {
    #[holder(use_place_holder)]
    ProductDefinition(ProductDefinitionAny),
    #[holder(use_place_holder)]
    ProductDefinitionFormation(ProductDefinitionFormationAny),
    #[holder(use_place_holder)]
    ProductDefinitionFormationRelationship(Box<ProductDefinitionFormationRelationship>),
    #[holder(use_place_holder)]
    ProductDefinitionRelationship(ProductDefinitionRelationshipAny),
    #[holder(use_place_holder)]
    PropertyDefinition(PropertyDefinitionAny),
    #[holder(use_place_holder)]
    VersionedActionRequest(Box<VersionedActionRequest>),
}
#[derive(Debug, Clone, PartialEq, :: ruststep_derive :: ToData, :: serde :: Deserialize)]
pub enum AheadOrBehind {
    Ahead,
    Exact,
    Behind,
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = amount_of_substance_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct AmountOfSubstanceMeasure(pub f64);
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum AngleDirectionReferenceSelect {
    #[holder(use_place_holder)]
    Direction(Box<Direction>),
    #[holder(use_place_holder)]
    Curve(CurveAny),
    #[holder(use_place_holder)]
    PointPath(Box<PointPath>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum AngleDirectionReferenceWithA2P3DSelect {
    #[holder(use_place_holder)]
    AngleDirectionReferenceSelect(Box<AngleDirectionReferenceSelect>),
    #[holder(use_place_holder)]
    Axis2Placement3D(Box<Axis2Placement3D>),
}
#[derive(Debug, Clone, PartialEq, :: ruststep_derive :: ToData, :: serde :: Deserialize)]
pub enum AngleRelator {
    Equal,
    Large,
    Small,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum AnnotationPlaneElement {
    #[holder(use_place_holder)]
    DraughtingCallout(DraughtingCalloutAny),
    #[holder(use_place_holder)]
    StyledItem(StyledItemAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum AnnotationRepresentationSelect {
    #[holder(use_place_holder)]
    PresentationArea(PresentationAreaAny),
    #[holder(use_place_holder)]
    PresentationView(PresentationViewAny),
    #[holder(use_place_holder)]
    SymbolRepresentation(SymbolRepresentationAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum AnnotationSymbolOccurrenceItem {
    #[holder(use_place_holder)]
    AnnotationSymbol(Box<AnnotationSymbol>),
    #[holder(use_place_holder)]
    DefinedSymbol(Box<DefinedSymbol>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum AnnotationTextOccurrenceItem {
    #[holder(use_place_holder)]
    TextLiteral(TextLiteralAny),
    #[holder(use_place_holder)]
    AnnotationText(Box<AnnotationText>),
    #[holder(use_place_holder)]
    AnnotationTextCharacter(Box<AnnotationTextCharacter>),
    #[holder(use_place_holder)]
    CompositeText(CompositeTextAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ApprovalItem {
    #[holder(use_place_holder)]
    Action(ActionAny),
    #[holder(use_place_holder)]
    ActionDirective(Box<ActionDirective>),
    #[holder(use_place_holder)]
    AlternateProductRelationship(Box<AlternateProductRelationship>),
    #[holder(use_place_holder)]
    AppliedActionAssignment(AppliedActionAssignmentAny),
    #[holder(use_place_holder)]
    AppliedUsageRight(Box<AppliedUsageRight>),
    #[holder(use_place_holder)]
    AssemblyComponentUsageSubstitute(Box<AssemblyComponentUsageSubstitute>),
    #[holder(use_place_holder)]
    Certification(Box<Certification>),
    #[holder(use_place_holder)]
    ConfigurationEffectivity(Box<ConfigurationEffectivity>),
    #[holder(use_place_holder)]
    ConfigurationItem(ConfigurationItemAny),
    #[holder(use_place_holder)]
    Contract(Box<Contract>),
    #[holder(use_place_holder)]
    Date(DateAny),
    #[holder(use_place_holder)]
    DirectedAction(Box<DirectedAction>),
    #[holder(use_place_holder)]
    Document(DocumentAny),
    #[holder(use_place_holder)]
    DocumentFile(Box<DocumentFile>),
    #[holder(use_place_holder)]
    Effectivity(EffectivityAny),
    #[holder(use_place_holder)]
    ExecutedAction(ExecutedActionAny),
    #[holder(use_place_holder)]
    GeneralPropertyRelationship(GeneralPropertyRelationshipAny),
    #[holder(use_place_holder)]
    Group(GroupAny),
    #[holder(use_place_holder)]
    GroupRelationship(Box<GroupRelationship>),
    #[holder(use_place_holder)]
    InformationUsageRight(Box<InformationUsageRight>),
    #[holder(use_place_holder)]
    Product(Box<Product>),
    #[holder(use_place_holder)]
    ProductDefinition(ProductDefinitionAny),
    #[holder(use_place_holder)]
    ProductDefinitionFormation(ProductDefinitionFormationAny),
    #[holder(use_place_holder)]
    ProductDefinitionFormationRelationship(Box<ProductDefinitionFormationRelationship>),
    #[holder(use_place_holder)]
    ProductDefinitionRelationship(ProductDefinitionRelationshipAny),
    #[holder(use_place_holder)]
    Representation(RepresentationAny),
    #[holder(use_place_holder)]
    RequirementAssignment(Box<RequirementAssignment>),
    #[holder(use_place_holder)]
    SecurityClassification(Box<SecurityClassification>),
    #[holder(use_place_holder)]
    ShapeAspectRelationship(ShapeAspectRelationshipAny),
    #[holder(use_place_holder)]
    VersionedActionRequest(Box<VersionedActionRequest>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ApprovedItem {
    #[holder(use_place_holder)]
    Certification(Box<Certification>),
    #[holder(use_place_holder)]
    Change(Box<Change>),
    #[holder(use_place_holder)]
    ChangeRequest(Box<ChangeRequest>),
    #[holder(use_place_holder)]
    ConfigurationEffectivity(Box<ConfigurationEffectivity>),
    #[holder(use_place_holder)]
    ConfigurationItem(ConfigurationItemAny),
    #[holder(use_place_holder)]
    Contract(Box<Contract>),
    #[holder(use_place_holder)]
    Product(Box<Product>),
    #[holder(use_place_holder)]
    SecurityClassification(Box<SecurityClassification>),
    #[holder(use_place_holder)]
    StartRequest(Box<StartRequest>),
    #[holder(use_place_holder)]
    StartWork(Box<StartWork>),
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = area_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct AreaMeasure(pub f64);
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum AreaOrView {
    #[holder(use_place_holder)]
    PresentationArea(PresentationAreaAny),
    #[holder(use_place_holder)]
    PresentationView(PresentationViewAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum AttributeClassificationItem {
    #[holder(use_place_holder)]
    ActionDirective(Box<ActionDirective>),
    #[holder(use_place_holder)]
    ActionMethod(ActionMethodAny),
    #[holder(use_place_holder)]
    ActionProperty(Box<ActionProperty>),
    #[holder(use_place_holder)]
    ActionPropertyRepresentation(Box<ActionPropertyRepresentation>),
    #[holder(use_place_holder)]
    ActionRelationship(Box<ActionRelationship>),
    #[holder(use_place_holder)]
    ActionRequestSolution(Box<ActionRequestSolution>),
    #[holder(use_place_holder)]
    ActionRequestStatus(Box<ActionRequestStatus>),
    #[holder(use_place_holder)]
    AlternateProductRelationship(Box<AlternateProductRelationship>),
    #[holder(use_place_holder)]
    AppliedActionAssignment(AppliedActionAssignmentAny),
    #[holder(use_place_holder)]
    AppliedActionRequestAssignment(Box<AppliedActionRequestAssignment>),
    #[holder(use_place_holder)]
    AppliedApprovalAssignment(Box<AppliedApprovalAssignment>),
    #[holder(use_place_holder)]
    AppliedCertificationAssignment(Box<AppliedCertificationAssignment>),
    #[holder(use_place_holder)]
    AppliedDocumentReference(Box<AppliedDocumentReference>),
    #[holder(use_place_holder)]
    AppliedDocumentUsageConstraintAssignment(AppliedDocumentUsageConstraintAssignmentAny),
    #[holder(use_place_holder)]
    AppliedEffectivityAssignment(Box<AppliedEffectivityAssignment>),
    #[holder(use_place_holder)]
    AppliedEventOccurrenceAssignment(Box<AppliedEventOccurrenceAssignment>),
    #[holder(use_place_holder)]
    AppliedExternalIdentificationAssignment(Box<AppliedExternalIdentificationAssignment>),
    #[holder(use_place_holder)]
    AppliedIdentificationAssignment(Box<AppliedIdentificationAssignment>),
    #[holder(use_place_holder)]
    AppliedOrganizationAssignment(Box<AppliedOrganizationAssignment>),
    #[holder(use_place_holder)]
    AppliedOrganizationalProjectAssignment(Box<AppliedOrganizationalProjectAssignment>),
    #[holder(use_place_holder)]
    AppliedPersonAndOrganizationAssignment(Box<AppliedPersonAndOrganizationAssignment>),
    #[holder(use_place_holder)]
    Approval(Box<Approval>),
    #[holder(use_place_holder)]
    ApprovalPersonOrganization(Box<ApprovalPersonOrganization>),
    #[holder(use_place_holder)]
    ApprovalRelationship(Box<ApprovalRelationship>),
    #[holder(use_place_holder)]
    ApprovalStatus(Box<ApprovalStatus>),
    #[holder(use_place_holder)]
    Certification(Box<Certification>),
    #[holder(use_place_holder)]
    ContextDependentUnit(ContextDependentUnitAny),
    #[holder(use_place_holder)]
    Contract(Box<Contract>),
    #[holder(use_place_holder)]
    DateAndTimeAssignment(DateAndTimeAssignmentAny),
    #[holder(use_place_holder)]
    DateAssignment(DateAssignmentAny),
    #[holder(use_place_holder)]
    DerivedUnit(DerivedUnitAny),
    #[holder(use_place_holder)]
    DescriptiveRepresentationItem(DescriptiveRepresentationItemAny),
    #[holder(use_place_holder)]
    DocumentFile(Box<DocumentFile>),
    #[holder(use_place_holder)]
    DocumentRelationship(Box<DocumentRelationship>),
    #[holder(use_place_holder)]
    Effectivity(EffectivityAny),
    #[holder(use_place_holder)]
    EventOccurrenceRelationship(Box<EventOccurrenceRelationship>),
    #[holder(use_place_holder)]
    ExecutedAction(ExecutedActionAny),
    #[holder(use_place_holder)]
    GeneralProperty(GeneralPropertyAny),
    #[holder(use_place_holder)]
    GeneralPropertyRelationship(GeneralPropertyRelationshipAny),
    #[holder(use_place_holder)]
    Group(GroupAny),
    #[holder(use_place_holder)]
    GroupRelationship(Box<GroupRelationship>),
    #[holder(use_place_holder)]
    InformationRight(Box<InformationRight>),
    #[holder(use_place_holder)]
    InformationUsageRight(Box<InformationUsageRight>),
    #[holder(use_place_holder)]
    Language(Box<Language>),
    #[holder(use_place_holder)]
    MeasureRepresentationItem(Box<MeasureRepresentationItem>),
    #[holder(use_place_holder)]
    MeasureWithUnit(MeasureWithUnitAny),
    #[holder(use_place_holder)]
    NamedUnit(NamedUnitAny),
    #[holder(use_place_holder)]
    OrganizationRelationship(Box<OrganizationRelationship>),
    #[holder(use_place_holder)]
    OrganizationalAddress(OrganizationalAddressAny),
    #[holder(use_place_holder)]
    OrganizationalProjectRelationship(Box<OrganizationalProjectRelationship>),
    #[holder(use_place_holder)]
    PersonAndOrganization(Box<PersonAndOrganization>),
    #[holder(use_place_holder)]
    PersonAndOrganizationAddress(Box<PersonAndOrganizationAddress>),
    #[holder(use_place_holder)]
    Product(Box<Product>),
    #[holder(use_place_holder)]
    ProductCategory(ProductCategoryAny),
    #[holder(use_place_holder)]
    ProductConcept(ProductConceptAny),
    #[holder(use_place_holder)]
    ProductConceptContext(Box<ProductConceptContext>),
    #[holder(use_place_holder)]
    ProductDefinition(ProductDefinitionAny),
    #[holder(use_place_holder)]
    ProductDefinitionContext(ProductDefinitionContextAny),
    #[holder(use_place_holder)]
    ProductDefinitionFormation(ProductDefinitionFormationAny),
    #[holder(use_place_holder)]
    ProductDefinitionFormationRelationship(Box<ProductDefinitionFormationRelationship>),
    #[holder(use_place_holder)]
    ProductDefinitionRelationship(ProductDefinitionRelationshipAny),
    #[holder(use_place_holder)]
    PropertyDefinition(PropertyDefinitionAny),
    #[holder(use_place_holder)]
    PropertyDefinitionRelationship(Box<PropertyDefinitionRelationship>),
    #[holder(use_place_holder)]
    PropertyDefinitionRepresentation(PropertyDefinitionRepresentationAny),
    #[holder(use_place_holder)]
    Representation(RepresentationAny),
    #[holder(use_place_holder)]
    RepresentationContext(RepresentationContextAny),
    #[holder(use_place_holder)]
    RepresentationItem(RepresentationItemAny),
    #[holder(use_place_holder)]
    SecurityClassification(Box<SecurityClassification>),
    #[holder(use_place_holder)]
    TimeIntervalRelationship(Box<TimeIntervalRelationship>),
    #[holder(use_place_holder)]
    UncertaintyMeasureWithUnit(Box<UncertaintyMeasureWithUnit>),
    #[holder(use_place_holder)]
    UsageAssociation(Box<UsageAssociation>),
    #[holder(use_place_holder)]
    VersionedActionRequest(Box<VersionedActionRequest>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum AttributeLanguageItem {
    #[holder(use_place_holder)]
    AlternateProductRelationship(Box<AlternateProductRelationship>),
    #[holder(use_place_holder)]
    ApplicationContext(Box<ApplicationContext>),
    #[holder(use_place_holder)]
    AppliedCertificationAssignment(Box<AppliedCertificationAssignment>),
    #[holder(use_place_holder)]
    AppliedDocumentReference(Box<AppliedDocumentReference>),
    #[holder(use_place_holder)]
    AppliedDocumentUsageConstraintAssignment(AppliedDocumentUsageConstraintAssignmentAny),
    #[holder(use_place_holder)]
    AppliedExternalIdentificationAssignment(Box<AppliedExternalIdentificationAssignment>),
    #[holder(use_place_holder)]
    AppliedIdentificationAssignment(Box<AppliedIdentificationAssignment>),
    #[holder(use_place_holder)]
    AppliedOrganizationalProjectAssignment(Box<AppliedOrganizationalProjectAssignment>),
    #[holder(use_place_holder)]
    AppliedSecurityClassificationAssignment(Box<AppliedSecurityClassificationAssignment>),
    #[holder(use_place_holder)]
    Approval(Box<Approval>),
    #[holder(use_place_holder)]
    ApprovalRelationship(Box<ApprovalRelationship>),
    #[holder(use_place_holder)]
    ApprovalStatus(Box<ApprovalStatus>),
    #[holder(use_place_holder)]
    AssemblyComponentUsageSubstitute(Box<AssemblyComponentUsageSubstitute>),
    #[holder(use_place_holder)]
    AttributeValueAssignment(AttributeValueAssignmentAny),
    #[holder(use_place_holder)]
    Certification(Box<Certification>),
    #[holder(use_place_holder)]
    CertificationType(Box<CertificationType>),
    #[holder(use_place_holder)]
    ConfigurationDesign(Box<ConfigurationDesign>),
    #[holder(use_place_holder)]
    ConfigurationItem(ConfigurationItemAny),
    #[holder(use_place_holder)]
    Contract(Box<Contract>),
    #[holder(use_place_holder)]
    DateRole(Box<DateRole>),
    #[holder(use_place_holder)]
    DateTimeRole(Box<DateTimeRole>),
    #[holder(use_place_holder)]
    DescriptiveRepresentationItem(DescriptiveRepresentationItemAny),
    #[holder(use_place_holder)]
    DocumentRelationship(Box<DocumentRelationship>),
    #[holder(use_place_holder)]
    DocumentUsageRole(Box<DocumentUsageRole>),
    #[holder(use_place_holder)]
    Effectivity(EffectivityAny),
    #[holder(use_place_holder)]
    EffectivityRelationship(Box<EffectivityRelationship>),
    #[holder(use_place_holder)]
    EventOccurrence(EventOccurrenceAny),
    #[holder(use_place_holder)]
    ExternalSource(ExternalSourceAny),
    #[holder(use_place_holder)]
    GeneralProperty(GeneralPropertyAny),
    #[holder(use_place_holder)]
    GeneralPropertyRelationship(GeneralPropertyRelationshipAny),
    #[holder(use_place_holder)]
    GeometricRepresentationItem(GeometricRepresentationItemAny),
    #[holder(use_place_holder)]
    GeometricTolerance(GeometricToleranceAny),
    #[holder(use_place_holder)]
    IdentificationRole(Box<IdentificationRole>),
    #[holder(use_place_holder)]
    InformationRight(Box<InformationRight>),
    #[holder(use_place_holder)]
    InformationUsageRight(Box<InformationUsageRight>),
    #[holder(use_place_holder)]
    MakeFromUsageOption(Box<MakeFromUsageOption>),
    #[holder(use_place_holder)]
    MappedItem(MappedItemAny),
    #[holder(use_place_holder)]
    MultiLanguageAttributeAssignment(Box<MultiLanguageAttributeAssignment>),
    #[holder(use_place_holder)]
    ObjectRole(Box<ObjectRole>),
    #[holder(use_place_holder)]
    OrganizationRelationship(Box<OrganizationRelationship>),
    #[holder(use_place_holder)]
    OrganizationRole(Box<OrganizationRole>),
    #[holder(use_place_holder)]
    OrganizationalProject(Box<OrganizationalProject>),
    #[holder(use_place_holder)]
    OrganizationalProjectRelationship(Box<OrganizationalProjectRelationship>),
    #[holder(use_place_holder)]
    OrganizationalProjectRole(Box<OrganizationalProjectRole>),
    #[holder(use_place_holder)]
    PersonAndOrganization(Box<PersonAndOrganization>),
    #[holder(use_place_holder)]
    PersonAndOrganizationRole(Box<PersonAndOrganizationRole>),
    #[holder(use_place_holder)]
    Product(Box<Product>),
    #[holder(use_place_holder)]
    ProductConcept(ProductConceptAny),
    #[holder(use_place_holder)]
    ProductConceptRelationship(Box<ProductConceptRelationship>),
    #[holder(use_place_holder)]
    ProductDefinition(ProductDefinitionAny),
    #[holder(use_place_holder)]
    ProductDefinitionContext(ProductDefinitionContextAny),
    #[holder(use_place_holder)]
    ProductDefinitionFormation(ProductDefinitionFormationAny),
    #[holder(use_place_holder)]
    ProductDefinitionFormationRelationship(Box<ProductDefinitionFormationRelationship>),
    #[holder(use_place_holder)]
    ProductDefinitionRelationship(ProductDefinitionRelationshipAny),
    #[holder(use_place_holder)]
    ProductDefinitionShape(Box<ProductDefinitionShape>),
    #[holder(use_place_holder)]
    ProductRelatedProductCategory(Box<ProductRelatedProductCategory>),
    #[holder(use_place_holder)]
    PropertyDefinition(PropertyDefinitionAny),
    #[holder(use_place_holder)]
    Representation(RepresentationAny),
    #[holder(use_place_holder)]
    SecurityClassification(Box<SecurityClassification>),
    #[holder(use_place_holder)]
    SecurityClassificationAssignment(SecurityClassificationAssignmentAny),
    #[holder(use_place_holder)]
    ShapeAspect(ShapeAspectAny),
    #[holder(use_place_holder)]
    ShapeAspectRelationship(ShapeAspectRelationshipAny),
    #[holder(use_place_holder)]
    ShapeRepresentation(ShapeRepresentationAny),
    #[holder(use_place_holder)]
    TimeIntervalRole(Box<TimeIntervalRole>),
    #[holder(use_place_holder)]
    TopologicalRepresentationItem(TopologicalRepresentationItemAny),
    #[holder(use_place_holder)]
    UncertaintyMeasureWithUnit(Box<UncertaintyMeasureWithUnit>),
    #[holder(use_place_holder)]
    UncertaintyQualifier(UncertaintyQualifierAny),
    #[holder(use_place_holder)]
    UsageAssociation(Box<UsageAssociation>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum AttributeType {
    #[holder(use_place_holder)]
    Label(Box<Label>),
    #[holder(use_place_holder)]
    Text(Box<Text>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum Axis2Placement {
    #[holder(use_place_holder)]
    Axis2Placement2D(Box<Axis2Placement2D>),
    #[holder(use_place_holder)]
    Axis2Placement3D(Box<Axis2Placement3D>),
}
#[derive(Debug, Clone, PartialEq, :: ruststep_derive :: ToData, :: serde :: Deserialize)]
pub enum BSplineCurveForm {
    PolylineForm,
    CircularArc,
    EllipticArc,
    ParabolicArc,
    HyperbolicArc,
    Unspecified,
}
#[derive(Debug, Clone, PartialEq, :: ruststep_derive :: ToData, :: serde :: Deserialize)]
pub enum BSplineSurfaceForm {
    PlaneSurf,
    CylindricalSurf,
    ConicalSurf,
    SphericalSurf,
    ToroidalSurf,
    SurfOfRevolution,
    RuledSurf,
    GeneralisedCone,
    QuadricSurf,
    SurfOfLinearExtrusion,
    Unspecified,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum BaseSolidSelect {
    #[holder(use_place_holder)]
    SolidModel(SolidModelAny),
    #[holder(use_place_holder)]
    CsgPrimitive(Box<CsgPrimitive>),
    #[holder(use_place_holder)]
    BooleanResult(Box<BooleanResult>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum BlendEndConditionSelect {
    #[holder(use_place_holder)]
    PointOnCurve(Box<PointOnCurve>),
    #[holder(use_place_holder)]
    EdgeCurve(Box<EdgeCurve>),
    #[holder(use_place_holder)]
    Vertex(VertexAny),
}
#[derive(Debug, Clone, PartialEq, :: ruststep_derive :: ToData, :: serde :: Deserialize)]
pub enum BlendRadiusVariationType {
    LinearBlend,
    CubicBlend,
    UnspecifiedBlend,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum BooleanOperand {
    #[holder(use_place_holder)]
    SolidModel(SolidModelAny),
    #[holder(use_place_holder)]
    HalfSpaceSolid(HalfSpaceSolidAny),
    #[holder(use_place_holder)]
    CsgPrimitive(Box<CsgPrimitive>),
    #[holder(use_place_holder)]
    BooleanResult(Box<BooleanResult>),
}
#[derive(Debug, Clone, PartialEq, :: ruststep_derive :: ToData, :: serde :: Deserialize)]
pub enum BooleanOperator {
    Union,
    Intersection,
    Difference,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum BoxCharacteristicSelect {
    #[holder(use_place_holder)]
    BoxHeight(Box<BoxHeight>),
    #[holder(use_place_holder)]
    BoxWidth(Box<BoxWidth>),
    #[holder(use_place_holder)]
    BoxSlantAngle(Box<BoxSlantAngle>),
    #[holder(use_place_holder)]
    BoxRotateAngle(Box<BoxRotateAngle>),
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = box_height)]
#[holder(generate_deserialize)]
# [holder (inner = PositiveRatioMeasure)]
pub struct BoxHeight(#[holder(use_place_holder)] pub PositiveRatioMeasure);
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = box_rotate_angle)]
#[holder(generate_deserialize)]
# [holder (inner = PlaneAngleMeasure)]
pub struct BoxRotateAngle(#[holder(use_place_holder)] pub PlaneAngleMeasure);
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = box_slant_angle)]
#[holder(generate_deserialize)]
# [holder (inner = PlaneAngleMeasure)]
pub struct BoxSlantAngle(#[holder(use_place_holder)] pub PlaneAngleMeasure);
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = box_width)]
#[holder(generate_deserialize)]
# [holder (inner = PositiveRatioMeasure)]
pub struct BoxWidth(#[holder(use_place_holder)] pub PositiveRatioMeasure);
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CameraModelD3MultiClippingInterectionSelect {
    #[holder(use_place_holder)]
    CameraModelD3MultiClippingUnion(Box<CameraModelD3MultiClippingUnion>),
    #[holder(use_place_holder)]
    Plane(Box<Plane>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CameraModelD3MultiClippingUnionSelect {
    #[holder(use_place_holder)]
    CameraModelD3MultiClippingIntersection(Box<CameraModelD3MultiClippingIntersection>),
    #[holder(use_place_holder)]
    Plane(Box<Plane>),
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = capacitance_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct CapacitanceMeasure(pub f64);
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CategoryUsageItem {
    #[holder(use_place_holder)]
    ProductClass(Box<ProductClass>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CcClassifiedItem {
    #[holder(use_place_holder)]
    AssemblyComponentUsage(AssemblyComponentUsageAny),
    #[holder(use_place_holder)]
    ProductDefinitionFormation(ProductDefinitionFormationAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CcPersonOrganizationItem {
    #[holder(use_place_holder)]
    Change(Box<Change>),
    #[holder(use_place_holder)]
    ChangeRequest(Box<ChangeRequest>),
    #[holder(use_place_holder)]
    ConfigurationItem(ConfigurationItemAny),
    #[holder(use_place_holder)]
    Contract(Box<Contract>),
    #[holder(use_place_holder)]
    Product(Box<Product>),
    #[holder(use_place_holder)]
    ProductDefinition(ProductDefinitionAny),
    #[holder(use_place_holder)]
    ProductDefinitionFormation(ProductDefinitionFormationAny),
    #[holder(use_place_holder)]
    SecurityClassification(Box<SecurityClassification>),
    #[holder(use_place_holder)]
    StartRequest(Box<StartRequest>),
    #[holder(use_place_holder)]
    StartWork(Box<StartWork>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CcSpecifiedItem {
    #[holder(use_place_holder)]
    ProductDefinition(ProductDefinitionAny),
    #[holder(use_place_holder)]
    ShapeAspect(ShapeAspectAny),
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = celsius_temperature_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct CelsiusTemperatureMeasure(pub f64);
#[derive(Debug, Clone, PartialEq, :: ruststep_derive :: ToData, :: serde :: Deserialize)]
pub enum CentralOrParallel {
    Central,
    Parallel,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CertificationItem {
    #[holder(use_place_holder)]
    AlternateProductRelationship(Box<AlternateProductRelationship>),
    #[holder(use_place_holder)]
    MakeFromUsageOption(Box<MakeFromUsageOption>),
    #[holder(use_place_holder)]
    ProductDefinitionFormation(ProductDefinitionFormationAny),
    #[holder(use_place_holder)]
    ProductDefinitionFormationRelationship(Box<ProductDefinitionFormationRelationship>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CertifiedItem {
    #[holder(use_place_holder)]
    SuppliedPartRelationship(Box<SuppliedPartRelationship>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ChangeRequestItem {
    #[holder(use_place_holder)]
    ProductDefinitionFormation(ProductDefinitionFormationAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CharacterSpacingSelect {
    #[holder(use_place_holder)]
    LengthMeasure(Box<LengthMeasure>),
    #[holder(use_place_holder)]
    RatioMeasure(Box<RatioMeasure>),
    #[holder(use_place_holder)]
    MeasureWithUnit(MeasureWithUnitAny),
    #[holder(use_place_holder)]
    DescriptiveMeasure(Box<DescriptiveMeasure>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CharacterStyleSelect {
    #[holder(use_place_holder)]
    CharacterGlyphStyleStroke(Box<CharacterGlyphStyleStroke>),
    #[holder(use_place_holder)]
    CharacterGlyphStyleOutline(Box<CharacterGlyphStyleOutline>),
    #[holder(use_place_holder)]
    TextStyleForDefinedFont(Box<TextStyleForDefinedFont>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CharacterizedActionDefinition {
    #[holder(use_place_holder)]
    Action(ActionAny),
    #[holder(use_place_holder)]
    ActionMethod(ActionMethodAny),
    #[holder(use_place_holder)]
    ActionMethodRelationship(ActionMethodRelationshipAny),
    #[holder(use_place_holder)]
    ActionRelationship(Box<ActionRelationship>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CharacterizedDefinition {
    #[holder(use_place_holder)]
    CharacterizedObject(CharacterizedObjectAny),
    #[holder(use_place_holder)]
    CharacterizedProductDefinition(Box<CharacterizedProductDefinition>),
    #[holder(use_place_holder)]
    ShapeDefinition(Box<ShapeDefinition>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CharacterizedMaterialProperty {
    #[holder(use_place_holder)]
    MaterialPropertyRepresentation(Box<MaterialPropertyRepresentation>),
    #[holder(use_place_holder)]
    ProductMaterialCompositionRelationship(Box<ProductMaterialCompositionRelationship>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CharacterizedProductCompositionValue {
    #[holder(use_place_holder)]
    MeasureWithUnit(MeasureWithUnitAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CharacterizedProductDefinition {
    #[holder(use_place_holder)]
    ProductDefinition(ProductDefinitionAny),
    #[holder(use_place_holder)]
    ProductDefinitionRelationship(ProductDefinitionRelationshipAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ClassUsageEffectivityContextItem {
    #[holder(use_place_holder)]
    ProductDefinition(ProductDefinitionAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ClassificationItem {
    #[holder(use_place_holder)]
    Action(ActionAny),
    #[holder(use_place_holder)]
    ActionDirective(Box<ActionDirective>),
    #[holder(use_place_holder)]
    ActionMethod(ActionMethodAny),
    #[holder(use_place_holder)]
    ActionProperty(Box<ActionProperty>),
    #[holder(use_place_holder)]
    ActionRelationship(Box<ActionRelationship>),
    #[holder(use_place_holder)]
    ActionRequestSolution(Box<ActionRequestSolution>),
    #[holder(use_place_holder)]
    ActionRequestStatus(Box<ActionRequestStatus>),
    #[holder(use_place_holder)]
    Address(AddressAny),
    #[holder(use_place_holder)]
    AlternateProductRelationship(Box<AlternateProductRelationship>),
    #[holder(use_place_holder)]
    AppliedActionAssignment(AppliedActionAssignmentAny),
    #[holder(use_place_holder)]
    AppliedActionRequestAssignment(Box<AppliedActionRequestAssignment>),
    #[holder(use_place_holder)]
    AppliedApprovalAssignment(Box<AppliedApprovalAssignment>),
    #[holder(use_place_holder)]
    AppliedCertificationAssignment(Box<AppliedCertificationAssignment>),
    #[holder(use_place_holder)]
    AppliedContractAssignment(Box<AppliedContractAssignment>),
    #[holder(use_place_holder)]
    AppliedDateAndTimeAssignment(Box<AppliedDateAndTimeAssignment>),
    #[holder(use_place_holder)]
    AppliedDateAssignment(Box<AppliedDateAssignment>),
    #[holder(use_place_holder)]
    AppliedDocumentReference(Box<AppliedDocumentReference>),
    #[holder(use_place_holder)]
    AppliedDocumentUsageConstraintAssignment(AppliedDocumentUsageConstraintAssignmentAny),
    #[holder(use_place_holder)]
    AppliedEffectivityAssignment(Box<AppliedEffectivityAssignment>),
    #[holder(use_place_holder)]
    AppliedEventOccurrenceAssignment(Box<AppliedEventOccurrenceAssignment>),
    #[holder(use_place_holder)]
    AppliedExternalIdentificationAssignment(Box<AppliedExternalIdentificationAssignment>),
    #[holder(use_place_holder)]
    AppliedIdentificationAssignment(Box<AppliedIdentificationAssignment>),
    #[holder(use_place_holder)]
    AppliedOrganizationAssignment(Box<AppliedOrganizationAssignment>),
    #[holder(use_place_holder)]
    AppliedOrganizationalProjectAssignment(Box<AppliedOrganizationalProjectAssignment>),
    #[holder(use_place_holder)]
    AppliedPersonAndOrganizationAssignment(Box<AppliedPersonAndOrganizationAssignment>),
    #[holder(use_place_holder)]
    AppliedSecurityClassificationAssignment(Box<AppliedSecurityClassificationAssignment>),
    #[holder(use_place_holder)]
    Approval(Box<Approval>),
    #[holder(use_place_holder)]
    ApprovalPersonOrganization(Box<ApprovalPersonOrganization>),
    #[holder(use_place_holder)]
    ApprovalRelationship(Box<ApprovalRelationship>),
    #[holder(use_place_holder)]
    ApprovalStatus(Box<ApprovalStatus>),
    #[holder(use_place_holder)]
    AssemblyComponentUsageSubstitute(Box<AssemblyComponentUsageSubstitute>),
    #[holder(use_place_holder)]
    CalendarDate(Box<CalendarDate>),
    #[holder(use_place_holder)]
    Certification(Box<Certification>),
    #[holder(use_place_holder)]
    CharacterizedClass(Box<CharacterizedClass>),
    #[holder(use_place_holder)]
    CharacterizedObject(CharacterizedObjectAny),
    #[holder(use_place_holder)]
    Class(ClassAny),
    #[holder(use_place_holder)]
    ClassifiedItem(Box<ClassifiedItem>),
    #[holder(use_place_holder)]
    ConfigurationItem(ConfigurationItemAny),
    #[holder(use_place_holder)]
    ContextDependentUnit(ContextDependentUnitAny),
    #[holder(use_place_holder)]
    Contract(Box<Contract>),
    #[holder(use_place_holder)]
    ConversionBasedUnit(ConversionBasedUnitAny),
    #[holder(use_place_holder)]
    DateAndTime(DateAndTimeAny),
    #[holder(use_place_holder)]
    DateAndTimeAssignment(DateAndTimeAssignmentAny),
    #[holder(use_place_holder)]
    DateAssignment(DateAssignmentAny),
    #[holder(use_place_holder)]
    DerivedUnit(DerivedUnitAny),
    #[holder(use_place_holder)]
    DescriptiveRepresentationItem(DescriptiveRepresentationItemAny),
    #[holder(use_place_holder)]
    DirectedAction(Box<DirectedAction>),
    #[holder(use_place_holder)]
    DocumentFile(Box<DocumentFile>),
    #[holder(use_place_holder)]
    DocumentRelationship(Box<DocumentRelationship>),
    #[holder(use_place_holder)]
    Effectivity(EffectivityAny),
    #[holder(use_place_holder)]
    EventOccurrence(EventOccurrenceAny),
    #[holder(use_place_holder)]
    ExecutedAction(ExecutedActionAny),
    #[holder(use_place_holder)]
    GeneralProperty(GeneralPropertyAny),
    #[holder(use_place_holder)]
    GeneralPropertyRelationship(GeneralPropertyRelationshipAny),
    #[holder(use_place_holder)]
    Group(GroupAny),
    #[holder(use_place_holder)]
    IdentificationAssignment(IdentificationAssignmentAny),
    #[holder(use_place_holder)]
    InformationRight(Box<InformationRight>),
    #[holder(use_place_holder)]
    InformationUsageRight(Box<InformationUsageRight>),
    #[holder(use_place_holder)]
    Language(Box<Language>),
    #[holder(use_place_holder)]
    MeasureRepresentationItem(Box<MeasureRepresentationItem>),
    #[holder(use_place_holder)]
    MeasureWithUnit(MeasureWithUnitAny),
    #[holder(use_place_holder)]
    MultiLanguageAttributeAssignment(Box<MultiLanguageAttributeAssignment>),
    #[holder(use_place_holder)]
    NamedUnit(NamedUnitAny),
    #[holder(use_place_holder)]
    Organization(Box<Organization>),
    #[holder(use_place_holder)]
    OrganizationRelationship(Box<OrganizationRelationship>),
    #[holder(use_place_holder)]
    OrganizationalAddress(OrganizationalAddressAny),
    #[holder(use_place_holder)]
    OrganizationalProject(Box<OrganizationalProject>),
    #[holder(use_place_holder)]
    OrganizationalProjectRelationship(Box<OrganizationalProjectRelationship>),
    #[holder(use_place_holder)]
    Person(Box<Person>),
    #[holder(use_place_holder)]
    PersonAndOrganizationAddress(Box<PersonAndOrganizationAddress>),
    #[holder(use_place_holder)]
    Product(Box<Product>),
    #[holder(use_place_holder)]
    ProductConcept(ProductConceptAny),
    #[holder(use_place_holder)]
    ProductDefinition(ProductDefinitionAny),
    #[holder(use_place_holder)]
    ProductDefinitionContext(ProductDefinitionContextAny),
    #[holder(use_place_holder)]
    ProductDefinitionFormation(ProductDefinitionFormationAny),
    #[holder(use_place_holder)]
    ProductDefinitionFormationRelationship(Box<ProductDefinitionFormationRelationship>),
    #[holder(use_place_holder)]
    ProductDefinitionRelationship(ProductDefinitionRelationshipAny),
    #[holder(use_place_holder)]
    PropertyDefinition(PropertyDefinitionAny),
    #[holder(use_place_holder)]
    PropertyDefinitionRepresentation(PropertyDefinitionRepresentationAny),
    #[holder(use_place_holder)]
    Representation(RepresentationAny),
    #[holder(use_place_holder)]
    RepresentationContext(RepresentationContextAny),
    #[holder(use_place_holder)]
    RepresentationItem(RepresentationItemAny),
    #[holder(use_place_holder)]
    SecurityClassification(Box<SecurityClassification>),
    #[holder(use_place_holder)]
    UncertaintyMeasureWithUnit(Box<UncertaintyMeasureWithUnit>),
    #[holder(use_place_holder)]
    UsageAssociation(Box<UsageAssociation>),
    #[holder(use_place_holder)]
    VersionedActionRequest(Box<VersionedActionRequest>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ClassifiedItem {
    #[holder(use_place_holder)]
    Product(Box<Product>),
    #[holder(use_place_holder)]
    ProductDefinition(ProductDefinitionAny),
    #[holder(use_place_holder)]
    ProductDefinitionFormation(ProductDefinitionFormationAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CompoundItemDefinition {
    #[holder(use_place_holder)]
    ListRepresentationItem(Box<ListRepresentationItem>),
    #[holder(use_place_holder)]
    SetRepresentationItem(Box<SetRepresentationItem>),
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = conductance_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct ConductanceMeasure(pub f64);
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ConfigurationDesignItem {
    #[holder(use_place_holder)]
    ProductDefinition(ProductDefinitionAny),
    #[holder(use_place_holder)]
    ProductDefinitionFormation(ProductDefinitionFormationAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ConfiguredEffectivityContextItem {
    #[holder(use_place_holder)]
    ProductConceptFeatureAssociation(Box<ProductConceptFeatureAssociation>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ConfiguredEffectivityItem {
    #[holder(use_place_holder)]
    ProductDefinition(ProductDefinitionAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ConstructiveGeometryRepresentationOrShapeRepresenation {
    #[holder(use_place_holder)]
    ConstructiveGeometryRepresentation(Box<ConstructiveGeometryRepresentation>),
    #[holder(use_place_holder)]
    ShapeRepresentation(ShapeRepresentationAny),
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = context_dependent_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct ContextDependentMeasure(pub f64);
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ContractItem {
    #[holder(use_place_holder)]
    ActionDirective(Box<ActionDirective>),
    #[holder(use_place_holder)]
    AlternateProductRelationship(Box<AlternateProductRelationship>),
    #[holder(use_place_holder)]
    DirectedAction(Box<DirectedAction>),
    #[holder(use_place_holder)]
    ExecutedAction(ExecutedActionAny),
    #[holder(use_place_holder)]
    InformationUsageRight(Box<InformationUsageRight>),
    #[holder(use_place_holder)]
    Organization(Box<Organization>),
    #[holder(use_place_holder)]
    PersonAndOrganization(Box<PersonAndOrganization>),
    #[holder(use_place_holder)]
    Product(Box<Product>),
    #[holder(use_place_holder)]
    ProductDefinitionFormation(ProductDefinitionFormationAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ContractedItem {
    #[holder(use_place_holder)]
    ProductDefinitionFormation(ProductDefinitionFormationAny),
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = count_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct CountMeasure(pub f64);
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CsgPrimitive {
    #[holder(use_place_holder)]
    Sphere(Box<Sphere>),
    #[holder(use_place_holder)]
    Block(Box<Block>),
    #[holder(use_place_holder)]
    RightAngularWedge(Box<RightAngularWedge>),
    #[holder(use_place_holder)]
    Torus(Box<Torus>),
    #[holder(use_place_holder)]
    RightCircularCone(Box<RightCircularCone>),
    #[holder(use_place_holder)]
    RightCircularCylinder(Box<RightCircularCylinder>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CsgSelect {
    #[holder(use_place_holder)]
    BooleanResult(Box<BooleanResult>),
    #[holder(use_place_holder)]
    CsgPrimitive(Box<CsgPrimitive>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CurveFontOrScaledCurveFontSelect {
    #[holder(use_place_holder)]
    CurveStyleFontSelect(Box<CurveStyleFontSelect>),
    #[holder(use_place_holder)]
    CurveStyleFontAndScaling(Box<CurveStyleFontAndScaling>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CurveOnSurface {
    #[holder(use_place_holder)]
    Pcurve(PcurveAny),
    #[holder(use_place_holder)]
    SurfaceCurve(SurfaceCurveAny),
    #[holder(use_place_holder)]
    CompositeCurveOnSurface(CompositeCurveOnSurfaceAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CurveOrAnnotationCurveOccurrence {
    #[holder(use_place_holder)]
    Curve(CurveAny),
    #[holder(use_place_holder)]
    AnnotationCurveOccurrence(AnnotationCurveOccurrenceAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CurveOrRender {
    #[holder(use_place_holder)]
    CurveStyle(CurveStyleAny),
    #[holder(use_place_holder)]
    CurveStyleRendering(Box<CurveStyleRendering>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CurveStyleFontSelect {
    #[holder(use_place_holder)]
    CurveStyleFont(CurveStyleFontAny),
    #[holder(use_place_holder)]
    PreDefinedCurveFont(PreDefinedCurveFontAny),
    #[holder(use_place_holder)]
    ExternallyDefinedCurveFont(Box<ExternallyDefinedCurveFont>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DateAndTimeItem {
    #[holder(use_place_holder)]
    Action(ActionAny),
    #[holder(use_place_holder)]
    ActionDirective(Box<ActionDirective>),
    #[holder(use_place_holder)]
    AppliedActionAssignment(AppliedActionAssignmentAny),
    #[holder(use_place_holder)]
    AppliedOrganizationAssignment(Box<AppliedOrganizationAssignment>),
    #[holder(use_place_holder)]
    AppliedPersonAndOrganizationAssignment(Box<AppliedPersonAndOrganizationAssignment>),
    #[holder(use_place_holder)]
    AppliedSecurityClassificationAssignment(Box<AppliedSecurityClassificationAssignment>),
    #[holder(use_place_holder)]
    ApprovalPersonOrganization(Box<ApprovalPersonOrganization>),
    #[holder(use_place_holder)]
    Certification(Box<Certification>),
    #[holder(use_place_holder)]
    Contract(Box<Contract>),
    #[holder(use_place_holder)]
    DirectedAction(Box<DirectedAction>),
    #[holder(use_place_holder)]
    Document(DocumentAny),
    #[holder(use_place_holder)]
    DocumentFile(Box<DocumentFile>),
    #[holder(use_place_holder)]
    EventOccurrence(EventOccurrenceAny),
    #[holder(use_place_holder)]
    ExecutedAction(ExecutedActionAny),
    #[holder(use_place_holder)]
    InformationUsageRight(Box<InformationUsageRight>),
    #[holder(use_place_holder)]
    OrganizationalProject(Box<OrganizationalProject>),
    #[holder(use_place_holder)]
    ProductDefinition(ProductDefinitionAny),
    #[holder(use_place_holder)]
    ProductDefinitionFormation(ProductDefinitionFormationAny),
    #[holder(use_place_holder)]
    ProductDefinitionRelationship(ProductDefinitionRelationshipAny),
    #[holder(use_place_holder)]
    RuleAction(RuleActionAny),
    #[holder(use_place_holder)]
    SecurityClassification(Box<SecurityClassification>),
    #[holder(use_place_holder)]
    VersionedActionRequest(Box<VersionedActionRequest>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DateItem {
    #[holder(use_place_holder)]
    Action(ActionAny),
    #[holder(use_place_holder)]
    ActionDirective(Box<ActionDirective>),
    #[holder(use_place_holder)]
    AppliedActionAssignment(AppliedActionAssignmentAny),
    #[holder(use_place_holder)]
    AppliedOrganizationAssignment(Box<AppliedOrganizationAssignment>),
    #[holder(use_place_holder)]
    AppliedPersonAndOrganizationAssignment(Box<AppliedPersonAndOrganizationAssignment>),
    #[holder(use_place_holder)]
    AppliedSecurityClassificationAssignment(Box<AppliedSecurityClassificationAssignment>),
    #[holder(use_place_holder)]
    ApprovalPersonOrganization(Box<ApprovalPersonOrganization>),
    #[holder(use_place_holder)]
    Certification(Box<Certification>),
    #[holder(use_place_holder)]
    Contract(Box<Contract>),
    #[holder(use_place_holder)]
    DirectedAction(Box<DirectedAction>),
    #[holder(use_place_holder)]
    Document(DocumentAny),
    #[holder(use_place_holder)]
    DocumentFile(Box<DocumentFile>),
    #[holder(use_place_holder)]
    EventOccurrence(EventOccurrenceAny),
    #[holder(use_place_holder)]
    ExecutedAction(ExecutedActionAny),
    #[holder(use_place_holder)]
    InformationUsageRight(Box<InformationUsageRight>),
    #[holder(use_place_holder)]
    OrganizationalProject(Box<OrganizationalProject>),
    #[holder(use_place_holder)]
    ProductDefinition(ProductDefinitionAny),
    #[holder(use_place_holder)]
    ProductDefinitionFormation(ProductDefinitionFormationAny),
    #[holder(use_place_holder)]
    ProductDefinitionRelationship(ProductDefinitionRelationshipAny),
    #[holder(use_place_holder)]
    SecurityClassification(Box<SecurityClassification>),
    #[holder(use_place_holder)]
    VersionedActionRequest(Box<VersionedActionRequest>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DateTimeItem {
    #[holder(use_place_holder)]
    ApprovalPersonOrganization(Box<ApprovalPersonOrganization>),
    #[holder(use_place_holder)]
    Certification(Box<Certification>),
    #[holder(use_place_holder)]
    Change(Box<Change>),
    #[holder(use_place_holder)]
    ChangeRequest(Box<ChangeRequest>),
    #[holder(use_place_holder)]
    Contract(Box<Contract>),
    #[holder(use_place_holder)]
    ProductDefinition(ProductDefinitionAny),
    #[holder(use_place_holder)]
    SecurityClassification(Box<SecurityClassification>),
    #[holder(use_place_holder)]
    StartRequest(Box<StartRequest>),
    #[holder(use_place_holder)]
    StartWork(Box<StartWork>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DateTimeOrEventOccurrence {
    #[holder(use_place_holder)]
    DateTimeSelect(Box<DateTimeSelect>),
    #[holder(use_place_holder)]
    EventOccurrence(EventOccurrenceAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DateTimeSelect {
    #[holder(use_place_holder)]
    Date(DateAny),
    #[holder(use_place_holder)]
    DateAndTime(DateAndTimeAny),
    #[holder(use_place_holder)]
    LocalTime(Box<LocalTime>),
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = day_in_month_number)]
#[holder(generate_deserialize)]
# [holder (from = i64)]
pub struct DayInMonthNumber(pub i64);
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = day_in_week_number)]
#[holder(generate_deserialize)]
# [holder (from = i64)]
pub struct DayInWeekNumber(pub i64);
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = day_in_year_number)]
#[holder(generate_deserialize)]
# [holder (from = i64)]
pub struct DayInYearNumber(pub i64);
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DefinedSymbolSelect {
    #[holder(use_place_holder)]
    PreDefinedSymbol(PreDefinedSymbolAny),
    #[holder(use_place_holder)]
    ExternallyDefinedSymbol(ExternallyDefinedSymbolAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DerivedPropertySelect {
    #[holder(use_place_holder)]
    PropertyDefinition(PropertyDefinitionAny),
    #[holder(use_place_holder)]
    ActionProperty(Box<ActionProperty>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DescriptionAttributeSelect {
    #[holder(use_place_holder)]
    ActionRequestSolution(Box<ActionRequestSolution>),
    #[holder(use_place_holder)]
    ApplicationContext(Box<ApplicationContext>),
    #[holder(use_place_holder)]
    ApprovalRole(Box<ApprovalRole>),
    #[holder(use_place_holder)]
    ConfigurationDesign(Box<ConfigurationDesign>),
    #[holder(use_place_holder)]
    DateRole(Box<DateRole>),
    #[holder(use_place_holder)]
    DateTimeRole(Box<DateTimeRole>),
    #[holder(use_place_holder)]
    ContextDependentShapeRepresentation(Box<ContextDependentShapeRepresentation>),
    #[holder(use_place_holder)]
    Effectivity(EffectivityAny),
    #[holder(use_place_holder)]
    ExternalSource(ExternalSourceAny),
    #[holder(use_place_holder)]
    OrganizationRole(Box<OrganizationRole>),
    #[holder(use_place_holder)]
    PersonAndOrganizationRole(Box<PersonAndOrganizationRole>),
    #[holder(use_place_holder)]
    PersonAndOrganization(Box<PersonAndOrganization>),
    #[holder(use_place_holder)]
    PropertyDefinitionRepresentation(PropertyDefinitionRepresentationAny),
    #[holder(use_place_holder)]
    Representation(RepresentationAny),
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = descriptive_measure)]
#[holder(generate_deserialize)]
# [holder (from = String)]
pub struct DescriptiveMeasure(pub String);
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = dimension_count)]
#[holder(generate_deserialize)]
# [holder (from = i64)]
pub struct DimensionCount(pub i64);
#[derive(Debug, Clone, PartialEq, :: ruststep_derive :: ToData, :: serde :: Deserialize)]
pub enum DimensionExtentUsage {
    Origin,
    Target,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DimensionalCharacteristic {
    #[holder(use_place_holder)]
    DimensionalLocation(DimensionalLocationAny),
    #[holder(use_place_holder)]
    DimensionalSize(DimensionalSizeAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DirectionCountSelect {
    #[holder(use_place_holder)]
    UDirectionCount(Box<UDirectionCount>),
    #[holder(use_place_holder)]
    VDirectionCount(Box<VDirectionCount>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DocumentIdentifierAssignedItem {
    #[holder(use_place_holder)]
    Document(DocumentAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DocumentReferenceItem {
    #[holder(use_place_holder)]
    ActionMethod(ActionMethodAny),
    #[holder(use_place_holder)]
    AppliedExternalIdentificationAssignment(Box<AppliedExternalIdentificationAssignment>),
    #[holder(use_place_holder)]
    AssemblyComponentUsage(AssemblyComponentUsageAny),
    #[holder(use_place_holder)]
    CharacterizedClass(Box<CharacterizedClass>),
    #[holder(use_place_holder)]
    CharacterizedObject(CharacterizedObjectAny),
    #[holder(use_place_holder)]
    ConfigurationItem(ConfigurationItemAny),
    #[holder(use_place_holder)]
    DescriptiveRepresentationItem(DescriptiveRepresentationItemAny),
    #[holder(use_place_holder)]
    DimensionalSize(DimensionalSizeAny),
    #[holder(use_place_holder)]
    ExecutedAction(ExecutedActionAny),
    #[holder(use_place_holder)]
    ExternallyDefinedDimensionDefinition(Box<ExternallyDefinedDimensionDefinition>),
    #[holder(use_place_holder)]
    ExternallyDefinedItem(ExternallyDefinedItemAny),
    #[holder(use_place_holder)]
    Group(GroupAny),
    #[holder(use_place_holder)]
    GroupRelationship(Box<GroupRelationship>),
    #[holder(use_place_holder)]
    InformationRight(Box<InformationRight>),
    #[holder(use_place_holder)]
    InformationUsageRight(Box<InformationUsageRight>),
    #[holder(use_place_holder)]
    MaterialDesignation(MaterialDesignationAny),
    #[holder(use_place_holder)]
    MeasureRepresentationItem(Box<MeasureRepresentationItem>),
    #[holder(use_place_holder)]
    Product(Box<Product>),
    #[holder(use_place_holder)]
    ProductCategory(ProductCategoryAny),
    #[holder(use_place_holder)]
    ProductDefinition(ProductDefinitionAny),
    #[holder(use_place_holder)]
    ProductDefinitionFormation(ProductDefinitionFormationAny),
    #[holder(use_place_holder)]
    ProductDefinitionFormationRelationship(Box<ProductDefinitionFormationRelationship>),
    #[holder(use_place_holder)]
    ProductDefinitionRelationship(ProductDefinitionRelationshipAny),
    #[holder(use_place_holder)]
    PropertyDefinition(PropertyDefinitionAny),
    #[holder(use_place_holder)]
    Representation(RepresentationAny),
    #[holder(use_place_holder)]
    RepresentationItem(RepresentationItemAny),
    #[holder(use_place_holder)]
    RuleSet(Box<RuleSet>),
    #[holder(use_place_holder)]
    ShapeAspect(ShapeAspectAny),
    #[holder(use_place_holder)]
    ShapeAspectRelationship(ShapeAspectRelationshipAny),
    #[holder(use_place_holder)]
    UsageAssociation(Box<UsageAssociation>),
    #[holder(use_place_holder)]
    VersionedActionRequest(Box<VersionedActionRequest>),
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = dose_equivalent_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct DoseEquivalentMeasure(pub f64);
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DraughtingCalloutElement {
    #[holder(use_place_holder)]
    AnnotationTextOccurrence(Box<AnnotationTextOccurrence>),
    #[holder(use_place_holder)]
    AnnotationSymbolOccurrence(AnnotationSymbolOccurrenceAny),
    #[holder(use_place_holder)]
    AnnotationCurveOccurrence(AnnotationCurveOccurrenceAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DraughtingModelItemAssociationSelect {
    #[holder(use_place_holder)]
    AnnotationOccurrence(AnnotationOccurrenceAny),
    #[holder(use_place_holder)]
    DraughtingCallout(DraughtingCalloutAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DraughtingModelItemSelect {
    #[holder(use_place_holder)]
    MappedItem(MappedItemAny),
    #[holder(use_place_holder)]
    StyledItem(StyledItemAny),
    #[holder(use_place_holder)]
    Axis2Placement(Box<Axis2Placement>),
    #[holder(use_place_holder)]
    CameraModel(CameraModelAny),
    #[holder(use_place_holder)]
    DraughtingCallout(DraughtingCalloutAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DraughtingTitledItem {
    #[holder(use_place_holder)]
    DrawingRevision(Box<DrawingRevision>),
    #[holder(use_place_holder)]
    DrawingSheetRevision(Box<DrawingSheetRevision>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum EffectivityItem {
    #[holder(use_place_holder)]
    AssemblyComponentUsageSubstitute(Box<AssemblyComponentUsageSubstitute>),
    #[holder(use_place_holder)]
    Product(Box<Product>),
    #[holder(use_place_holder)]
    ProductDefinition(ProductDefinitionAny),
    #[holder(use_place_holder)]
    ProductDefinitionFormation(ProductDefinitionFormationAny),
    #[holder(use_place_holder)]
    ProductDefinitionRelationship(ProductDefinitionRelationshipAny),
    #[holder(use_place_holder)]
    ProductDefinitionSubstitute(Box<ProductDefinitionSubstitute>),
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = electric_charge_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct ElectricChargeMeasure(pub f64);
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = electric_current_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct ElectricCurrentMeasure(pub f64);
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = electric_potential_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct ElectricPotentialMeasure(pub f64);
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = energy_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct EnergyMeasure(pub f64);
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum EventOccurrenceItem {
    #[holder(use_place_holder)]
    OrganizationalProject(Box<OrganizationalProject>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ExternalIdentificationItem {
    #[holder(use_place_holder)]
    ActionRelationship(Box<ActionRelationship>),
    #[holder(use_place_holder)]
    ActionRequestStatus(Box<ActionRequestStatus>),
    #[holder(use_place_holder)]
    AppliedOrganizationAssignment(Box<AppliedOrganizationAssignment>),
    #[holder(use_place_holder)]
    AppliedPersonAndOrganizationAssignment(Box<AppliedPersonAndOrganizationAssignment>),
    #[holder(use_place_holder)]
    Approval(Box<Approval>),
    #[holder(use_place_holder)]
    ApprovalStatus(Box<ApprovalStatus>),
    #[holder(use_place_holder)]
    DateAndTimeAssignment(DateAndTimeAssignmentAny),
    #[holder(use_place_holder)]
    DateAssignment(DateAssignmentAny),
    #[holder(use_place_holder)]
    DocumentFile(Box<DocumentFile>),
    #[holder(use_place_holder)]
    ExternalSource(ExternalSourceAny),
    #[holder(use_place_holder)]
    ExternallyDefinedClass(Box<ExternallyDefinedClass>),
    #[holder(use_place_holder)]
    ExternallyDefinedContextDependentUnit(ExternallyDefinedContextDependentUnitAny),
    #[holder(use_place_holder)]
    ExternallyDefinedConversionBasedUnit(Box<ExternallyDefinedConversionBasedUnit>),
    #[holder(use_place_holder)]
    ExternallyDefinedGeneralProperty(Box<ExternallyDefinedGeneralProperty>),
    #[holder(use_place_holder)]
    ExternallyDefinedPictureRepresentationItem(Box<ExternallyDefinedPictureRepresentationItem>),
    #[holder(use_place_holder)]
    ExternallyDefinedRepresentationItem(ExternallyDefinedRepresentationItemAny),
    #[holder(use_place_holder)]
    OrganizationalAddress(OrganizationalAddressAny),
    #[holder(use_place_holder)]
    ProductDefinition(ProductDefinitionAny),
    #[holder(use_place_holder)]
    SecurityClassification(Box<SecurityClassification>),
    #[holder(use_place_holder)]
    TrimmedCurve(Box<TrimmedCurve>),
    #[holder(use_place_holder)]
    VersionedActionRequest(Box<VersionedActionRequest>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum FillAreaStyleTileShapeSelect {
    #[holder(use_place_holder)]
    FillAreaStyleTileCurveWithStyle(Box<FillAreaStyleTileCurveWithStyle>),
    #[holder(use_place_holder)]
    FillAreaStyleTileColouredRegion(Box<FillAreaStyleTileColouredRegion>),
    #[holder(use_place_holder)]
    FillAreaStyleTileSymbolWithStyle(Box<FillAreaStyleTileSymbolWithStyle>),
    #[holder(use_place_holder)]
    PreDefinedTile(Box<PreDefinedTile>),
    #[holder(use_place_holder)]
    ExternallyDefinedTile(Box<ExternallyDefinedTile>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum FillStyleSelect {
    #[holder(use_place_holder)]
    FillAreaStyleColour(Box<FillAreaStyleColour>),
    #[holder(use_place_holder)]
    ExternallyDefinedTileStyle(Box<ExternallyDefinedTileStyle>),
    #[holder(use_place_holder)]
    FillAreaStyleTiles(Box<FillAreaStyleTiles>),
    #[holder(use_place_holder)]
    ExternallyDefinedHatchStyle(Box<ExternallyDefinedHatchStyle>),
    #[holder(use_place_holder)]
    FillAreaStyleHatching(Box<FillAreaStyleHatching>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum FontSelect {
    #[holder(use_place_holder)]
    PreDefinedTextFont(PreDefinedTextFontAny),
    #[holder(use_place_holder)]
    ExternallyDefinedTextFont(Box<ExternallyDefinedTextFont>),
    #[holder(use_place_holder)]
    TextFont(Box<TextFont>),
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = force_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct ForceMeasure(pub f64);
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum FoundedItemSelect {
    #[holder(use_place_holder)]
    FoundedItem(FoundedItemAny),
    #[holder(use_place_holder)]
    RepresentationItem(RepresentationItemAny),
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = frequency_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct FrequencyMeasure(pub f64);
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum GeneralizedSurfaceSelect {
    #[holder(use_place_holder)]
    Surface(SurfaceAny),
    #[holder(use_place_holder)]
    FaceSurface(FaceSurfaceAny),
    #[holder(use_place_holder)]
    SurfacedOpenShell(Box<SurfacedOpenShell>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum GeometricItemSpecificUsageSelect {
    #[holder(use_place_holder)]
    ShapeAspect(ShapeAspectAny),
    #[holder(use_place_holder)]
    ShapeAspectRelationship(ShapeAspectRelationshipAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum GeometricSetSelect {
    #[holder(use_place_holder)]
    Point(PointAny),
    #[holder(use_place_holder)]
    Curve(CurveAny),
    #[holder(use_place_holder)]
    Surface(SurfaceAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum GroupableItem {
    #[holder(use_place_holder)]
    GeometricRepresentationItem(GeometricRepresentationItemAny),
    #[holder(use_place_holder)]
    GroupRelationship(Box<GroupRelationship>),
    #[holder(use_place_holder)]
    MappedItem(MappedItemAny),
    #[holder(use_place_holder)]
    PackageProductConceptFeature(Box<PackageProductConceptFeature>),
    #[holder(use_place_holder)]
    ProductConceptFeature(ProductConceptFeatureAny),
    #[holder(use_place_holder)]
    ProductDefinition(ProductDefinitionAny),
    #[holder(use_place_holder)]
    ProductDefinitionFormation(ProductDefinitionFormationAny),
    #[holder(use_place_holder)]
    PropertyDefinitionRepresentation(PropertyDefinitionRepresentationAny),
    #[holder(use_place_holder)]
    Representation(RepresentationAny),
    #[holder(use_place_holder)]
    RepresentationItem(RepresentationItemAny),
    #[holder(use_place_holder)]
    RepresentationRelationshipWithTransformation(Box<RepresentationRelationshipWithTransformation>),
    #[holder(use_place_holder)]
    ShapeAspect(ShapeAspectAny),
    #[holder(use_place_holder)]
    ShapeAspectRelationship(ShapeAspectRelationshipAny),
    #[holder(use_place_holder)]
    ShapeRepresentationRelationship(ShapeRepresentationRelationshipAny),
    #[holder(use_place_holder)]
    StyledItem(StyledItemAny),
    #[holder(use_place_holder)]
    TopologicalRepresentationItem(TopologicalRepresentationItemAny),
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = hour_in_day)]
#[holder(generate_deserialize)]
# [holder (from = i64)]
pub struct HourInDay(pub i64);
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum IdAttributeSelect {
    #[holder(use_place_holder)]
    Action(ActionAny),
    #[holder(use_place_holder)]
    Address(AddressAny),
    #[holder(use_place_holder)]
    ProductCategory(ProductCategoryAny),
    #[holder(use_place_holder)]
    PropertyDefinition(PropertyDefinitionAny),
    #[holder(use_place_holder)]
    ShapeAspect(ShapeAspectAny),
    #[holder(use_place_holder)]
    ShapeAspectRelationship(ShapeAspectRelationshipAny),
    #[holder(use_place_holder)]
    ApplicationContext(Box<ApplicationContext>),
    #[holder(use_place_holder)]
    Group(GroupAny),
    #[holder(use_place_holder)]
    OrganizationalProject(Box<OrganizationalProject>),
    #[holder(use_place_holder)]
    Representation(RepresentationAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum IdentificationItem {
    #[holder(use_place_holder)]
    ApprovalStatus(Box<ApprovalStatus>),
    #[holder(use_place_holder)]
    CharacterizedClass(Box<CharacterizedClass>),
    #[holder(use_place_holder)]
    Class(ClassAny),
    #[holder(use_place_holder)]
    ConfigurationItem(ConfigurationItemAny),
    #[holder(use_place_holder)]
    Contract(Box<Contract>),
    #[holder(use_place_holder)]
    DimensionalSize(DimensionalSizeAny),
    #[holder(use_place_holder)]
    DocumentFile(Box<DocumentFile>),
    #[holder(use_place_holder)]
    GeneralProperty(GeneralPropertyAny),
    #[holder(use_place_holder)]
    Group(GroupAny),
    #[holder(use_place_holder)]
    GroupRelationship(Box<GroupRelationship>),
    #[holder(use_place_holder)]
    InformationRight(Box<InformationRight>),
    #[holder(use_place_holder)]
    InformationUsageRight(Box<InformationUsageRight>),
    #[holder(use_place_holder)]
    MaterialDesignation(MaterialDesignationAny),
    #[holder(use_place_holder)]
    Organization(Box<Organization>),
    #[holder(use_place_holder)]
    PersonAndOrganization(Box<PersonAndOrganization>),
    #[holder(use_place_holder)]
    Product(Box<Product>),
    #[holder(use_place_holder)]
    ProductCategory(ProductCategoryAny),
    #[holder(use_place_holder)]
    ProductClass(Box<ProductClass>),
    #[holder(use_place_holder)]
    ProductConcept(ProductConceptAny),
    #[holder(use_place_holder)]
    ProductConceptFeature(ProductConceptFeatureAny),
    #[holder(use_place_holder)]
    ProductDefinition(ProductDefinitionAny),
    #[holder(use_place_holder)]
    ProductDefinitionFormation(ProductDefinitionFormationAny),
    #[holder(use_place_holder)]
    ProductIdentification(ProductIdentificationAny),
    #[holder(use_place_holder)]
    Representation(RepresentationAny),
    #[holder(use_place_holder)]
    RuleSet(Box<RuleSet>),
    #[holder(use_place_holder)]
    SecurityClassification(Box<SecurityClassification>),
    #[holder(use_place_holder)]
    SecurityClassificationLevel(Box<SecurityClassificationLevel>),
    #[holder(use_place_holder)]
    ShapeAspectRelationship(ShapeAspectRelationshipAny),
    #[holder(use_place_holder)]
    ShapeRepresentation(ShapeRepresentationAny),
    #[holder(use_place_holder)]
    UsageAssociation(Box<UsageAssociation>),
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = identifier)]
#[holder(generate_deserialize)]
# [holder (from = String)]
pub struct Identifier(pub String);
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = illuminance_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct IlluminanceMeasure(pub f64);
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = inductance_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct InductanceMeasure(pub f64);
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum InstanceUsageContextSelect {
    #[holder(use_place_holder)]
    ProductDefinitionRelationship(ProductDefinitionRelationshipAny),
    #[holder(use_place_holder)]
    ProductDefinitionUsage(ProductDefinitionUsageAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum InvisibilityContext {
    #[holder(use_place_holder)]
    DraughtingModel(Box<DraughtingModel>),
    #[holder(use_place_holder)]
    PresentationRepresentation(PresentationRepresentationAny),
    #[holder(use_place_holder)]
    PresentationSet(PresentationSetAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum InvisibleItem {
    #[holder(use_place_holder)]
    DraughtingCallout(DraughtingCalloutAny),
    #[holder(use_place_holder)]
    PresentationLayerAssignment(Box<PresentationLayerAssignment>),
    #[holder(use_place_holder)]
    Representation(RepresentationAny),
    #[holder(use_place_holder)]
    StyledItem(StyledItemAny),
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = ir_usage_item)]
#[holder(generate_deserialize)]
# [holder (inner = ActionItems)]
pub struct IrUsageItem(#[holder(use_place_holder)] pub ActionItems);
#[derive(Debug, Clone, PartialEq, :: ruststep_derive :: ToData, :: serde :: Deserialize)]
pub enum KnotType {
    UniformKnots,
    QuasiUniformKnots,
    PiecewiseBezierKnots,
    Unspecified,
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = label)]
#[holder(generate_deserialize)]
# [holder (from = String)]
pub struct Label(pub String);
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum LayeredItem {
    #[holder(use_place_holder)]
    PresentationRepresentation(PresentationRepresentationAny),
    #[holder(use_place_holder)]
    RepresentationItem(RepresentationItemAny),
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = length_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct LengthMeasure(pub f64);
#[derive(Debug, Clone, PartialEq, :: ruststep_derive :: ToData, :: serde :: Deserialize)]
pub enum LimitCondition {
    MaximumMaterialCondition,
    LeastMaterialCondition,
    RegardlessOfFeatureSize,
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = list_of_reversible_topology_item)]
#[holder(generate_deserialize)]
pub struct ListOfReversibleTopologyItem(
    #[holder(use_place_holder)] pub Vec<ReversibleTopologyItem>,
);
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = list_representation_item)]
#[holder(generate_deserialize)]
pub struct ListRepresentationItem(#[holder(use_place_holder)] pub Vec<RepresentationItemAny>);
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = luminous_flux_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct LuminousFluxMeasure(pub f64);
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = luminous_intensity_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct LuminousIntensityMeasure(pub f64);
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = magnetic_flux_density_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct MagneticFluxDensityMeasure(pub f64);
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = magnetic_flux_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct MagneticFluxMeasure(pub f64);
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum MarkerSelect {
    MarkerType(MarkerType),
    #[holder(use_place_holder)]
    PreDefinedMarker(PreDefinedMarkerAny),
}
#[derive(Debug, Clone, PartialEq, :: ruststep_derive :: ToData, :: serde :: Deserialize)]
pub enum MarkerType {
    Dot,
    X,
    Plus,
    Asterisk,
    Ring,
    Square,
    Triangle,
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = mass_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct MassMeasure(pub f64);
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum MeasureValue {
    #[holder(use_place_holder)]
    AbsorbedDoseMeasure(Box<AbsorbedDoseMeasure>),
    #[holder(use_place_holder)]
    DoseEquivalentMeasure(Box<DoseEquivalentMeasure>),
    #[holder(use_place_holder)]
    RadioactivityMeasure(Box<RadioactivityMeasure>),
    #[holder(use_place_holder)]
    AccelerationMeasure(Box<AccelerationMeasure>),
    #[holder(use_place_holder)]
    AmountOfSubstanceMeasure(Box<AmountOfSubstanceMeasure>),
    #[holder(use_place_holder)]
    AreaMeasure(Box<AreaMeasure>),
    #[holder(use_place_holder)]
    CelsiusTemperatureMeasure(Box<CelsiusTemperatureMeasure>),
    #[holder(use_place_holder)]
    ContextDependentMeasure(Box<ContextDependentMeasure>),
    #[holder(use_place_holder)]
    CountMeasure(Box<CountMeasure>),
    #[holder(use_place_holder)]
    DescriptiveMeasure(Box<DescriptiveMeasure>),
    #[holder(use_place_holder)]
    CapacitanceMeasure(Box<CapacitanceMeasure>),
    #[holder(use_place_holder)]
    ElectricChargeMeasure(Box<ElectricChargeMeasure>),
    #[holder(use_place_holder)]
    ConductanceMeasure(Box<ConductanceMeasure>),
    #[holder(use_place_holder)]
    ElectricCurrentMeasure(Box<ElectricCurrentMeasure>),
    #[holder(use_place_holder)]
    ElectricPotentialMeasure(Box<ElectricPotentialMeasure>),
    #[holder(use_place_holder)]
    EnergyMeasure(Box<EnergyMeasure>),
    #[holder(use_place_holder)]
    MagneticFluxDensityMeasure(Box<MagneticFluxDensityMeasure>),
    #[holder(use_place_holder)]
    ForceMeasure(Box<ForceMeasure>),
    #[holder(use_place_holder)]
    FrequencyMeasure(Box<FrequencyMeasure>),
    #[holder(use_place_holder)]
    IlluminanceMeasure(Box<IlluminanceMeasure>),
    #[holder(use_place_holder)]
    InductanceMeasure(Box<InductanceMeasure>),
    #[holder(use_place_holder)]
    LengthMeasure(Box<LengthMeasure>),
    #[holder(use_place_holder)]
    LuminousFluxMeasure(Box<LuminousFluxMeasure>),
    #[holder(use_place_holder)]
    LuminousIntensityMeasure(Box<LuminousIntensityMeasure>),
    #[holder(use_place_holder)]
    MagneticFluxMeasure(Box<MagneticFluxMeasure>),
    #[holder(use_place_holder)]
    MassMeasure(Box<MassMeasure>),
    #[holder(use_place_holder)]
    NumericMeasure(Box<NumericMeasure>),
    #[holder(use_place_holder)]
    NonNegativeLengthMeasure(Box<NonNegativeLengthMeasure>),
    #[holder(use_place_holder)]
    ParameterValue(Box<ParameterValue>),
    #[holder(use_place_holder)]
    PlaneAngleMeasure(Box<PlaneAngleMeasure>),
    #[holder(use_place_holder)]
    PositiveLengthMeasure(Box<PositiveLengthMeasure>),
    #[holder(use_place_holder)]
    PositivePlaneAngleMeasure(Box<PositivePlaneAngleMeasure>),
    #[holder(use_place_holder)]
    PositiveRatioMeasure(Box<PositiveRatioMeasure>),
    #[holder(use_place_holder)]
    PowerMeasure(Box<PowerMeasure>),
    #[holder(use_place_holder)]
    PressureMeasure(Box<PressureMeasure>),
    #[holder(use_place_holder)]
    RatioMeasure(Box<RatioMeasure>),
    #[holder(use_place_holder)]
    ResistanceMeasure(Box<ResistanceMeasure>),
    #[holder(use_place_holder)]
    SolidAngleMeasure(Box<SolidAngleMeasure>),
    #[holder(use_place_holder)]
    ThermodynamicTemperatureMeasure(Box<ThermodynamicTemperatureMeasure>),
    #[holder(use_place_holder)]
    TimeMeasure(Box<TimeMeasure>),
    #[holder(use_place_holder)]
    VelocityMeasure(Box<VelocityMeasure>),
    #[holder(use_place_holder)]
    VolumeMeasure(Box<VolumeMeasure>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum MechanicalDesignAndDraughtingRelationshipSelect {
    #[holder(use_place_holder)]
    DraughtingModel(Box<DraughtingModel>),
    #[holder(use_place_holder)]
    MechanicalDesignGeometricPresentationRepresentation(
        Box<MechanicalDesignGeometricPresentationRepresentation>,
    ),
    #[holder(use_place_holder)]
    MechanicalDesignPresentationRepresentationWithDraughting(
        Box<MechanicalDesignPresentationRepresentationWithDraughting>,
    ),
    #[holder(use_place_holder)]
    MechanicalDesignShadedPresentationRepresentation(
        Box<MechanicalDesignShadedPresentationRepresentation>,
    ),
    #[holder(use_place_holder)]
    ShapeRepresentation(ShapeRepresentationAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum MechanicalDesignGeometricPresentationAreaItems {
    #[holder(use_place_holder)]
    Axis2Placement(Box<Axis2Placement>),
    #[holder(use_place_holder)]
    MappedItem(MappedItemAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum MechanicalDesignGeometricPresentationRepresentationItems {
    #[holder(use_place_holder)]
    Axis2Placement(Box<Axis2Placement>),
    #[holder(use_place_holder)]
    CameraModelD3(CameraModelD3Any),
    #[holder(use_place_holder)]
    MappedItem(MappedItemAny),
    #[holder(use_place_holder)]
    StyledItem(StyledItemAny),
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = message)]
#[holder(generate_deserialize)]
# [holder (from = String)]
pub struct Message(pub String);
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = minute_in_hour)]
#[holder(generate_deserialize)]
# [holder (from = i64)]
pub struct MinuteInHour(pub i64);
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = month_in_year_number)]
#[holder(generate_deserialize)]
# [holder (from = i64)]
pub struct MonthInYearNumber(pub i64);
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum MultiLanguageAttributeItem {
    #[holder(use_place_holder)]
    AlternateProductRelationship(Box<AlternateProductRelationship>),
    #[holder(use_place_holder)]
    ApplicationContext(Box<ApplicationContext>),
    #[holder(use_place_holder)]
    AppliedCertificationAssignment(Box<AppliedCertificationAssignment>),
    #[holder(use_place_holder)]
    AppliedDocumentReference(Box<AppliedDocumentReference>),
    #[holder(use_place_holder)]
    AppliedDocumentUsageConstraintAssignment(AppliedDocumentUsageConstraintAssignmentAny),
    #[holder(use_place_holder)]
    AppliedExternalIdentificationAssignment(Box<AppliedExternalIdentificationAssignment>),
    #[holder(use_place_holder)]
    AppliedIdentificationAssignment(Box<AppliedIdentificationAssignment>),
    #[holder(use_place_holder)]
    AppliedOrganizationalProjectAssignment(Box<AppliedOrganizationalProjectAssignment>),
    #[holder(use_place_holder)]
    Approval(Box<Approval>),
    #[holder(use_place_holder)]
    ApprovalRelationship(Box<ApprovalRelationship>),
    #[holder(use_place_holder)]
    ApprovalStatus(Box<ApprovalStatus>),
    #[holder(use_place_holder)]
    AssemblyComponentUsageSubstitute(Box<AssemblyComponentUsageSubstitute>),
    #[holder(use_place_holder)]
    AttributeValueAssignment(AttributeValueAssignmentAny),
    #[holder(use_place_holder)]
    Certification(Box<Certification>),
    #[holder(use_place_holder)]
    CertificationType(Box<CertificationType>),
    #[holder(use_place_holder)]
    Colour(ColourAny),
    #[holder(use_place_holder)]
    ConfigurationDesign(Box<ConfigurationDesign>),
    #[holder(use_place_holder)]
    ConfigurationItem(ConfigurationItemAny),
    #[holder(use_place_holder)]
    Contract(Box<Contract>),
    #[holder(use_place_holder)]
    DateRole(Box<DateRole>),
    #[holder(use_place_holder)]
    DateTimeRole(Box<DateTimeRole>),
    #[holder(use_place_holder)]
    DescriptiveRepresentationItem(DescriptiveRepresentationItemAny),
    #[holder(use_place_holder)]
    DocumentRelationship(Box<DocumentRelationship>),
    #[holder(use_place_holder)]
    DocumentUsageRole(Box<DocumentUsageRole>),
    #[holder(use_place_holder)]
    Effectivity(EffectivityAny),
    #[holder(use_place_holder)]
    EffectivityRelationship(Box<EffectivityRelationship>),
    #[holder(use_place_holder)]
    EventOccurrence(EventOccurrenceAny),
    #[holder(use_place_holder)]
    ExternalSource(ExternalSourceAny),
    #[holder(use_place_holder)]
    GeneralProperty(GeneralPropertyAny),
    #[holder(use_place_holder)]
    GeneralPropertyRelationship(GeneralPropertyRelationshipAny),
    #[holder(use_place_holder)]
    GeometricRepresentationItem(GeometricRepresentationItemAny),
    #[holder(use_place_holder)]
    GeometricTolerance(GeometricToleranceAny),
    #[holder(use_place_holder)]
    IdentificationRole(Box<IdentificationRole>),
    #[holder(use_place_holder)]
    InformationRight(Box<InformationRight>),
    #[holder(use_place_holder)]
    InformationUsageRight(Box<InformationUsageRight>),
    #[holder(use_place_holder)]
    MakeFromUsageOption(Box<MakeFromUsageOption>),
    #[holder(use_place_holder)]
    MappedItem(MappedItemAny),
    #[holder(use_place_holder)]
    ObjectRole(Box<ObjectRole>),
    #[holder(use_place_holder)]
    OrganizationRelationship(Box<OrganizationRelationship>),
    #[holder(use_place_holder)]
    OrganizationRole(Box<OrganizationRole>),
    #[holder(use_place_holder)]
    OrganizationalProject(Box<OrganizationalProject>),
    #[holder(use_place_holder)]
    OrganizationalProjectRelationship(Box<OrganizationalProjectRelationship>),
    #[holder(use_place_holder)]
    OrganizationalProjectRole(Box<OrganizationalProjectRole>),
    #[holder(use_place_holder)]
    PersonAndOrganization(Box<PersonAndOrganization>),
    #[holder(use_place_holder)]
    PersonAndOrganizationRole(Box<PersonAndOrganizationRole>),
    #[holder(use_place_holder)]
    Product(Box<Product>),
    #[holder(use_place_holder)]
    ProductConcept(ProductConceptAny),
    #[holder(use_place_holder)]
    ProductConceptRelationship(Box<ProductConceptRelationship>),
    #[holder(use_place_holder)]
    ProductDefinition(ProductDefinitionAny),
    #[holder(use_place_holder)]
    ProductDefinitionContext(ProductDefinitionContextAny),
    #[holder(use_place_holder)]
    ProductDefinitionFormation(ProductDefinitionFormationAny),
    #[holder(use_place_holder)]
    ProductDefinitionFormationRelationship(Box<ProductDefinitionFormationRelationship>),
    #[holder(use_place_holder)]
    ProductDefinitionRelationship(ProductDefinitionRelationshipAny),
    #[holder(use_place_holder)]
    ProductDefinitionShape(Box<ProductDefinitionShape>),
    #[holder(use_place_holder)]
    ProductRelatedProductCategory(Box<ProductRelatedProductCategory>),
    #[holder(use_place_holder)]
    PropertyDefinition(PropertyDefinitionAny),
    #[holder(use_place_holder)]
    Representation(RepresentationAny),
    #[holder(use_place_holder)]
    RepresentationRelationship(RepresentationRelationshipAny),
    #[holder(use_place_holder)]
    SecurityClassification(Box<SecurityClassification>),
    #[holder(use_place_holder)]
    SecurityClassificationAssignment(SecurityClassificationAssignmentAny),
    #[holder(use_place_holder)]
    ShapeAspect(ShapeAspectAny),
    #[holder(use_place_holder)]
    ShapeAspectRelationship(ShapeAspectRelationshipAny),
    #[holder(use_place_holder)]
    ShapeRepresentation(ShapeRepresentationAny),
    #[holder(use_place_holder)]
    TimeIntervalRole(Box<TimeIntervalRole>),
    #[holder(use_place_holder)]
    TopologicalRepresentationItem(TopologicalRepresentationItemAny),
    #[holder(use_place_holder)]
    UncertaintyMeasureWithUnit(Box<UncertaintyMeasureWithUnit>),
    #[holder(use_place_holder)]
    UsageAssociation(Box<UsageAssociation>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum NameAttributeSelect {
    #[holder(use_place_holder)]
    ActionRequestSolution(Box<ActionRequestSolution>),
    #[holder(use_place_holder)]
    Address(AddressAny),
    #[holder(use_place_holder)]
    ConfigurationDesign(Box<ConfigurationDesign>),
    #[holder(use_place_holder)]
    ContextDependentShapeRepresentation(Box<ContextDependentShapeRepresentation>),
    #[holder(use_place_holder)]
    DerivedUnit(DerivedUnitAny),
    #[holder(use_place_holder)]
    Effectivity(EffectivityAny),
    #[holder(use_place_holder)]
    PersonAndOrganization(Box<PersonAndOrganization>),
    #[holder(use_place_holder)]
    ProductDefinition(ProductDefinitionAny),
    #[holder(use_place_holder)]
    ProductDefinitionSubstitute(Box<ProductDefinitionSubstitute>),
    #[holder(use_place_holder)]
    PropertyDefinitionRepresentation(PropertyDefinitionRepresentationAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum NameItem {
    #[holder(use_place_holder)]
    AssemblyComponentUsage(AssemblyComponentUsageAny),
    #[holder(use_place_holder)]
    ExternalClassLibrary(Box<ExternalClassLibrary>),
    #[holder(use_place_holder)]
    Group(GroupAny),
    #[holder(use_place_holder)]
    GroupRelationship(Box<GroupRelationship>),
    #[holder(use_place_holder)]
    Product(Box<Product>),
    #[holder(use_place_holder)]
    ProductDefinition(ProductDefinitionAny),
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = non_negative_length_measure)]
#[holder(generate_deserialize)]
# [holder (inner = LengthMeasure)]
pub struct NonNegativeLengthMeasure(#[holder(use_place_holder)] pub LengthMeasure);
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = nonnegative_integer)]
#[holder(generate_deserialize)]
# [holder (from = i64)]
pub struct NonnegativeInteger(pub i64);
#[derive(Debug, Clone, PartialEq, :: ruststep_derive :: ToData, :: serde :: Deserialize)]
pub enum NullStyle {
    Null,
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = numeric_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct NumericMeasure(pub f64);
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum OrganizationItem {
    #[holder(use_place_holder)]
    Action(ActionAny),
    #[holder(use_place_holder)]
    ActionDirective(Box<ActionDirective>),
    #[holder(use_place_holder)]
    AlternateProductRelationship(Box<AlternateProductRelationship>),
    #[holder(use_place_holder)]
    AppliedActionAssignment(AppliedActionAssignmentAny),
    #[holder(use_place_holder)]
    AppliedClassificationAssignment(Box<AppliedClassificationAssignment>),
    #[holder(use_place_holder)]
    AppliedIdentificationAssignment(Box<AppliedIdentificationAssignment>),
    #[holder(use_place_holder)]
    AppliedSecurityClassificationAssignment(Box<AppliedSecurityClassificationAssignment>),
    #[holder(use_place_holder)]
    Approval(Box<Approval>),
    #[holder(use_place_holder)]
    AssemblyComponentUsageSubstitute(Box<AssemblyComponentUsageSubstitute>),
    #[holder(use_place_holder)]
    Certification(Box<Certification>),
    #[holder(use_place_holder)]
    Class(ClassAny),
    #[holder(use_place_holder)]
    ConfigurationItem(ConfigurationItemAny),
    #[holder(use_place_holder)]
    Contract(Box<Contract>),
    #[holder(use_place_holder)]
    DocumentFile(Box<DocumentFile>),
    #[holder(use_place_holder)]
    ExecutedAction(ExecutedActionAny),
    #[holder(use_place_holder)]
    GeneralProperty(GeneralPropertyAny),
    #[holder(use_place_holder)]
    InformationUsageRight(Box<InformationUsageRight>),
    #[holder(use_place_holder)]
    OrganizationalProject(Box<OrganizationalProject>),
    #[holder(use_place_holder)]
    Product(Box<Product>),
    #[holder(use_place_holder)]
    ProductDefinition(ProductDefinitionAny),
    #[holder(use_place_holder)]
    ProductDefinitionFormation(ProductDefinitionFormationAny),
    #[holder(use_place_holder)]
    ProductDefinitionFormationRelationship(Box<ProductDefinitionFormationRelationship>),
    #[holder(use_place_holder)]
    PropertyDefinition(PropertyDefinitionAny),
    #[holder(use_place_holder)]
    RuleAction(RuleActionAny),
    #[holder(use_place_holder)]
    SecurityClassification(Box<SecurityClassification>),
    #[holder(use_place_holder)]
    ShapeRepresentation(ShapeRepresentationAny),
    #[holder(use_place_holder)]
    VersionedActionRequest(Box<VersionedActionRequest>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum OrientationBasisSelect {
    #[holder(use_place_holder)]
    Axis2Placement3D(Box<Axis2Placement3D>),
    #[holder(use_place_holder)]
    MinAndMajorPlyOrientationBasis(Box<MinAndMajorPlyOrientationBasis>),
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = parameter_value)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct ParameterValue(pub f64);
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PcurveOrSurface {
    #[holder(use_place_holder)]
    Pcurve(PcurveAny),
    #[holder(use_place_holder)]
    Surface(SurfaceAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PersonAndOrganizationItem {
    #[holder(use_place_holder)]
    Action(ActionAny),
    #[holder(use_place_holder)]
    ActionDirective(Box<ActionDirective>),
    #[holder(use_place_holder)]
    AlternateProductRelationship(Box<AlternateProductRelationship>),
    #[holder(use_place_holder)]
    AppliedActionAssignment(AppliedActionAssignmentAny),
    #[holder(use_place_holder)]
    AppliedClassificationAssignment(Box<AppliedClassificationAssignment>),
    #[holder(use_place_holder)]
    AppliedIdentificationAssignment(Box<AppliedIdentificationAssignment>),
    #[holder(use_place_holder)]
    AppliedSecurityClassificationAssignment(Box<AppliedSecurityClassificationAssignment>),
    #[holder(use_place_holder)]
    Approval(Box<Approval>),
    #[holder(use_place_holder)]
    AssemblyComponentUsageSubstitute(Box<AssemblyComponentUsageSubstitute>),
    #[holder(use_place_holder)]
    Certification(Box<Certification>),
    #[holder(use_place_holder)]
    ConfigurationItem(ConfigurationItemAny),
    #[holder(use_place_holder)]
    Contract(Box<Contract>),
    #[holder(use_place_holder)]
    DocumentFile(Box<DocumentFile>),
    #[holder(use_place_holder)]
    ExecutedAction(ExecutedActionAny),
    #[holder(use_place_holder)]
    GeneralProperty(GeneralPropertyAny),
    #[holder(use_place_holder)]
    InformationUsageRight(Box<InformationUsageRight>),
    #[holder(use_place_holder)]
    OrganizationalProject(Box<OrganizationalProject>),
    #[holder(use_place_holder)]
    PersonAndOrganization(Box<PersonAndOrganization>),
    #[holder(use_place_holder)]
    Product(Box<Product>),
    #[holder(use_place_holder)]
    ProductDefinition(ProductDefinitionAny),
    #[holder(use_place_holder)]
    ProductDefinitionFormation(ProductDefinitionFormationAny),
    #[holder(use_place_holder)]
    ProductDefinitionFormationRelationship(Box<ProductDefinitionFormationRelationship>),
    #[holder(use_place_holder)]
    PropertyDefinition(PropertyDefinitionAny),
    #[holder(use_place_holder)]
    RuleAction(RuleActionAny),
    #[holder(use_place_holder)]
    SecurityClassification(Box<SecurityClassification>),
    #[holder(use_place_holder)]
    ShapeRepresentation(ShapeRepresentationAny),
    #[holder(use_place_holder)]
    VersionedActionRequest(Box<VersionedActionRequest>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PersonOrganizationSelect {
    #[holder(use_place_holder)]
    Person(Box<Person>),
    #[holder(use_place_holder)]
    Organization(Box<Organization>),
    #[holder(use_place_holder)]
    PersonAndOrganization(Box<PersonAndOrganization>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PictureRepresentationItemSelect {
    #[holder(use_place_holder)]
    StyledItem(StyledItemAny),
    #[holder(use_place_holder)]
    PlanarBox(Box<PlanarBox>),
    #[holder(use_place_holder)]
    Axis2Placement2D(Box<Axis2Placement2D>),
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = plane_angle_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct PlaneAngleMeasure(pub f64);
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PlaneOrPlanarBox {
    #[holder(use_place_holder)]
    Plane(Box<Plane>),
    #[holder(use_place_holder)]
    PlanarBox(Box<PlanarBox>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PointAndVectorMember {
    #[holder(use_place_holder)]
    Point(PointAny),
    #[holder(use_place_holder)]
    Direction(Box<Direction>),
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = point_and_vector_members)]
#[holder(generate_deserialize)]
pub struct PointAndVectorMembers(#[holder(use_place_holder)] pub Vec<PointAndVectorMember>);
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = point_path_members)]
#[holder(generate_deserialize)]
pub struct PointPathMembers(#[holder(use_place_holder)] pub Vec<PointAndVector>);
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = positive_integer)]
#[holder(generate_deserialize)]
# [holder (inner = NonnegativeInteger)]
pub struct PositiveInteger(#[holder(use_place_holder)] pub NonnegativeInteger);
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = positive_length_measure)]
#[holder(generate_deserialize)]
# [holder (inner = NonNegativeLengthMeasure)]
pub struct PositiveLengthMeasure(#[holder(use_place_holder)] pub NonNegativeLengthMeasure);
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = positive_plane_angle_measure)]
#[holder(generate_deserialize)]
# [holder (inner = PlaneAngleMeasure)]
pub struct PositivePlaneAngleMeasure(#[holder(use_place_holder)] pub PlaneAngleMeasure);
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = positive_ratio_measure)]
#[holder(generate_deserialize)]
# [holder (inner = RatioMeasure)]
pub struct PositiveRatioMeasure(#[holder(use_place_holder)] pub RatioMeasure);
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = power_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct PowerMeasure(pub f64);
#[derive(Debug, Clone, PartialEq, :: ruststep_derive :: ToData, :: serde :: Deserialize)]
pub enum PreferredSurfaceCurveRepresentation {
    Curve3D,
    PcurveS1,
    PcurveS2,
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = presentable_text)]
#[holder(generate_deserialize)]
# [holder (from = String)]
pub struct PresentableText(pub String);
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PresentationRepresentationSelect {
    #[holder(use_place_holder)]
    PresentationRepresentation(PresentationRepresentationAny),
    #[holder(use_place_holder)]
    PresentationSet(PresentationSetAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PresentationSizeAssignmentSelect {
    #[holder(use_place_holder)]
    PresentationView(PresentationViewAny),
    #[holder(use_place_holder)]
    PresentationArea(PresentationAreaAny),
    #[holder(use_place_holder)]
    AreaInSet(AreaInSetAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PresentationStyleSelect {
    #[holder(use_place_holder)]
    PointStyle(Box<PointStyle>),
    #[holder(use_place_holder)]
    CurveStyle(CurveStyleAny),
    #[holder(use_place_holder)]
    SurfaceStyleUsage(Box<SurfaceStyleUsage>),
    #[holder(use_place_holder)]
    SymbolStyle(Box<SymbolStyle>),
    #[holder(use_place_holder)]
    FillAreaStyle(Box<FillAreaStyle>),
    #[holder(use_place_holder)]
    TextStyle(TextStyleAny),
    NullStyle(NullStyle),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PresentedItemSelect {
    #[holder(use_place_holder)]
    Action(ActionAny),
    #[holder(use_place_holder)]
    ActionMethod(ActionMethodAny),
    #[holder(use_place_holder)]
    ActionRelationship(Box<ActionRelationship>),
    #[holder(use_place_holder)]
    ProductConcept(ProductConceptAny),
    #[holder(use_place_holder)]
    ProductConceptFeature(ProductConceptFeatureAny),
    #[holder(use_place_holder)]
    ProductConceptFeatureCategory(ProductConceptFeatureCategoryAny),
    #[holder(use_place_holder)]
    ProductDefinition(ProductDefinitionAny),
    #[holder(use_place_holder)]
    ProductDefinitionFormation(ProductDefinitionFormationAny),
    #[holder(use_place_holder)]
    ProductDefinitionRelationship(ProductDefinitionRelationshipAny),
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = pressure_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct PressureMeasure(pub f64);
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ProductDefinitionOrAssemblyRelationship {
    #[holder(use_place_holder)]
    AssemblyComponentUsage(AssemblyComponentUsageAny),
    #[holder(use_place_holder)]
    ProductDefinition(ProductDefinitionAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ProductDefinitionOrBreakdownElementUsage {
    #[holder(use_place_holder)]
    ProductDefinition(ProductDefinitionAny),
    #[holder(use_place_holder)]
    ProductDefinitionUsage(ProductDefinitionUsageAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ProductDefinitionOrProductDefinitionRelationship {
    #[holder(use_place_holder)]
    ProductDefinition(ProductDefinitionAny),
    #[holder(use_place_holder)]
    ProductDefinitionUsage(ProductDefinitionUsageAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ProductOrFormationOrDefinition {
    #[holder(use_place_holder)]
    Product(Box<Product>),
    #[holder(use_place_holder)]
    ProductDefinitionFormation(ProductDefinitionFormationAny),
    #[holder(use_place_holder)]
    ProductDefinition(ProductDefinitionAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ProjectItem {
    #[holder(use_place_holder)]
    ExecutedAction(ExecutedActionAny),
    #[holder(use_place_holder)]
    ProductConcept(ProductConceptAny),
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = radioactivity_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct RadioactivityMeasure(pub f64);
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = ratio_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct RatioMeasure(pub f64);
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum RenderingPropertiesSelect {
    #[holder(use_place_holder)]
    SurfaceStyleReflectanceAmbient(SurfaceStyleReflectanceAmbientAny),
    #[holder(use_place_holder)]
    SurfaceStyleTransparent(Box<SurfaceStyleTransparent>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum RepresentedDefinition {
    #[holder(use_place_holder)]
    GeneralProperty(GeneralPropertyAny),
    #[holder(use_place_holder)]
    PropertyDefinition(PropertyDefinitionAny),
    #[holder(use_place_holder)]
    PropertyDefinitionRelationship(Box<PropertyDefinitionRelationship>),
    #[holder(use_place_holder)]
    ShapeAspect(ShapeAspectAny),
    #[holder(use_place_holder)]
    ShapeAspectRelationship(ShapeAspectRelationshipAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum RequirementAssignedItem {
    #[holder(use_place_holder)]
    ConfigurationItem(ConfigurationItemAny),
    #[holder(use_place_holder)]
    DescriptiveRepresentationItem(DescriptiveRepresentationItemAny),
    #[holder(use_place_holder)]
    Product(Box<Product>),
    #[holder(use_place_holder)]
    ProductClass(Box<ProductClass>),
    #[holder(use_place_holder)]
    ProductDefinition(ProductDefinitionAny),
    #[holder(use_place_holder)]
    ProductDefinitionFormation(ProductDefinitionFormationAny),
    #[holder(use_place_holder)]
    ProductDefinitionRelationship(ProductDefinitionRelationshipAny),
    #[holder(use_place_holder)]
    Representation(RepresentationAny),
    #[holder(use_place_holder)]
    ShapeAspect(ShapeAspectAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum RequirementSatisfactionItem {
    #[holder(use_place_holder)]
    RequirementAssignedItem(Box<RequirementAssignedItem>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum RequirementSourceItem {
    #[holder(use_place_holder)]
    CharacterizedObject(CharacterizedObjectAny),
    #[holder(use_place_holder)]
    Group(GroupAny),
    #[holder(use_place_holder)]
    GroupRelationship(Box<GroupRelationship>),
    #[holder(use_place_holder)]
    Product(Box<Product>),
    #[holder(use_place_holder)]
    ProductDefinition(ProductDefinitionAny),
    #[holder(use_place_holder)]
    ProductDefinitionFormation(ProductDefinitionFormationAny),
    #[holder(use_place_holder)]
    ProductDefinitionRelationship(ProductDefinitionRelationshipAny),
    #[holder(use_place_holder)]
    ShapeAspect(ShapeAspectAny),
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = resistance_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct ResistanceMeasure(pub f64);
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ReversibleTopology {
    #[holder(use_place_holder)]
    ReversibleTopologyItem(Box<ReversibleTopologyItem>),
    #[holder(use_place_holder)]
    ListOfReversibleTopologyItem(Box<ListOfReversibleTopologyItem>),
    #[holder(use_place_holder)]
    SetOfReversibleTopologyItem(Box<SetOfReversibleTopologyItem>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ReversibleTopologyItem {
    #[holder(use_place_holder)]
    Edge(EdgeAny),
    #[holder(use_place_holder)]
    Path(PathAny),
    #[holder(use_place_holder)]
    Face(FaceAny),
    #[holder(use_place_holder)]
    FaceBound(FaceBoundAny),
    #[holder(use_place_holder)]
    ClosedShell(ClosedShellAny),
    #[holder(use_place_holder)]
    OpenShell(OpenShellAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum RoleSelect {
    #[holder(use_place_holder)]
    ActionAssignment(ActionAssignmentAny),
    #[holder(use_place_holder)]
    ActionRequestAssignment(ActionRequestAssignmentAny),
    #[holder(use_place_holder)]
    ApprovalAssignment(ApprovalAssignmentAny),
    #[holder(use_place_holder)]
    ApprovalDateTime(Box<ApprovalDateTime>),
    #[holder(use_place_holder)]
    CertificationAssignment(CertificationAssignmentAny),
    #[holder(use_place_holder)]
    ContractAssignment(ContractAssignmentAny),
    #[holder(use_place_holder)]
    DocumentReference(DocumentReferenceAny),
    #[holder(use_place_holder)]
    EffectivityAssignment(EffectivityAssignmentAny),
    #[holder(use_place_holder)]
    GroupAssignment(GroupAssignmentAny),
    #[holder(use_place_holder)]
    NameAssignment(NameAssignmentAny),
    #[holder(use_place_holder)]
    SecurityClassificationAssignment(SecurityClassificationAssignmentAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum RuleSupersededItem {
    #[holder(use_place_holder)]
    ProductDefinitionFormation(ProductDefinitionFormationAny),
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = second_in_minute)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct SecondInMinute(pub f64);
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum SecurityClassificationItem {
    #[holder(use_place_holder)]
    AssemblyComponentUsage(AssemblyComponentUsageAny),
    #[holder(use_place_holder)]
    Document(DocumentAny),
    #[holder(use_place_holder)]
    DocumentFile(Box<DocumentFile>),
    #[holder(use_place_holder)]
    MakeFromUsageOption(Box<MakeFromUsageOption>),
    #[holder(use_place_holder)]
    Product(Box<Product>),
    #[holder(use_place_holder)]
    ProductDefinition(ProductDefinitionAny),
    #[holder(use_place_holder)]
    ProductDefinitionFormation(ProductDefinitionFormationAny),
    #[holder(use_place_holder)]
    ProductDefinitionUsage(ProductDefinitionUsageAny),
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = set_of_reversible_topology_item)]
#[holder(generate_deserialize)]
pub struct SetOfReversibleTopologyItem(#[holder(use_place_holder)] pub Vec<ReversibleTopologyItem>);
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = set_representation_item)]
#[holder(generate_deserialize)]
pub struct SetRepresentationItem(#[holder(use_place_holder)] pub Vec<RepresentationItemAny>);
#[derive(Debug, Clone, PartialEq, :: ruststep_derive :: ToData, :: serde :: Deserialize)]
pub enum ShadingCurveMethod {
    ConstantColour,
    LinearColour,
}
#[derive(Debug, Clone, PartialEq, :: ruststep_derive :: ToData, :: serde :: Deserialize)]
pub enum ShadingSurfaceMethod {
    ConstantShading,
    ColourShading,
    DotShading,
    NormalShading,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ShapeDefinition {
    #[holder(use_place_holder)]
    ProductDefinitionShape(Box<ProductDefinitionShape>),
    #[holder(use_place_holder)]
    ShapeAspect(ShapeAspectAny),
    #[holder(use_place_holder)]
    ShapeAspectRelationship(ShapeAspectRelationshipAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum Shell {
    #[holder(use_place_holder)]
    VertexShell(Box<VertexShell>),
    #[holder(use_place_holder)]
    WireShell(Box<WireShell>),
    #[holder(use_place_holder)]
    OpenShell(OpenShellAny),
    #[holder(use_place_holder)]
    ClosedShell(ClosedShellAny),
}
#[derive(Debug, Clone, PartialEq, :: ruststep_derive :: ToData, :: serde :: Deserialize)]
pub enum SiPrefix {
    Exa,
    Peta,
    Tera,
    Giga,
    Mega,
    Kilo,
    Hecto,
    Deca,
    Deci,
    Centi,
    Milli,
    Micro,
    Nano,
    Pico,
    Femto,
    Atto,
}
#[derive(Debug, Clone, PartialEq, :: ruststep_derive :: ToData, :: serde :: Deserialize)]
pub enum SiUnitName {
    Metre,
    Gram,
    Second,
    Ampere,
    Kelvin,
    Mole,
    Candela,
    Radian,
    Steradian,
    Hertz,
    Newton,
    Pascal,
    Joule,
    Watt,
    Coulomb,
    Volt,
    Farad,
    Ohm,
    Siemens,
    Weber,
    Tesla,
    Henry,
    DegreeCelsius,
    Lumen,
    Lux,
    Becquerel,
    Gray,
    Sievert,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum SizeSelect {
    #[holder(use_place_holder)]
    PositiveLengthMeasure(Box<PositiveLengthMeasure>),
    #[holder(use_place_holder)]
    MeasureWithUnit(MeasureWithUnitAny),
    #[holder(use_place_holder)]
    DescriptiveMeasure(Box<DescriptiveMeasure>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum SketchBasisSelect {
    #[holder(use_place_holder)]
    CurveBoundedSurface(Box<CurveBoundedSurface>),
    #[holder(use_place_holder)]
    FaceSurface(FaceSurfaceAny),
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = solid_angle_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct SolidAngleMeasure(pub f64);
#[derive(Debug, Clone, PartialEq, :: ruststep_derive :: ToData, :: serde :: Deserialize)]
pub enum Source {
    Made,
    Bought,
    NotKnown,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum SourceItem {
    #[holder(use_place_holder)]
    Identifier(Box<Identifier>),
    #[holder(use_place_holder)]
    Message(Box<Message>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum StartRequestItem {
    #[holder(use_place_holder)]
    ProductDefinitionFormation(ProductDefinitionFormationAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum StringRepresentationItemSelect {
    #[holder(use_place_holder)]
    DescriptiveRepresentationItem(DescriptiveRepresentationItemAny),
    #[holder(use_place_holder)]
    IncludedTextBlock(Box<IncludedTextBlock>),
    #[holder(use_place_holder)]
    StructuredTextComposition(Box<StructuredTextComposition>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum StyleContextSelect {
    #[holder(use_place_holder)]
    Group(GroupAny),
    #[holder(use_place_holder)]
    PresentationLayerAssignment(Box<PresentationLayerAssignment>),
    #[holder(use_place_holder)]
    PresentationSet(PresentationSetAny),
    #[holder(use_place_holder)]
    Representation(RepresentationAny),
    #[holder(use_place_holder)]
    RepresentationItem(RepresentationItemAny),
    #[holder(use_place_holder)]
    RepresentationRelationship(RepresentationRelationshipAny),
}
#[derive(Debug, Clone, PartialEq, :: ruststep_derive :: ToData, :: serde :: Deserialize)]
pub enum SurfaceSide {
    Positive,
    Negative,
    Both,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum SurfaceSideStyleSelect {
    #[holder(use_place_holder)]
    SurfaceSideStyle(Box<SurfaceSideStyle>),
    #[holder(use_place_holder)]
    PreDefinedSurfaceSideStyle(Box<PreDefinedSurfaceSideStyle>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum SurfaceStyleElementSelect {
    #[holder(use_place_holder)]
    SurfaceStyleFillArea(Box<SurfaceStyleFillArea>),
    #[holder(use_place_holder)]
    SurfaceStyleBoundary(Box<SurfaceStyleBoundary>),
    #[holder(use_place_holder)]
    SurfaceStyleSilhouette(Box<SurfaceStyleSilhouette>),
    #[holder(use_place_holder)]
    SurfaceStyleSegmentationCurve(Box<SurfaceStyleSegmentationCurve>),
    #[holder(use_place_holder)]
    SurfaceStyleControlGrid(Box<SurfaceStyleControlGrid>),
    #[holder(use_place_holder)]
    SurfaceStyleParameterLine(Box<SurfaceStyleParameterLine>),
    #[holder(use_place_holder)]
    SurfaceStyleRendering(SurfaceStyleRenderingAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum SymbolStyleSelect {
    #[holder(use_place_holder)]
    SymbolColour(Box<SymbolColour>),
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = text)]
#[holder(generate_deserialize)]
# [holder (from = String)]
pub struct Text(pub String);
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = text_alignment)]
#[holder(generate_deserialize)]
# [holder (inner = Label)]
pub struct TextAlignment(#[holder(use_place_holder)] pub Label);
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = text_delineation)]
#[holder(generate_deserialize)]
# [holder (inner = Label)]
pub struct TextDelineation(#[holder(use_place_holder)] pub Label);
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum TextOrCharacter {
    #[holder(use_place_holder)]
    AnnotationText(Box<AnnotationText>),
    #[holder(use_place_holder)]
    AnnotationTextCharacter(Box<AnnotationTextCharacter>),
    #[holder(use_place_holder)]
    CompositeText(CompositeTextAny),
    #[holder(use_place_holder)]
    TextLiteral(TextLiteralAny),
}
#[derive(Debug, Clone, PartialEq, :: ruststep_derive :: ToData, :: serde :: Deserialize)]
pub enum TextPath {
    Left,
    Right,
    Up,
    Down,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum TextStringRepresentationItem {
    #[holder(use_place_holder)]
    TextLiteral(TextLiteralAny),
    #[holder(use_place_holder)]
    AnnotationText(Box<AnnotationText>),
    #[holder(use_place_holder)]
    AnnotationTextCharacter(Box<AnnotationTextCharacter>),
    #[holder(use_place_holder)]
    CompositeText(CompositeTextAny),
    #[holder(use_place_holder)]
    Axis2Placement(Box<Axis2Placement>),
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = thermodynamic_temperature_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct ThermodynamicTemperatureMeasure(pub f64);
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum TimeIntervalItem {
    #[holder(use_place_holder)]
    Action(ActionAny),
    #[holder(use_place_holder)]
    TimeIntervalBasedEffectivity(Box<TimeIntervalBasedEffectivity>),
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = time_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct TimeMeasure(pub f64);
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ToleranceMethodDefinition {
    #[holder(use_place_holder)]
    ToleranceValue(Box<ToleranceValue>),
    #[holder(use_place_holder)]
    LimitsAndFits(Box<LimitsAndFits>),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum Transformation {
    #[holder(use_place_holder)]
    ItemDefinedTransformation(ItemDefinedTransformationAny),
    #[holder(use_place_holder)]
    FunctionallyDefinedTransformation(FunctionallyDefinedTransformationAny),
}
#[derive(Debug, Clone, PartialEq, :: ruststep_derive :: ToData, :: serde :: Deserialize)]
pub enum TransitionCode {
    Discontinuous,
    Continuous,
    ContSameGradient,
    ContSameGradientSameCurvature,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum TrimConditionSelect {
    #[holder(use_place_holder)]
    LengthMeasure(Box<LengthMeasure>),
    #[holder(use_place_holder)]
    PlaneAngleMeasure(Box<PlaneAngleMeasure>),
    #[holder(use_place_holder)]
    GeneralizedSurfaceSelect(Box<GeneralizedSurfaceSelect>),
    #[holder(use_place_holder)]
    SolidModel(SolidModelAny),
}
#[derive(Debug, Clone, PartialEq, :: ruststep_derive :: ToData, :: serde :: Deserialize)]
pub enum TrimIntent {
    Blind,
    Offset,
    ThroughAll,
    Unspecified,
    UpToNext,
}
#[derive(Debug, Clone, PartialEq, :: ruststep_derive :: ToData, :: serde :: Deserialize)]
pub enum TrimmingPreference {
    Cartesian,
    Parameter,
    Unspecified,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum TrimmingSelect {
    #[holder(use_place_holder)]
    CartesianPoint(Box<CartesianPoint>),
    #[holder(use_place_holder)]
    ParameterValue(Box<ParameterValue>),
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = u_direction_count)]
#[holder(generate_deserialize)]
# [holder (from = i64)]
pub struct UDirectionCount(pub i64);
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum Unit {
    #[holder(use_place_holder)]
    DerivedUnit(DerivedUnitAny),
    #[holder(use_place_holder)]
    NamedUnit(NamedUnitAny),
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = v_direction_count)]
#[holder(generate_deserialize)]
# [holder (from = i64)]
pub struct VDirectionCount(pub i64);
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ValueQualifier {
    #[holder(use_place_holder)]
    PrecisionQualifier(Box<PrecisionQualifier>),
    #[holder(use_place_holder)]
    TypeQualifier(Box<TypeQualifier>),
    #[holder(use_place_holder)]
    UncertaintyQualifier(UncertaintyQualifierAny),
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum VectorOrDirection {
    #[holder(use_place_holder)]
    Vector(Box<Vector>),
    #[holder(use_place_holder)]
    Direction(Box<Direction>),
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = velocity_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct VelocityMeasure(pub f64);
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = volume_measure)]
#[holder(generate_deserialize)]
# [holder (from = f64)]
pub struct VolumeMeasure(pub f64);
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = week_in_year_number)]
#[holder(generate_deserialize)]
# [holder (from = i64)]
pub struct WeekInYearNumber(pub i64);
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum WorkItem {
    #[holder(use_place_holder)]
    ProductDefinitionFormation(ProductDefinitionFormationAny),
}
#[derive(
    Clone, Debug, PartialEq, AsRef, Deref, DerefMut, Into, From, :: ruststep_derive :: Holder,
)]
# [holder (table = Tables)]
# [holder (field = year_number)]
#[holder(generate_deserialize)]
# [holder (from = i64)]
pub struct YearNumber(pub i64);
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = absorbed_dose_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct AbsorbedDoseMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = absorbed_dose_unit)]
#[holder(generate_deserialize)]
pub struct AbsorbedDoseUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum AbsorbedDoseUnitAny {
    #[holder(use_place_holder)]
    AbsorbedDoseUnit(Box<AbsorbedDoseUnit>),
    #[holder(use_place_holder)]
    SiAbsorbedDoseUnit(Box<SiAbsorbedDoseUnit>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = abstract_variable)]
#[holder(generate_deserialize)]
pub struct AbstractVariable {
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition")]
    pub definition: CharacterizedDefinition,
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition_representation")]
    pub used_representation: RepresentationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum AbstractVariableAny {
    #[holder(use_place_holder)]
    AbstractVariable(Box<AbstractVariable>),
    #[holder(use_place_holder)]
    RowVariable(Box<RowVariable>),
    #[holder(use_place_holder)]
    ScalarVariable(Box<ScalarVariable>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = acceleration_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct AccelerationMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = acceleration_unit)]
#[holder(generate_deserialize)]
pub struct AccelerationUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = action)]
#[holder(generate_deserialize)]
pub struct Action {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub chosen_method: ActionMethodAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ActionAny {
    #[holder(use_place_holder)]
    Action(Box<Action>),
    #[holder(use_place_holder)]
    ExecutedAction(Box<ExecutedActionAny>),
    #[holder(use_place_holder)]
    RuleAction(Box<RuleActionAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = action_assignment)]
#[holder(generate_deserialize)]
pub struct ActionAssignment {
    #[holder(use_place_holder)]
    pub assigned_action: ActionAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ActionAssignmentAny {
    #[holder(use_place_holder)]
    ActionAssignment(Box<ActionAssignment>),
    #[holder(use_place_holder)]
    AppliedActionAssignment(Box<AppliedActionAssignmentAny>),
    #[holder(use_place_holder)]
    Change(Box<Change>),
    #[holder(use_place_holder)]
    RuleSupersededAssignment(Box<RuleSupersededAssignment>),
    #[holder(use_place_holder)]
    StartWork(Box<StartWork>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = action_directive)]
#[holder(generate_deserialize)]
pub struct ActionDirective {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub analysis: Text,
    #[holder(use_place_holder)]
    pub comment: Text,
    #[holder(use_place_holder)]
    pub requests: Vec<VersionedActionRequest>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = action_method)]
#[holder(generate_deserialize)]
pub struct ActionMethod {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub consequence: Text,
    #[holder(use_place_holder)]
    pub purpose: Text,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ActionMethodAny {
    #[holder(use_place_holder)]
    ActionMethod(Box<ActionMethod>),
    #[holder(use_place_holder)]
    InformationRight(Box<InformationRight>),
    #[holder(use_place_holder)]
    InformationUsageRight(Box<InformationUsageRight>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = action_method_assignment)]
#[holder(generate_deserialize)]
pub struct ActionMethodAssignment {
    #[holder(use_place_holder)]
    pub assigned_action_method: ActionMethodAny,
    #[holder(use_place_holder)]
    pub role: ActionMethodRole,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ActionMethodAssignmentAny {
    #[holder(use_place_holder)]
    ActionMethodAssignment(Box<ActionMethodAssignment>),
    #[holder(use_place_holder)]
    AppliedActionMethodAssignment(Box<AppliedActionMethodAssignment>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = action_method_relationship)]
#[holder(generate_deserialize)]
pub struct ActionMethodRelationship {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub relating_method: ActionMethodAny,
    #[holder(use_place_holder)]
    pub related_method: ActionMethodAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ActionMethodRelationshipAny {
    #[holder(use_place_holder)]
    ActionMethodRelationship(Box<ActionMethodRelationship>),
    #[holder(use_place_holder)]
    RightToUsageAssociation(Box<RightToUsageAssociation>),
    #[holder(use_place_holder)]
    UsageAssociation(Box<UsageAssociation>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = action_method_role)]
#[holder(generate_deserialize)]
pub struct ActionMethodRole {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = action_property)]
#[holder(generate_deserialize)]
pub struct ActionProperty {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Text,
    #[holder(use_place_holder)]
    pub definition: CharacterizedActionDefinition,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = action_property_representation)]
#[holder(generate_deserialize)]
pub struct ActionPropertyRepresentation {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Text,
    #[holder(use_place_holder)]
    pub property: ActionProperty,
    #[holder(use_place_holder)]
    pub representation: RepresentationAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = action_relationship)]
#[holder(generate_deserialize)]
pub struct ActionRelationship {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub relating_action: ActionAny,
    #[holder(use_place_holder)]
    pub related_action: ActionAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = action_request_assignment)]
#[holder(generate_deserialize)]
pub struct ActionRequestAssignment {
    #[holder(use_place_holder)]
    pub assigned_action_request: VersionedActionRequest,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ActionRequestAssignmentAny {
    #[holder(use_place_holder)]
    ActionRequestAssignment(Box<ActionRequestAssignment>),
    #[holder(use_place_holder)]
    AppliedActionRequestAssignment(Box<AppliedActionRequestAssignment>),
    #[holder(use_place_holder)]
    ChangeRequest(Box<ChangeRequest>),
    #[holder(use_place_holder)]
    StartRequest(Box<StartRequest>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = action_request_solution)]
#[holder(generate_deserialize)]
pub struct ActionRequestSolution {
    #[holder(use_place_holder)]
    pub method: ActionMethodAny,
    #[holder(use_place_holder)]
    pub request: VersionedActionRequest,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = action_request_status)]
#[holder(generate_deserialize)]
pub struct ActionRequestStatus {
    #[holder(use_place_holder)]
    pub status: Label,
    #[holder(use_place_holder)]
    pub assigned_request: VersionedActionRequest,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = action_status)]
#[holder(generate_deserialize)]
pub struct ActionStatus {
    #[holder(use_place_holder)]
    pub status: Label,
    #[holder(use_place_holder)]
    pub assigned_action: ExecutedActionAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = address)]
#[holder(generate_deserialize)]
pub struct Address {
    #[holder(use_place_holder)]
    pub internal_location: Option<Label>,
    #[holder(use_place_holder)]
    pub street_number: Option<Label>,
    #[holder(use_place_holder)]
    pub street: Option<Label>,
    #[holder(use_place_holder)]
    pub postal_box: Option<Label>,
    #[holder(use_place_holder)]
    pub town: Option<Label>,
    #[holder(use_place_holder)]
    pub region: Option<Label>,
    #[holder(use_place_holder)]
    pub postal_code: Option<Label>,
    #[holder(use_place_holder)]
    pub country: Option<Label>,
    #[holder(use_place_holder)]
    pub facsimile_number: Option<Label>,
    #[holder(use_place_holder)]
    pub telephone_number: Option<Label>,
    #[holder(use_place_holder)]
    pub electronic_mail_address: Option<Label>,
    #[holder(use_place_holder)]
    pub telex_number: Option<Label>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum AddressAny {
    #[holder(use_place_holder)]
    Address(Box<Address>),
    #[holder(use_place_holder)]
    OrganizationalAddress(Box<OrganizationalAddressAny>),
    #[holder(use_place_holder)]
    PersonalAddress(Box<PersonalAddressAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = advanced_brep_shape_representation)]
#[holder(generate_deserialize)]
pub struct AdvancedBrepShapeRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = advanced_face)]
#[holder(generate_deserialize)]
pub struct AdvancedFace {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "face")]
    pub bounds: Vec<FaceBoundAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "face_surface")]
    pub face_geometry: SurfaceAny,
    #[holder(supertype = "face_surface")]
    pub same_sense: bool,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = alternate_product_relationship)]
#[holder(generate_deserialize)]
pub struct AlternateProductRelationship {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub definition: Option<Text>,
    #[holder(use_place_holder)]
    pub alternate: Product,
    #[holder(use_place_holder)]
    pub base: Product,
    #[holder(use_place_holder)]
    pub basis: Text,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = amount_of_substance_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct AmountOfSubstanceMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = amount_of_substance_unit)]
#[holder(generate_deserialize)]
pub struct AmountOfSubstanceUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "named_unit")]
    pub dimensions: DimensionalExponents,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = angle_direction_reference)]
#[holder(generate_deserialize)]
pub struct AngleDirectionReference {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item_relationship")]
    pub relating_representation_item: RepresentationItemAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item_relationship")]
    pub related_representation_item: RepresentationItemAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = angular_dimension)]
#[holder(generate_deserialize)]
pub struct AngularDimension {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "draughting_callout")]
    pub contents: Vec<DraughtingCalloutElement>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = angular_location)]
#[holder(generate_deserialize)]
pub struct AngularLocation {
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect_relationship")]
    pub relating_shape_aspect: ShapeAspectAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect_relationship")]
    pub related_shape_aspect: ShapeAspectAny,
    pub angle_selection: AngleRelator,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = angular_size)]
#[holder(generate_deserialize)]
pub struct AngularSize {
    #[holder(use_place_holder)]
    #[holder(supertype = "dimensional_size")]
    pub applies_to: ShapeAspectAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "dimensional_size")]
    pub name: Label,
    pub angle_selection: AngleRelator,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = angularity_tolerance)]
#[holder(generate_deserialize)]
pub struct AngularityTolerance {
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub description: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub magnitude: MeasureWithUnitAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub toleranced_shape_aspect: ShapeAspectAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance_with_datum_reference")]
    pub datum_system: Vec<DatumReferenceAny>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = annotation_curve_occurrence)]
#[holder(generate_deserialize)]
pub struct AnnotationCurveOccurrence {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "styled_item")]
    pub styles: Vec<PresentationStyleAssignmentAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "styled_item")]
    pub item: RepresentationItemAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum AnnotationCurveOccurrenceAny {
    #[holder(use_place_holder)]
    AnnotationCurveOccurrence(Box<AnnotationCurveOccurrence>),
    #[holder(use_place_holder)]
    DimensionCurve(Box<DimensionCurve>),
    #[holder(use_place_holder)]
    LeaderCurve(Box<LeaderCurve>),
    #[holder(use_place_holder)]
    ProjectionCurve(Box<ProjectionCurve>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = annotation_fill_area)]
#[holder(generate_deserialize)]
pub struct AnnotationFillArea {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub boundaries: Vec<CurveAny>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = annotation_fill_area_occurrence)]
#[holder(generate_deserialize)]
pub struct AnnotationFillAreaOccurrence {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "styled_item")]
    pub styles: Vec<PresentationStyleAssignmentAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "styled_item")]
    pub item: RepresentationItemAny,
    #[holder(use_place_holder)]
    pub fill_style_target: PointAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = annotation_occurrence)]
#[holder(generate_deserialize)]
pub struct AnnotationOccurrence {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "styled_item")]
    pub styles: Vec<PresentationStyleAssignmentAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "styled_item")]
    pub item: RepresentationItemAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum AnnotationOccurrenceAny {
    #[holder(use_place_holder)]
    AnnotationOccurrence(Box<AnnotationOccurrence>),
    #[holder(use_place_holder)]
    AnnotationCurveOccurrence(Box<AnnotationCurveOccurrenceAny>),
    #[holder(use_place_holder)]
    AnnotationFillAreaOccurrence(Box<AnnotationFillAreaOccurrence>),
    #[holder(use_place_holder)]
    AnnotationPlane(Box<AnnotationPlane>),
    #[holder(use_place_holder)]
    AnnotationSymbolOccurrence(Box<AnnotationSymbolOccurrenceAny>),
    #[holder(use_place_holder)]
    AnnotationTextOccurrence(Box<AnnotationTextOccurrence>),
    #[holder(use_place_holder)]
    DraughtingAnnotationOccurrence(Box<DraughtingAnnotationOccurrence>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = annotation_occurrence_associativity)]
#[holder(generate_deserialize)]
pub struct AnnotationOccurrenceAssociativity {
    #[holder(use_place_holder)]
    #[holder(supertype = "annotation_occurrence_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "annotation_occurrence_relationship")]
    pub description: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "annotation_occurrence_relationship")]
    pub relating_annotation_occurrence: AnnotationOccurrenceAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "annotation_occurrence_relationship")]
    pub related_annotation_occurrence: AnnotationOccurrenceAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum AnnotationOccurrenceAssociativityAny {
    #[holder(use_place_holder)]
    AnnotationOccurrenceAssociativity(Box<AnnotationOccurrenceAssociativity>),
    #[holder(use_place_holder)]
    DimensionCurveTerminatorToProjectionCurveAssociativity(
        Box<DimensionCurveTerminatorToProjectionCurveAssociativity>,
    ),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = annotation_occurrence_relationship)]
#[holder(generate_deserialize)]
pub struct AnnotationOccurrenceRelationship {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Text,
    #[holder(use_place_holder)]
    pub relating_annotation_occurrence: AnnotationOccurrenceAny,
    #[holder(use_place_holder)]
    pub related_annotation_occurrence: AnnotationOccurrenceAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum AnnotationOccurrenceRelationshipAny {
    #[holder(use_place_holder)]
    AnnotationOccurrenceRelationship(Box<AnnotationOccurrenceRelationship>),
    #[holder(use_place_holder)]
    AnnotationOccurrenceAssociativity(Box<AnnotationOccurrenceAssociativityAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = annotation_plane)]
#[holder(generate_deserialize)]
pub struct AnnotationPlane {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "styled_item")]
    pub styles: Vec<PresentationStyleAssignmentAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "styled_item")]
    pub item: RepresentationItemAny,
    #[holder(use_place_holder)]
    pub elements: Option<Vec<AnnotationPlaneElement>>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = annotation_subfigure_occurrence)]
#[holder(generate_deserialize)]
pub struct AnnotationSubfigureOccurrence {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "styled_item")]
    pub styles: Vec<PresentationStyleAssignmentAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "styled_item")]
    pub item: RepresentationItemAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = annotation_symbol)]
#[holder(generate_deserialize)]
pub struct AnnotationSymbol {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "mapped_item")]
    pub mapping_source: RepresentationMapAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "mapped_item")]
    pub mapping_target: RepresentationItemAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = annotation_symbol_occurrence)]
#[holder(generate_deserialize)]
pub struct AnnotationSymbolOccurrence {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "styled_item")]
    pub styles: Vec<PresentationStyleAssignmentAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "styled_item")]
    pub item: RepresentationItemAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum AnnotationSymbolOccurrenceAny {
    #[holder(use_place_holder)]
    AnnotationSymbolOccurrence(Box<AnnotationSymbolOccurrence>),
    #[holder(use_place_holder)]
    AnnotationSubfigureOccurrence(Box<AnnotationSubfigureOccurrence>),
    #[holder(use_place_holder)]
    TerminatorSymbol(Box<TerminatorSymbolAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = annotation_text)]
#[holder(generate_deserialize)]
pub struct AnnotationText {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "mapped_item")]
    pub mapping_source: RepresentationMapAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "mapped_item")]
    pub mapping_target: RepresentationItemAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = annotation_text_character)]
#[holder(generate_deserialize)]
pub struct AnnotationTextCharacter {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "mapped_item")]
    pub mapping_source: RepresentationMapAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "mapped_item")]
    pub mapping_target: RepresentationItemAny,
    #[holder(use_place_holder)]
    pub alignment: TextAlignment,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = annotation_text_occurrence)]
#[holder(generate_deserialize)]
pub struct AnnotationTextOccurrence {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "styled_item")]
    pub styles: Vec<PresentationStyleAssignmentAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "styled_item")]
    pub item: RepresentationItemAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = apex)]
#[holder(generate_deserialize)]
pub struct Apex {
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub of_shape: ProductDefinitionShape,
    #[holder(supertype = "shape_aspect")]
    pub product_definitional: Logical,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = application_context)]
#[holder(generate_deserialize)]
pub struct ApplicationContext {
    #[holder(use_place_holder)]
    pub application: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = application_context_element)]
#[holder(generate_deserialize)]
pub struct ApplicationContextElement {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub frame_of_reference: ApplicationContext,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ApplicationContextElementAny {
    #[holder(use_place_holder)]
    ApplicationContextElement(Box<ApplicationContextElement>),
    #[holder(use_place_holder)]
    ProductConceptContext(Box<ProductConceptContext>),
    #[holder(use_place_holder)]
    ProductContext(Box<ProductContextAny>),
    #[holder(use_place_holder)]
    ProductDefinitionContext(Box<ProductDefinitionContextAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = application_protocol_definition)]
#[holder(generate_deserialize)]
pub struct ApplicationProtocolDefinition {
    #[holder(use_place_holder)]
    pub status: Label,
    #[holder(use_place_holder)]
    pub application_interpreted_model_schema_name: Label,
    #[holder(use_place_holder)]
    pub application_protocol_year: YearNumber,
    #[holder(use_place_holder)]
    pub application: ApplicationContext,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = applied_action_assignment)]
#[holder(generate_deserialize)]
pub struct AppliedActionAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "action_assignment")]
    pub assigned_action: ActionAny,
    #[holder(use_place_holder)]
    pub items: Vec<ActionItems>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum AppliedActionAssignmentAny {
    #[holder(use_place_holder)]
    AppliedActionAssignment(Box<AppliedActionAssignment>),
    #[holder(use_place_holder)]
    AppliedUsageRight(Box<AppliedUsageRight>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = applied_action_method_assignment)]
#[holder(generate_deserialize)]
pub struct AppliedActionMethodAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "action_method_assignment")]
    pub assigned_action_method: ActionMethodAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "action_method_assignment")]
    pub role: ActionMethodRole,
    #[holder(use_place_holder)]
    pub items: Vec<ActionMethodItems>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = applied_action_request_assignment)]
#[holder(generate_deserialize)]
pub struct AppliedActionRequestAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "action_request_assignment")]
    pub assigned_action_request: VersionedActionRequest,
    #[holder(use_place_holder)]
    pub items: Vec<ActionRequestItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = applied_approval_assignment)]
#[holder(generate_deserialize)]
pub struct AppliedApprovalAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "approval_assignment")]
    pub assigned_approval: Approval,
    #[holder(use_place_holder)]
    pub items: Vec<ApprovalItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = applied_attribute_classification_assignment)]
#[holder(generate_deserialize)]
pub struct AppliedAttributeClassificationAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "attribute_classification_assignment")]
    pub assigned_class: GroupAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "attribute_classification_assignment")]
    pub attribute_name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "attribute_classification_assignment")]
    pub role: ClassificationRole,
    #[holder(use_place_holder)]
    pub items: Vec<AttributeClassificationItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = applied_certification_assignment)]
#[holder(generate_deserialize)]
pub struct AppliedCertificationAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "certification_assignment")]
    pub assigned_certification: Certification,
    #[holder(use_place_holder)]
    pub items: Vec<CertificationItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = applied_classification_assignment)]
#[holder(generate_deserialize)]
pub struct AppliedClassificationAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "classification_assignment")]
    pub assigned_class: GroupAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "classification_assignment")]
    pub role: ClassificationRole,
    #[holder(use_place_holder)]
    pub items: Vec<ClassificationItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = applied_contract_assignment)]
#[holder(generate_deserialize)]
pub struct AppliedContractAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "contract_assignment")]
    pub assigned_contract: Contract,
    #[holder(use_place_holder)]
    pub items: Vec<ContractItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = applied_date_and_time_assignment)]
#[holder(generate_deserialize)]
pub struct AppliedDateAndTimeAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "date_and_time_assignment")]
    pub assigned_date_and_time: DateAndTimeAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "date_and_time_assignment")]
    pub role: DateTimeRole,
    #[holder(use_place_holder)]
    pub items: Vec<DateAndTimeItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = applied_date_assignment)]
#[holder(generate_deserialize)]
pub struct AppliedDateAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "date_assignment")]
    pub assigned_date: DateAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "date_assignment")]
    pub role: DateRole,
    #[holder(use_place_holder)]
    pub items: Vec<DateItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = applied_document_reference)]
#[holder(generate_deserialize)]
pub struct AppliedDocumentReference {
    #[holder(use_place_holder)]
    #[holder(supertype = "document_reference")]
    pub assigned_document: DocumentAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "document_reference")]
    pub source: Label,
    #[holder(use_place_holder)]
    pub items: Vec<DocumentReferenceItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = applied_document_usage_constraint_assignment)]
#[holder(generate_deserialize)]
pub struct AppliedDocumentUsageConstraintAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "document_usage_constraint_assignment")]
    pub assigned_document_usage: DocumentUsageConstraint,
    #[holder(use_place_holder)]
    #[holder(supertype = "document_usage_constraint_assignment")]
    pub role: DocumentUsageRole,
    #[holder(use_place_holder)]
    pub items: Vec<DocumentReferenceItem>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum AppliedDocumentUsageConstraintAssignmentAny {
    #[holder(use_place_holder)]
    AppliedDocumentUsageConstraintAssignment(Box<AppliedDocumentUsageConstraintAssignment>),
    #[holder(use_place_holder)]
    PartialDocumentWithStructuredTextRepresentationAssignment(
        Box<PartialDocumentWithStructuredTextRepresentationAssignment>,
    ),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = applied_effectivity_assignment)]
#[holder(generate_deserialize)]
pub struct AppliedEffectivityAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "effectivity_assignment")]
    pub assigned_effectivity: EffectivityAny,
    #[holder(use_place_holder)]
    pub items: Vec<EffectivityItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = applied_event_occurrence_assignment)]
#[holder(generate_deserialize)]
pub struct AppliedEventOccurrenceAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "event_occurrence_assignment")]
    pub assigned_event_occurrence: EventOccurrenceAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "event_occurrence_assignment")]
    pub role: EventOccurrenceRole,
    #[holder(use_place_holder)]
    pub items: Vec<EventOccurrenceItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = applied_external_identification_assignment)]
#[holder(generate_deserialize)]
pub struct AppliedExternalIdentificationAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "identification_assignment")]
    pub assigned_id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "identification_assignment")]
    pub role: IdentificationRole,
    #[holder(use_place_holder)]
    #[holder(supertype = "external_identification_assignment")]
    pub source: ExternalSourceAny,
    #[holder(use_place_holder)]
    pub items: Vec<ExternalIdentificationItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = applied_group_assignment)]
#[holder(generate_deserialize)]
pub struct AppliedGroupAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "group_assignment")]
    pub assigned_group: GroupAny,
    #[holder(use_place_holder)]
    pub items: Vec<GroupableItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = applied_identification_assignment)]
#[holder(generate_deserialize)]
pub struct AppliedIdentificationAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "identification_assignment")]
    pub assigned_id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "identification_assignment")]
    pub role: IdentificationRole,
    #[holder(use_place_holder)]
    pub items: Vec<IdentificationItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = applied_name_assignment)]
#[holder(generate_deserialize)]
pub struct AppliedNameAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "name_assignment")]
    pub assigned_name: Label,
    #[holder(use_place_holder)]
    pub item: NameItem,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = applied_organization_assignment)]
#[holder(generate_deserialize)]
pub struct AppliedOrganizationAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "organization_assignment")]
    pub assigned_organization: Organization,
    #[holder(use_place_holder)]
    #[holder(supertype = "organization_assignment")]
    pub role: OrganizationRole,
    #[holder(use_place_holder)]
    pub items: Vec<OrganizationItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = applied_organizational_project_assignment)]
#[holder(generate_deserialize)]
pub struct AppliedOrganizationalProjectAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "organizational_project_assignment")]
    pub assigned_organizational_project: OrganizationalProject,
    #[holder(use_place_holder)]
    #[holder(supertype = "organizational_project_assignment")]
    pub role: OrganizationalProjectRole,
    #[holder(use_place_holder)]
    pub items: Vec<ProjectItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = applied_person_and_organization_assignment)]
#[holder(generate_deserialize)]
pub struct AppliedPersonAndOrganizationAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "person_and_organization_assignment")]
    pub assigned_person_and_organization: PersonAndOrganization,
    #[holder(use_place_holder)]
    #[holder(supertype = "person_and_organization_assignment")]
    pub role: PersonAndOrganizationRole,
    #[holder(use_place_holder)]
    pub items: Vec<PersonAndOrganizationItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = applied_presented_item)]
#[holder(generate_deserialize)]
pub struct AppliedPresentedItem {
    #[holder(use_place_holder)]
    pub items: Vec<PresentedItemSelect>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = applied_security_classification_assignment)]
#[holder(generate_deserialize)]
pub struct AppliedSecurityClassificationAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "security_classification_assignment")]
    pub assigned_security_classification: SecurityClassification,
    #[holder(use_place_holder)]
    pub items: Vec<SecurityClassificationItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = applied_time_interval_assignment)]
#[holder(generate_deserialize)]
pub struct AppliedTimeIntervalAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "time_interval_assignment")]
    pub assigned_time_interval: TimeIntervalAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "time_interval_assignment")]
    pub role: TimeIntervalRole,
    #[holder(use_place_holder)]
    pub items: Vec<TimeIntervalItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = applied_usage_right)]
#[holder(generate_deserialize)]
pub struct AppliedUsageRight {
    #[holder(use_place_holder)]
    #[holder(supertype = "action_assignment")]
    pub assigned_action: ActionAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "applied_action_assignment")]
    pub items: Vec<ActionItems>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = approval)]
#[holder(generate_deserialize)]
pub struct Approval {
    #[holder(use_place_holder)]
    pub status: ApprovalStatus,
    #[holder(use_place_holder)]
    pub level: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = approval_assignment)]
#[holder(generate_deserialize)]
pub struct ApprovalAssignment {
    #[holder(use_place_holder)]
    pub assigned_approval: Approval,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ApprovalAssignmentAny {
    #[holder(use_place_holder)]
    ApprovalAssignment(Box<ApprovalAssignment>),
    #[holder(use_place_holder)]
    AppliedApprovalAssignment(Box<AppliedApprovalAssignment>),
    #[holder(use_place_holder)]
    CcDesignApproval(Box<CcDesignApproval>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = approval_date_time)]
#[holder(generate_deserialize)]
pub struct ApprovalDateTime {
    #[holder(use_place_holder)]
    pub date_time: DateTimeSelect,
    #[holder(use_place_holder)]
    pub dated_approval: Approval,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = approval_person_organization)]
#[holder(generate_deserialize)]
pub struct ApprovalPersonOrganization {
    #[holder(use_place_holder)]
    pub person_organization: PersonOrganizationSelect,
    #[holder(use_place_holder)]
    pub authorized_approval: Approval,
    #[holder(use_place_holder)]
    pub role: ApprovalRole,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = approval_relationship)]
#[holder(generate_deserialize)]
pub struct ApprovalRelationship {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub relating_approval: Approval,
    #[holder(use_place_holder)]
    pub related_approval: Approval,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = approval_role)]
#[holder(generate_deserialize)]
pub struct ApprovalRole {
    #[holder(use_place_holder)]
    pub role: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = approval_status)]
#[holder(generate_deserialize)]
pub struct ApprovalStatus {
    #[holder(use_place_holder)]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = area_in_set)]
#[holder(generate_deserialize)]
pub struct AreaInSet {
    #[holder(use_place_holder)]
    pub area: PresentationAreaAny,
    #[holder(use_place_holder)]
    pub in_set: PresentationSetAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum AreaInSetAny {
    #[holder(use_place_holder)]
    AreaInSet(Box<AreaInSet>),
    #[holder(use_place_holder)]
    DrawingSheetRevisionUsage(Box<DrawingSheetRevisionUsage>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = area_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct AreaMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = area_unit)]
#[holder(generate_deserialize)]
pub struct AreaUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = assembly_component_usage)]
#[holder(generate_deserialize)]
pub struct AssemblyComponentUsage {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub relating_product_definition: ProductDefinitionAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub related_product_definition: ProductDefinitionAny,
    #[holder(use_place_holder)]
    pub reference_designator: Option<Identifier>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum AssemblyComponentUsageAny {
    #[holder(use_place_holder)]
    AssemblyComponentUsage(Box<AssemblyComponentUsage>),
    #[holder(use_place_holder)]
    NextAssemblyUsageOccurrence(Box<NextAssemblyUsageOccurrence>),
    #[holder(use_place_holder)]
    PromissoryUsageOccurrence(Box<PromissoryUsageOccurrence>),
    #[holder(use_place_holder)]
    QuantifiedAssemblyComponentUsage(Box<QuantifiedAssemblyComponentUsage>),
    #[holder(use_place_holder)]
    SpecifiedHigherUsageOccurrence(Box<SpecifiedHigherUsageOccurrence>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = assembly_component_usage_substitute)]
#[holder(generate_deserialize)]
pub struct AssemblyComponentUsageSubstitute {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub definition: Option<Text>,
    #[holder(use_place_holder)]
    pub base: AssemblyComponentUsageAny,
    #[holder(use_place_holder)]
    pub substitute: AssemblyComponentUsageAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = assigned_requirement)]
#[holder(generate_deserialize)]
pub struct AssignedRequirement {
    #[holder(use_place_holder)]
    #[holder(supertype = "group_assignment")]
    pub assigned_group: GroupAny,
    #[holder(use_place_holder)]
    pub items: Vec<ProductDefinitionAny>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = atomic_formula)]
#[holder(generate_deserialize)]
pub struct AtomicFormula {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "compound_representation_item")]
    pub item_element: CompoundItemDefinition,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum AtomicFormulaAny {
    #[holder(use_place_holder)]
    AtomicFormula(Box<AtomicFormula>),
    #[holder(use_place_holder)]
    GroundFact(Box<GroundFact>),
    #[holder(use_place_holder)]
    RuleCondition(Box<RuleCondition>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = attribute_assertion)]
#[holder(generate_deserialize)]
pub struct AttributeAssertion {
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition")]
    pub definition: CharacterizedDefinition,
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition_representation")]
    pub used_representation: RepresentationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = attribute_classification_assignment)]
#[holder(generate_deserialize)]
pub struct AttributeClassificationAssignment {
    #[holder(use_place_holder)]
    pub assigned_class: GroupAny,
    #[holder(use_place_holder)]
    pub attribute_name: Label,
    #[holder(use_place_holder)]
    pub role: ClassificationRole,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum AttributeClassificationAssignmentAny {
    #[holder(use_place_holder)]
    AttributeClassificationAssignment(Box<AttributeClassificationAssignment>),
    #[holder(use_place_holder)]
    AppliedAttributeClassificationAssignment(Box<AppliedAttributeClassificationAssignment>),
    #[holder(use_place_holder)]
    AttributeLanguageAssignment(Box<AttributeLanguageAssignment>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = attribute_language_assignment)]
#[holder(generate_deserialize)]
pub struct AttributeLanguageAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "attribute_classification_assignment")]
    pub assigned_class: GroupAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "attribute_classification_assignment")]
    pub attribute_name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "attribute_classification_assignment")]
    pub role: ClassificationRole,
    #[holder(use_place_holder)]
    pub items: Vec<AttributeLanguageItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = attribute_value_assignment)]
#[holder(generate_deserialize)]
pub struct AttributeValueAssignment {
    #[holder(use_place_holder)]
    pub attribute_name: Label,
    #[holder(use_place_holder)]
    pub attribute_value: AttributeType,
    #[holder(use_place_holder)]
    pub role: AttributeValueRole,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum AttributeValueAssignmentAny {
    #[holder(use_place_holder)]
    AttributeValueAssignment(Box<AttributeValueAssignment>),
    #[holder(use_place_holder)]
    MultiLanguageAttributeAssignment(Box<MultiLanguageAttributeAssignment>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = attribute_value_role)]
#[holder(generate_deserialize)]
pub struct AttributeValueRole {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = auxiliary_geometric_representation_item)]
#[holder(generate_deserialize)]
pub struct AuxiliaryGeometricRepresentationItem {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = axis1_placement)]
#[holder(generate_deserialize)]
pub struct Axis1Placement {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "placement")]
    pub location: CartesianPoint,
    #[holder(use_place_holder)]
    pub axis: Option<Direction>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = axis2_placement_2d)]
#[holder(generate_deserialize)]
pub struct Axis2Placement2D {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "placement")]
    pub location: CartesianPoint,
    #[holder(use_place_holder)]
    pub ref_direction: Option<Direction>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = axis2_placement_3d)]
#[holder(generate_deserialize)]
pub struct Axis2Placement3D {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "placement")]
    pub location: CartesianPoint,
    #[holder(use_place_holder)]
    pub axis: Option<Direction>,
    #[holder(use_place_holder)]
    pub ref_direction: Option<Direction>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = b_spline_curve)]
#[holder(generate_deserialize)]
pub struct BSplineCurve {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    pub degree: i64,
    #[holder(use_place_holder)]
    pub control_points_list: Vec<CartesianPoint>,
    pub curve_form: BSplineCurveForm,
    pub closed_curve: Logical,
    pub self_intersect: Logical,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum BSplineCurveAny {
    #[holder(use_place_holder)]
    BSplineCurve(Box<BSplineCurve>),
    #[holder(use_place_holder)]
    BSplineCurveWithKnots(Box<BSplineCurveWithKnots>),
    #[holder(use_place_holder)]
    BezierCurve(Box<BezierCurve>),
    #[holder(use_place_holder)]
    QuasiUniformCurve(Box<QuasiUniformCurve>),
    #[holder(use_place_holder)]
    RationalBSplineCurve(Box<RationalBSplineCurve>),
    #[holder(use_place_holder)]
    UniformCurve(Box<UniformCurve>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = b_spline_curve_with_knots)]
#[holder(generate_deserialize)]
pub struct BSplineCurveWithKnots {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(supertype = "b_spline_curve")]
    pub degree: i64,
    #[holder(use_place_holder)]
    #[holder(supertype = "b_spline_curve")]
    pub control_points_list: Vec<CartesianPoint>,
    #[holder(supertype = "b_spline_curve")]
    pub curve_form: BSplineCurveForm,
    #[holder(supertype = "b_spline_curve")]
    pub closed_curve: Logical,
    #[holder(supertype = "b_spline_curve")]
    pub self_intersect: Logical,
    pub knot_multiplicities: Vec<i64>,
    #[holder(use_place_holder)]
    pub knots: Vec<ParameterValue>,
    pub knot_spec: KnotType,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = b_spline_surface)]
#[holder(generate_deserialize)]
pub struct BSplineSurface {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    pub u_degree: i64,
    pub v_degree: i64,
    #[holder(use_place_holder)]
    pub control_points_list: Vec<Vec<CartesianPoint>>,
    pub surface_form: BSplineSurfaceForm,
    pub u_closed: Logical,
    pub v_closed: Logical,
    pub self_intersect: Logical,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum BSplineSurfaceAny {
    #[holder(use_place_holder)]
    BSplineSurface(Box<BSplineSurface>),
    #[holder(use_place_holder)]
    BSplineSurfaceWithKnots(Box<BSplineSurfaceWithKnots>),
    #[holder(use_place_holder)]
    BezierSurface(Box<BezierSurface>),
    #[holder(use_place_holder)]
    QuasiUniformSurface(Box<QuasiUniformSurface>),
    #[holder(use_place_holder)]
    RationalBSplineSurface(Box<RationalBSplineSurface>),
    #[holder(use_place_holder)]
    UniformSurface(Box<UniformSurface>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = b_spline_surface_with_knots)]
#[holder(generate_deserialize)]
pub struct BSplineSurfaceWithKnots {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(supertype = "b_spline_surface")]
    pub u_degree: i64,
    #[holder(supertype = "b_spline_surface")]
    pub v_degree: i64,
    #[holder(use_place_holder)]
    #[holder(supertype = "b_spline_surface")]
    pub control_points_list: Vec<Vec<CartesianPoint>>,
    #[holder(supertype = "b_spline_surface")]
    pub surface_form: BSplineSurfaceForm,
    #[holder(supertype = "b_spline_surface")]
    pub u_closed: Logical,
    #[holder(supertype = "b_spline_surface")]
    pub v_closed: Logical,
    #[holder(supertype = "b_spline_surface")]
    pub self_intersect: Logical,
    pub u_multiplicities: Vec<i64>,
    pub v_multiplicities: Vec<i64>,
    #[holder(use_place_holder)]
    pub u_knots: Vec<ParameterValue>,
    #[holder(use_place_holder)]
    pub v_knots: Vec<ParameterValue>,
    pub knot_spec: KnotType,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = back_chaining_rule)]
#[holder(generate_deserialize)]
pub struct BackChainingRule {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub formation: ProductDefinitionFormationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub frame_of_reference: ProductDefinitionContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = back_chaining_rule_body)]
#[holder(generate_deserialize)]
pub struct BackChainingRuleBody {
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition")]
    pub definition: CharacterizedDefinition,
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition_representation")]
    pub used_representation: RepresentationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = background_colour)]
#[holder(generate_deserialize)]
pub struct BackgroundColour {
    #[holder(use_place_holder)]
    pub presentation: AreaOrView,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = beveled_sheet_representation)]
#[holder(generate_deserialize)]
pub struct BeveledSheetRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = bezier_curve)]
#[holder(generate_deserialize)]
pub struct BezierCurve {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(supertype = "b_spline_curve")]
    pub degree: i64,
    #[holder(use_place_holder)]
    #[holder(supertype = "b_spline_curve")]
    pub control_points_list: Vec<CartesianPoint>,
    #[holder(supertype = "b_spline_curve")]
    pub curve_form: BSplineCurveForm,
    #[holder(supertype = "b_spline_curve")]
    pub closed_curve: Logical,
    #[holder(supertype = "b_spline_curve")]
    pub self_intersect: Logical,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = bezier_surface)]
#[holder(generate_deserialize)]
pub struct BezierSurface {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(supertype = "b_spline_surface")]
    pub u_degree: i64,
    #[holder(supertype = "b_spline_surface")]
    pub v_degree: i64,
    #[holder(use_place_holder)]
    #[holder(supertype = "b_spline_surface")]
    pub control_points_list: Vec<Vec<CartesianPoint>>,
    #[holder(supertype = "b_spline_surface")]
    pub surface_form: BSplineSurfaceForm,
    #[holder(supertype = "b_spline_surface")]
    pub u_closed: Logical,
    #[holder(supertype = "b_spline_surface")]
    pub v_closed: Logical,
    #[holder(supertype = "b_spline_surface")]
    pub self_intersect: Logical,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = binary_generic_expression)]
#[holder(generate_deserialize)]
pub struct BinaryGenericExpression {
    #[holder(use_place_holder)]
    pub operands: Vec<GenericExpressionAny>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum BinaryGenericExpressionAny {
    #[holder(use_place_holder)]
    BinaryGenericExpression(Box<BinaryGenericExpression>),
    #[holder(use_place_holder)]
    BinaryNumericExpression(Box<BinaryNumericExpressionAny>),
    #[holder(use_place_holder)]
    ComparisonExpression(Box<ComparisonExpression>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = binary_numeric_expression)]
#[holder(generate_deserialize)]
pub struct BinaryNumericExpression {
    #[holder(use_place_holder)]
    #[holder(supertype = "binary_generic_expression")]
    pub operands: Vec<GenericExpressionAny>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum BinaryNumericExpressionAny {
    #[holder(use_place_holder)]
    BinaryNumericExpression(Box<BinaryNumericExpression>),
    #[holder(use_place_holder)]
    SlashExpression(Box<SlashExpressionAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = binary_representation_item)]
#[holder(generate_deserialize)]
pub struct BinaryRepresentationItem {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    pub binary_value: Binary,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum BinaryRepresentationItemAny {
    #[holder(use_place_holder)]
    BinaryRepresentationItem(Box<BinaryRepresentationItem>),
    #[holder(use_place_holder)]
    BytesRepresentationItem(Box<BytesRepresentationItemAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = block)]
#[holder(generate_deserialize)]
pub struct Block {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub position: Axis2Placement3D,
    #[holder(use_place_holder)]
    pub x: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    pub y: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    pub z: PositiveLengthMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = boolean_expression)]
#[holder(generate_deserialize)]
pub struct BooleanExpression {}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum BooleanExpressionAny {
    #[holder(use_place_holder)]
    BooleanExpression(Box<BooleanExpression>),
    #[holder(use_place_holder)]
    ComparisonExpression(Box<ComparisonExpression>),
    #[holder(use_place_holder)]
    IntervalExpression(Box<IntervalExpression>),
    #[holder(use_place_holder)]
    MultipleArityBooleanExpression(Box<MultipleArityBooleanExpression>),
    #[holder(use_place_holder)]
    SimpleBooleanExpression(Box<SimpleBooleanExpressionAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = boolean_literal)]
#[holder(generate_deserialize)]
pub struct BooleanLiteral {
    pub the_value: bool,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum BooleanLiteralAny {
    #[holder(use_place_holder)]
    BooleanLiteral(Box<BooleanLiteral>),
    #[holder(use_place_holder)]
    BooleanRepresentationItem(Box<BooleanRepresentationItem>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = boolean_representation_item)]
#[holder(generate_deserialize)]
pub struct BooleanRepresentationItem {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(supertype = "boolean_literal")]
    pub the_value: bool,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = boolean_result)]
#[holder(generate_deserialize)]
pub struct BooleanResult {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    pub operator: BooleanOperator,
    #[holder(use_place_holder)]
    pub first_operand: BooleanOperand,
    #[holder(use_place_holder)]
    pub second_operand: BooleanOperand,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = boundary_curve)]
#[holder(generate_deserialize)]
pub struct BoundaryCurve {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "composite_curve")]
    pub segments: Vec<CompositeCurveSegmentAny>,
    #[holder(supertype = "composite_curve")]
    pub self_intersect: Logical,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum BoundaryCurveAny {
    #[holder(use_place_holder)]
    BoundaryCurve(Box<BoundaryCurve>),
    #[holder(use_place_holder)]
    OuterBoundaryCurve(Box<OuterBoundaryCurve>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = bounded_curve)]
#[holder(generate_deserialize)]
pub struct BoundedCurve {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum BoundedCurveAny {
    #[holder(use_place_holder)]
    BoundedCurve(Box<BoundedCurve>),
    #[holder(use_place_holder)]
    BSplineCurve(Box<BSplineCurveAny>),
    #[holder(use_place_holder)]
    BoundedPcurve(Box<BoundedPcurve>),
    #[holder(use_place_holder)]
    BoundedSurfaceCurve(Box<BoundedSurfaceCurve>),
    #[holder(use_place_holder)]
    CompositeCurve(Box<CompositeCurveAny>),
    #[holder(use_place_holder)]
    Polyline(Box<Polyline>),
    #[holder(use_place_holder)]
    TrimmedCurve(Box<TrimmedCurve>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = bounded_pcurve)]
#[holder(generate_deserialize)]
pub struct BoundedPcurve {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "pcurve")]
    pub basis_surface: SurfaceAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "pcurve")]
    pub reference_to_curve: DefinitionalRepresentation,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = bounded_surface)]
#[holder(generate_deserialize)]
pub struct BoundedSurface {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum BoundedSurfaceAny {
    #[holder(use_place_holder)]
    BoundedSurface(Box<BoundedSurface>),
    #[holder(use_place_holder)]
    BSplineSurface(Box<BSplineSurfaceAny>),
    #[holder(use_place_holder)]
    CurveBoundedSurface(Box<CurveBoundedSurface>),
    #[holder(use_place_holder)]
    RectangularCompositeSurface(Box<RectangularCompositeSurface>),
    #[holder(use_place_holder)]
    RectangularTrimmedSurface(Box<RectangularTrimmedSurface>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = bounded_surface_curve)]
#[holder(generate_deserialize)]
pub struct BoundedSurfaceCurve {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "surface_curve")]
    pub curve_3d: CurveAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "surface_curve")]
    pub associated_geometry: Vec<PcurveOrSurface>,
    #[holder(supertype = "surface_curve")]
    pub master_representation: PreferredSurfaceCurveRepresentation,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = box_domain)]
#[holder(generate_deserialize)]
pub struct BoxDomain {
    #[holder(use_place_holder)]
    pub corner: CartesianPoint,
    #[holder(use_place_holder)]
    pub xlength: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    pub ylength: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    pub zlength: PositiveLengthMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = boxed_half_space)]
#[holder(generate_deserialize)]
pub struct BoxedHalfSpace {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "half_space_solid")]
    pub base_surface: SurfaceAny,
    #[holder(supertype = "half_space_solid")]
    pub agreement_flag: bool,
    #[holder(use_place_holder)]
    pub enclosure: BoxDomain,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = breakdown_context)]
#[holder(generate_deserialize)]
pub struct BreakdownContext {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub relating_product_definition: ProductDefinitionAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub related_product_definition: ProductDefinitionAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum BreakdownContextAny {
    #[holder(use_place_holder)]
    BreakdownContext(Box<BreakdownContext>),
    #[holder(use_place_holder)]
    FunctionalBreakdownContext(Box<FunctionalBreakdownContext>),
    #[holder(use_place_holder)]
    PhysicalBreakdownContext(Box<PhysicalBreakdownContext>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = breakdown_element_group_assignment)]
#[holder(generate_deserialize)]
pub struct BreakdownElementGroupAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "group_assignment")]
    pub assigned_group: GroupAny,
    #[holder(use_place_holder)]
    pub items: Vec<ProductDefinitionOrBreakdownElementUsage>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = breakdown_element_realization)]
#[holder(generate_deserialize)]
pub struct BreakdownElementRealization {
    #[holder(use_place_holder)]
    #[holder(supertype = "characterized_object")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "characterized_object")]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = breakdown_element_usage)]
#[holder(generate_deserialize)]
pub struct BreakdownElementUsage {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub relating_product_definition: ProductDefinitionAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub related_product_definition: ProductDefinitionAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum BreakdownElementUsageAny {
    #[holder(use_place_holder)]
    BreakdownElementUsage(Box<BreakdownElementUsage>),
    #[holder(use_place_holder)]
    FunctionalElementUsage(Box<FunctionalElementUsage>),
    #[holder(use_place_holder)]
    PhysicalElementUsage(Box<PhysicalElementUsage>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = breakdown_of)]
#[holder(generate_deserialize)]
pub struct BreakdownOf {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub relating_product_definition: ProductDefinitionAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub related_product_definition: ProductDefinitionAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = brep_with_voids)]
#[holder(generate_deserialize)]
pub struct BrepWithVoids {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "manifold_solid_brep")]
    pub outer: ClosedShellAny,
    #[holder(use_place_holder)]
    pub voids: Vec<OrientedClosedShell>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = bytes_representation_item)]
#[holder(generate_deserialize)]
pub struct BytesRepresentationItem {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(supertype = "binary_representation_item")]
    pub binary_value: Binary,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum BytesRepresentationItemAny {
    #[holder(use_place_holder)]
    BytesRepresentationItem(Box<BytesRepresentationItem>),
    #[holder(use_place_holder)]
    PictureRepresentationItem(Box<PictureRepresentationItemAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = calendar_date)]
#[holder(generate_deserialize)]
pub struct CalendarDate {
    #[holder(use_place_holder)]
    #[holder(supertype = "date")]
    pub year_component: YearNumber,
    #[holder(use_place_holder)]
    pub day_component: DayInMonthNumber,
    #[holder(use_place_holder)]
    pub month_component: MonthInYearNumber,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = camera_image)]
#[holder(generate_deserialize)]
pub struct CameraImage {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "mapped_item")]
    pub mapping_source: RepresentationMapAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "mapped_item")]
    pub mapping_target: RepresentationItemAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CameraImageAny {
    #[holder(use_place_holder)]
    CameraImage(Box<CameraImage>),
    #[holder(use_place_holder)]
    CameraImage3DWithScale(Box<CameraImage3DWithScale>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = camera_image_3d_with_scale)]
#[holder(generate_deserialize)]
pub struct CameraImage3DWithScale {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "mapped_item")]
    pub mapping_source: RepresentationMapAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "mapped_item")]
    pub mapping_target: RepresentationItemAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = camera_model)]
#[holder(generate_deserialize)]
pub struct CameraModel {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CameraModelAny {
    #[holder(use_place_holder)]
    CameraModel(Box<CameraModel>),
    #[holder(use_place_holder)]
    CameraModelD3(Box<CameraModelD3Any>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = camera_model_d3)]
#[holder(generate_deserialize)]
pub struct CameraModelD3 {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub view_reference_system: Axis2Placement3D,
    #[holder(use_place_holder)]
    pub perspective_of_volume: ViewVolume,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CameraModelD3Any {
    #[holder(use_place_holder)]
    CameraModelD3(Box<CameraModelD3>),
    #[holder(use_place_holder)]
    CameraModelD3MultiClipping(Box<CameraModelD3MultiClipping>),
    #[holder(use_place_holder)]
    CameraModelD3WithHlhsr(Box<CameraModelD3WithHlhsr>),
    #[holder(use_place_holder)]
    CameraModelWithLightSources(Box<CameraModelWithLightSources>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = camera_model_d3_multi_clipping)]
#[holder(generate_deserialize)]
pub struct CameraModelD3MultiClipping {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "camera_model_d3")]
    pub view_reference_system: Axis2Placement3D,
    #[holder(use_place_holder)]
    #[holder(supertype = "camera_model_d3")]
    pub perspective_of_volume: ViewVolume,
    #[holder(use_place_holder)]
    pub shape_clipping: Vec<CameraModelD3MultiClippingInterectionSelect>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = camera_model_d3_multi_clipping_intersection)]
#[holder(generate_deserialize)]
pub struct CameraModelD3MultiClippingIntersection {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub shape_clipping: Vec<CameraModelD3MultiClippingInterectionSelect>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = camera_model_d3_multi_clipping_union)]
#[holder(generate_deserialize)]
pub struct CameraModelD3MultiClippingUnion {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub shape_clipping: Vec<CameraModelD3MultiClippingUnionSelect>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = camera_model_d3_with_hlhsr)]
#[holder(generate_deserialize)]
pub struct CameraModelD3WithHlhsr {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "camera_model_d3")]
    pub view_reference_system: Axis2Placement3D,
    #[holder(use_place_holder)]
    #[holder(supertype = "camera_model_d3")]
    pub perspective_of_volume: ViewVolume,
    pub hidden_line_surface_removal: bool,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = camera_model_with_light_sources)]
#[holder(generate_deserialize)]
pub struct CameraModelWithLightSources {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "camera_model_d3")]
    pub view_reference_system: Axis2Placement3D,
    #[holder(use_place_holder)]
    #[holder(supertype = "camera_model_d3")]
    pub perspective_of_volume: ViewVolume,
    #[holder(use_place_holder)]
    pub sources: Vec<LightSourceAny>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = camera_usage)]
#[holder(generate_deserialize)]
pub struct CameraUsage {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_map")]
    pub mapping_origin: RepresentationItemAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_map")]
    pub mapped_representation: RepresentationAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = capacitance_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct CapacitanceMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = capacitance_unit)]
#[holder(generate_deserialize)]
pub struct CapacitanceUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CapacitanceUnitAny {
    #[holder(use_place_holder)]
    CapacitanceUnit(Box<CapacitanceUnit>),
    #[holder(use_place_holder)]
    SiCapacitanceUnit(Box<SiCapacitanceUnit>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = cartesian_point)]
#[holder(generate_deserialize)]
pub struct CartesianPoint {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub coordinates: Vec<LengthMeasure>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = cartesian_transformation_operator)]
#[holder(generate_deserialize)]
pub struct CartesianTransformationOperator {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "functionally_defined_transformation")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub axis1: Option<Direction>,
    #[holder(use_place_holder)]
    pub axis2: Option<Direction>,
    #[holder(use_place_holder)]
    pub local_origin: CartesianPoint,
    pub scale: Option<f64>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CartesianTransformationOperatorAny {
    #[holder(use_place_holder)]
    CartesianTransformationOperator(Box<CartesianTransformationOperator>),
    #[holder(use_place_holder)]
    CartesianTransformationOperator2D(Box<CartesianTransformationOperator2D>),
    #[holder(use_place_holder)]
    CartesianTransformationOperator3D(Box<CartesianTransformationOperator3D>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = cartesian_transformation_operator_2d)]
#[holder(generate_deserialize)]
pub struct CartesianTransformationOperator2D {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "functionally_defined_transformation")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "cartesian_transformation_operator")]
    pub axis1: Option<Direction>,
    #[holder(use_place_holder)]
    #[holder(supertype = "cartesian_transformation_operator")]
    pub axis2: Option<Direction>,
    #[holder(use_place_holder)]
    #[holder(supertype = "cartesian_transformation_operator")]
    pub local_origin: CartesianPoint,
    #[holder(supertype = "cartesian_transformation_operator")]
    pub scale: Option<f64>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = cartesian_transformation_operator_3d)]
#[holder(generate_deserialize)]
pub struct CartesianTransformationOperator3D {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "functionally_defined_transformation")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "cartesian_transformation_operator")]
    pub axis1: Option<Direction>,
    #[holder(use_place_holder)]
    #[holder(supertype = "cartesian_transformation_operator")]
    pub axis2: Option<Direction>,
    #[holder(use_place_holder)]
    #[holder(supertype = "cartesian_transformation_operator")]
    pub local_origin: CartesianPoint,
    #[holder(supertype = "cartesian_transformation_operator")]
    pub scale: Option<f64>,
    #[holder(use_place_holder)]
    pub axis3: Option<Direction>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = cc_design_approval)]
#[holder(generate_deserialize)]
pub struct CcDesignApproval {
    #[holder(use_place_holder)]
    #[holder(supertype = "approval_assignment")]
    pub assigned_approval: Approval,
    #[holder(use_place_holder)]
    pub items: Vec<ApprovedItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = cc_design_certification)]
#[holder(generate_deserialize)]
pub struct CcDesignCertification {
    #[holder(use_place_holder)]
    #[holder(supertype = "certification_assignment")]
    pub assigned_certification: Certification,
    #[holder(use_place_holder)]
    pub items: Vec<CertifiedItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = cc_design_contract)]
#[holder(generate_deserialize)]
pub struct CcDesignContract {
    #[holder(use_place_holder)]
    #[holder(supertype = "contract_assignment")]
    pub assigned_contract: Contract,
    #[holder(use_place_holder)]
    pub items: Vec<ContractedItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = cc_design_date_and_time_assignment)]
#[holder(generate_deserialize)]
pub struct CcDesignDateAndTimeAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "date_and_time_assignment")]
    pub assigned_date_and_time: DateAndTimeAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "date_and_time_assignment")]
    pub role: DateTimeRole,
    #[holder(use_place_holder)]
    pub items: Vec<DateTimeItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = cc_design_person_and_organization_assignment)]
#[holder(generate_deserialize)]
pub struct CcDesignPersonAndOrganizationAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "person_and_organization_assignment")]
    pub assigned_person_and_organization: PersonAndOrganization,
    #[holder(use_place_holder)]
    #[holder(supertype = "person_and_organization_assignment")]
    pub role: PersonAndOrganizationRole,
    #[holder(use_place_holder)]
    pub items: Vec<CcPersonOrganizationItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = cc_design_security_classification)]
#[holder(generate_deserialize)]
pub struct CcDesignSecurityClassification {
    #[holder(use_place_holder)]
    #[holder(supertype = "security_classification_assignment")]
    pub assigned_security_classification: SecurityClassification,
    #[holder(use_place_holder)]
    pub items: Vec<CcClassifiedItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = cc_design_specification_reference)]
#[holder(generate_deserialize)]
pub struct CcDesignSpecificationReference {
    #[holder(use_place_holder)]
    #[holder(supertype = "document_reference")]
    pub assigned_document: DocumentAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "document_reference")]
    pub source: Label,
    #[holder(use_place_holder)]
    pub items: Vec<CcSpecifiedItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = celsius_temperature_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct CelsiusTemperatureMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = centre_of_symmetry)]
#[holder(generate_deserialize)]
pub struct CentreOfSymmetry {
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub of_shape: ProductDefinitionShape,
    #[holder(supertype = "shape_aspect")]
    pub product_definitional: Logical,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = certification)]
#[holder(generate_deserialize)]
pub struct Certification {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub purpose: Text,
    #[holder(use_place_holder)]
    pub kind: CertificationType,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = certification_assignment)]
#[holder(generate_deserialize)]
pub struct CertificationAssignment {
    #[holder(use_place_holder)]
    pub assigned_certification: Certification,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CertificationAssignmentAny {
    #[holder(use_place_holder)]
    CertificationAssignment(Box<CertificationAssignment>),
    #[holder(use_place_holder)]
    AppliedCertificationAssignment(Box<AppliedCertificationAssignment>),
    #[holder(use_place_holder)]
    CcDesignCertification(Box<CcDesignCertification>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = certification_type)]
#[holder(generate_deserialize)]
pub struct CertificationType {
    #[holder(use_place_holder)]
    pub description: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = change)]
#[holder(generate_deserialize)]
pub struct Change {
    #[holder(use_place_holder)]
    #[holder(supertype = "action_assignment")]
    pub assigned_action: ActionAny,
    #[holder(use_place_holder)]
    pub items: Vec<WorkItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = change_request)]
#[holder(generate_deserialize)]
pub struct ChangeRequest {
    #[holder(use_place_holder)]
    #[holder(supertype = "action_request_assignment")]
    pub assigned_action_request: VersionedActionRequest,
    #[holder(use_place_holder)]
    pub items: Vec<ChangeRequestItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = character_glyph_font_usage)]
#[holder(generate_deserialize)]
pub struct CharacterGlyphFontUsage {
    #[holder(use_place_holder)]
    pub character: GenericCharacterGlyphSymbolAny,
    #[holder(use_place_holder)]
    pub font: TextFont,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = character_glyph_style_outline)]
#[holder(generate_deserialize)]
pub struct CharacterGlyphStyleOutline {
    #[holder(use_place_holder)]
    pub outline_style: CurveStyleAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = character_glyph_style_stroke)]
#[holder(generate_deserialize)]
pub struct CharacterGlyphStyleStroke {
    #[holder(use_place_holder)]
    pub stroke_style: CurveStyleAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = character_glyph_symbol)]
#[holder(generate_deserialize)]
pub struct CharacterGlyphSymbol {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
    #[holder(use_place_holder)]
    pub character_box: PlanarExtentAny,
    #[holder(use_place_holder)]
    pub baseline_ratio: RatioMeasure,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CharacterGlyphSymbolAny {
    #[holder(use_place_holder)]
    CharacterGlyphSymbol(Box<CharacterGlyphSymbol>),
    #[holder(use_place_holder)]
    CharacterGlyphSymbolOutline(Box<CharacterGlyphSymbolOutline>),
    #[holder(use_place_holder)]
    CharacterGlyphSymbolStroke(Box<CharacterGlyphSymbolStroke>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = character_glyph_symbol_outline)]
#[holder(generate_deserialize)]
pub struct CharacterGlyphSymbolOutline {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "character_glyph_symbol")]
    pub character_box: PlanarExtentAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "character_glyph_symbol")]
    pub baseline_ratio: RatioMeasure,
    #[holder(use_place_holder)]
    pub outlines: Vec<AnnotationFillArea>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = character_glyph_symbol_stroke)]
#[holder(generate_deserialize)]
pub struct CharacterGlyphSymbolStroke {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "character_glyph_symbol")]
    pub character_box: PlanarExtentAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "character_glyph_symbol")]
    pub baseline_ratio: RatioMeasure,
    #[holder(use_place_holder)]
    pub strokes: Vec<CurveAny>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = characteristic_data_column_header)]
#[holder(generate_deserialize)]
pub struct CharacteristicDataColumnHeader {
    #[holder(use_place_holder)]
    #[holder(supertype = "general_property")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "general_property")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "general_property")]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = characteristic_data_column_header_link)]
#[holder(generate_deserialize)]
pub struct CharacteristicDataColumnHeaderLink {
    #[holder(use_place_holder)]
    #[holder(supertype = "general_property_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "general_property_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "general_property_relationship")]
    pub relating_property: GeneralPropertyAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "general_property_relationship")]
    pub related_property: GeneralPropertyAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = characteristic_data_table_header)]
#[holder(generate_deserialize)]
pub struct CharacteristicDataTableHeader {
    #[holder(use_place_holder)]
    #[holder(supertype = "general_property")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "general_property")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "general_property")]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = characteristic_data_table_header_decomposition)]
#[holder(generate_deserialize)]
pub struct CharacteristicDataTableHeaderDecomposition {
    #[holder(use_place_holder)]
    #[holder(supertype = "general_property_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "general_property_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "general_property_relationship")]
    pub relating_property: GeneralPropertyAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "general_property_relationship")]
    pub related_property: GeneralPropertyAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = characteristic_type)]
#[holder(generate_deserialize)]
pub struct CharacteristicType {
    #[holder(use_place_holder)]
    #[holder(supertype = "group")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "group")]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = characterized_class)]
#[holder(generate_deserialize)]
pub struct CharacterizedClass {
    #[holder(use_place_holder)]
    #[holder(supertype = "characterized_object")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "characterized_object")]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = characterized_object)]
#[holder(generate_deserialize)]
pub struct CharacterizedObject {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CharacterizedObjectAny {
    #[holder(use_place_holder)]
    CharacterizedObject(Box<CharacterizedObject>),
    #[holder(use_place_holder)]
    BreakdownElementRealization(Box<BreakdownElementRealization>),
    #[holder(use_place_holder)]
    CharacterizedClass(Box<CharacterizedClass>),
    #[holder(use_place_holder)]
    DocumentFile(Box<DocumentFile>),
    #[holder(use_place_holder)]
    Extent(Box<Extent>),
    #[holder(use_place_holder)]
    PartialDocumentWithStructuredTextRepresentationAssignment(
        Box<PartialDocumentWithStructuredTextRepresentationAssignment>,
    ),
    #[holder(use_place_holder)]
    ProductClass(Box<ProductClass>),
    #[holder(use_place_holder)]
    ProductIdentification(Box<ProductIdentificationAny>),
    #[holder(use_place_holder)]
    RequirementAssignment(Box<RequirementAssignment>),
    #[holder(use_place_holder)]
    ShapeFeatureDefinition(Box<ShapeFeatureDefinitionAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = circle)]
#[holder(generate_deserialize)]
pub struct Circle {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "conic")]
    pub position: Axis2Placement,
    #[holder(use_place_holder)]
    pub radius: PositiveLengthMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = circular_runout_tolerance)]
#[holder(generate_deserialize)]
pub struct CircularRunoutTolerance {
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub description: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub magnitude: MeasureWithUnitAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub toleranced_shape_aspect: ShapeAspectAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance_with_datum_reference")]
    pub datum_system: Vec<DatumReferenceAny>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = class)]
#[holder(generate_deserialize)]
pub struct Class {
    #[holder(use_place_holder)]
    #[holder(supertype = "group")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "group")]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ClassAny {
    #[holder(use_place_holder)]
    Class(Box<Class>),
    #[holder(use_place_holder)]
    CharacterizedClass(Box<CharacterizedClass>),
    #[holder(use_place_holder)]
    ClassByExtension(Box<ClassByExtension>),
    #[holder(use_place_holder)]
    ClassByIntension(Box<ClassByIntension>),
    #[holder(use_place_holder)]
    ExternallyDefinedClass(Box<ExternallyDefinedClass>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = class_by_extension)]
#[holder(generate_deserialize)]
pub struct ClassByExtension {
    #[holder(use_place_holder)]
    #[holder(supertype = "group")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "group")]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = class_by_intension)]
#[holder(generate_deserialize)]
pub struct ClassByIntension {
    #[holder(use_place_holder)]
    #[holder(supertype = "group")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "group")]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = class_system)]
#[holder(generate_deserialize)]
pub struct ClassSystem {
    #[holder(use_place_holder)]
    #[holder(supertype = "group")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "group")]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = class_usage_effectivity_context_assignment)]
#[holder(generate_deserialize)]
pub struct ClassUsageEffectivityContextAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "effectivity_context_assignment")]
    pub assigned_effectivity_assignment: EffectivityAssignmentAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "effectivity_context_assignment")]
    pub role: EffectivityContextRole,
    #[holder(use_place_holder)]
    pub items: Vec<ClassUsageEffectivityContextItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = classification_assignment)]
#[holder(generate_deserialize)]
pub struct ClassificationAssignment {
    #[holder(use_place_holder)]
    pub assigned_class: GroupAny,
    #[holder(use_place_holder)]
    pub role: ClassificationRole,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ClassificationAssignmentAny {
    #[holder(use_place_holder)]
    ClassificationAssignment(Box<ClassificationAssignment>),
    #[holder(use_place_holder)]
    AppliedClassificationAssignment(Box<AppliedClassificationAssignment>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = classification_role)]
#[holder(generate_deserialize)]
pub struct ClassificationRole {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = closed_shell)]
#[holder(generate_deserialize)]
pub struct ClosedShell {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "connected_face_set")]
    pub cfs_faces: Vec<FaceAny>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ClosedShellAny {
    #[holder(use_place_holder)]
    ClosedShell(Box<ClosedShell>),
    #[holder(use_place_holder)]
    OrientedClosedShell(Box<OrientedClosedShell>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = coaxiality_tolerance)]
#[holder(generate_deserialize)]
pub struct CoaxialityTolerance {
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub description: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub magnitude: MeasureWithUnitAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub toleranced_shape_aspect: ShapeAspectAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance_with_datum_reference")]
    pub datum_system: Vec<DatumReferenceAny>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = colour)]
#[holder(generate_deserialize)]
pub struct Colour {}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ColourAny {
    #[holder(use_place_holder)]
    Colour(Box<Colour>),
    #[holder(use_place_holder)]
    BackgroundColour(Box<BackgroundColour>),
    #[holder(use_place_holder)]
    ColourSpecification(Box<ColourSpecificationAny>),
    #[holder(use_place_holder)]
    PreDefinedColour(Box<PreDefinedColourAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = colour_rgb)]
#[holder(generate_deserialize)]
pub struct ColourRgb {
    #[holder(use_place_holder)]
    #[holder(supertype = "colour_specification")]
    pub name: Label,
    pub red: f64,
    pub green: f64,
    pub blue: f64,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = colour_specification)]
#[holder(generate_deserialize)]
pub struct ColourSpecification {
    #[holder(use_place_holder)]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ColourSpecificationAny {
    #[holder(use_place_holder)]
    ColourSpecification(Box<ColourSpecification>),
    #[holder(use_place_holder)]
    ColourRgb(Box<ColourRgb>),
    #[holder(use_place_holder)]
    ExternallyDefinedColour(Box<ExternallyDefinedColour>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = common_datum)]
#[holder(generate_deserialize)]
pub struct CommonDatum {
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub of_shape: ProductDefinitionShape,
    #[holder(supertype = "shape_aspect")]
    pub product_definitional: Logical,
    #[holder(use_place_holder)]
    #[holder(supertype = "datum")]
    pub identification: Identifier,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = comparison_expression)]
#[holder(generate_deserialize)]
pub struct ComparisonExpression {
    #[holder(use_place_holder)]
    #[holder(supertype = "binary_generic_expression")]
    pub operands: Vec<GenericExpressionAny>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = complex_clause)]
#[holder(generate_deserialize)]
pub struct ComplexClause {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "compound_representation_item")]
    pub item_element: CompoundItemDefinition,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ComplexClauseAny {
    #[holder(use_place_holder)]
    ComplexClause(Box<ComplexClause>),
    #[holder(use_place_holder)]
    ComplexConjunctiveClause(Box<ComplexConjunctiveClause>),
    #[holder(use_place_holder)]
    ComplexDisjunctiveClause(Box<ComplexDisjunctiveClause>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = complex_conjunctive_clause)]
#[holder(generate_deserialize)]
pub struct ComplexConjunctiveClause {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "compound_representation_item")]
    pub item_element: CompoundItemDefinition,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = complex_disjunctive_clause)]
#[holder(generate_deserialize)]
pub struct ComplexDisjunctiveClause {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "compound_representation_item")]
    pub item_element: CompoundItemDefinition,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = complex_shelled_solid)]
#[holder(generate_deserialize)]
pub struct ComplexShelledSolid {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "shelled_solid")]
    pub deleted_face_set: Vec<FaceSurfaceAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "shelled_solid")]
    pub thickness: LengthMeasure,
    #[holder(use_place_holder)]
    pub thickened_face_list: Vec<Vec<FaceSurfaceAny>>,
    #[holder(use_place_holder)]
    pub thickness_list: Vec<LengthMeasure>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = composite_assembly_definition)]
#[holder(generate_deserialize)]
pub struct CompositeAssemblyDefinition {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub formation: ProductDefinitionFormationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub frame_of_reference: ProductDefinitionContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = composite_assembly_sequence_definition)]
#[holder(generate_deserialize)]
pub struct CompositeAssemblySequenceDefinition {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub formation: ProductDefinitionFormationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub frame_of_reference: ProductDefinitionContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = composite_assembly_table)]
#[holder(generate_deserialize)]
pub struct CompositeAssemblyTable {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub formation: ProductDefinitionFormationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub frame_of_reference: ProductDefinitionContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = composite_curve)]
#[holder(generate_deserialize)]
pub struct CompositeCurve {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub segments: Vec<CompositeCurveSegmentAny>,
    pub self_intersect: Logical,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CompositeCurveAny {
    #[holder(use_place_holder)]
    CompositeCurve(Box<CompositeCurve>),
    #[holder(use_place_holder)]
    CompositeCurveOnSurface(Box<CompositeCurveOnSurfaceAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = composite_curve_on_surface)]
#[holder(generate_deserialize)]
pub struct CompositeCurveOnSurface {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "composite_curve")]
    pub segments: Vec<CompositeCurveSegmentAny>,
    #[holder(supertype = "composite_curve")]
    pub self_intersect: Logical,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CompositeCurveOnSurfaceAny {
    #[holder(use_place_holder)]
    CompositeCurveOnSurface(Box<CompositeCurveOnSurface>),
    #[holder(use_place_holder)]
    BoundaryCurve(Box<BoundaryCurveAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = composite_curve_segment)]
#[holder(generate_deserialize)]
pub struct CompositeCurveSegment {
    pub transition: TransitionCode,
    pub same_sense: bool,
    #[holder(use_place_holder)]
    pub parent_curve: CurveAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CompositeCurveSegmentAny {
    #[holder(use_place_holder)]
    CompositeCurveSegment(Box<CompositeCurveSegment>),
    #[holder(use_place_holder)]
    ReparametrisedCompositeCurveSegment(Box<ReparametrisedCompositeCurveSegment>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = composite_material_designation)]
#[holder(generate_deserialize)]
pub struct CompositeMaterialDesignation {
    #[holder(use_place_holder)]
    #[holder(supertype = "material_designation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "material_designation")]
    pub definitions: Vec<CharacterizedDefinition>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = composite_shape_aspect)]
#[holder(generate_deserialize)]
pub struct CompositeShapeAspect {
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub of_shape: ProductDefinitionShape,
    #[holder(supertype = "shape_aspect")]
    pub product_definitional: Logical,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CompositeShapeAspectAny {
    #[holder(use_place_holder)]
    CompositeShapeAspect(Box<CompositeShapeAspect>),
    #[holder(use_place_holder)]
    CommonDatum(Box<CommonDatum>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = composite_sheet_representation)]
#[holder(generate_deserialize)]
pub struct CompositeSheetRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = composite_text)]
#[holder(generate_deserialize)]
pub struct CompositeText {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub collected_text: Vec<TextOrCharacter>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CompositeTextAny {
    #[holder(use_place_holder)]
    CompositeText(Box<CompositeText>),
    #[holder(use_place_holder)]
    CompositeTextWithAssociatedCurves(Box<CompositeTextWithAssociatedCurves>),
    #[holder(use_place_holder)]
    CompositeTextWithBlankingBox(Box<CompositeTextWithBlankingBox>),
    #[holder(use_place_holder)]
    CompositeTextWithDelineation(Box<CompositeTextWithDelineation>),
    #[holder(use_place_holder)]
    CompositeTextWithExtent(Box<CompositeTextWithExtent>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = composite_text_with_associated_curves)]
#[holder(generate_deserialize)]
pub struct CompositeTextWithAssociatedCurves {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "composite_text")]
    pub collected_text: Vec<TextOrCharacter>,
    #[holder(use_place_holder)]
    pub associated_curves: Vec<CurveAny>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = composite_text_with_blanking_box)]
#[holder(generate_deserialize)]
pub struct CompositeTextWithBlankingBox {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "composite_text")]
    pub collected_text: Vec<TextOrCharacter>,
    #[holder(use_place_holder)]
    pub blanking: PlanarBox,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = composite_text_with_delineation)]
#[holder(generate_deserialize)]
pub struct CompositeTextWithDelineation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "composite_text")]
    pub collected_text: Vec<TextOrCharacter>,
    #[holder(use_place_holder)]
    pub delineation: TextDelineation,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = composite_text_with_extent)]
#[holder(generate_deserialize)]
pub struct CompositeTextWithExtent {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "composite_text")]
    pub collected_text: Vec<TextOrCharacter>,
    #[holder(use_place_holder)]
    pub extent: PlanarExtentAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = compound_representation_item)]
#[holder(generate_deserialize)]
pub struct CompoundRepresentationItem {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub item_element: CompoundItemDefinition,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CompoundRepresentationItemAny {
    #[holder(use_place_holder)]
    CompoundRepresentationItem(Box<CompoundRepresentationItem>),
    #[holder(use_place_holder)]
    AtomicFormula(Box<AtomicFormulaAny>),
    #[holder(use_place_holder)]
    ComplexClause(Box<ComplexClauseAny>),
    #[holder(use_place_holder)]
    DefaultToleranceTableCell(Box<DefaultToleranceTableCell>),
    #[holder(use_place_holder)]
    Func(Box<Func>),
    #[holder(use_place_holder)]
    PointAndVector(Box<PointAndVector>),
    #[holder(use_place_holder)]
    PointPath(Box<PointPath>),
    #[holder(use_place_holder)]
    RowRepresentationItem(Box<RowRepresentationItem>),
    #[holder(use_place_holder)]
    RowValue(Box<RowValue>),
    #[holder(use_place_holder)]
    SimpleClause(Box<SimpleClauseAny>),
    #[holder(use_place_holder)]
    StructuredTextComposition(Box<StructuredTextComposition>),
    #[holder(use_place_holder)]
    TableRepresentationItem(Box<TableRepresentationItem>),
    #[holder(use_place_holder)]
    ValueRange(Box<ValueRange>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = compound_shape_representation)]
#[holder(generate_deserialize)]
pub struct CompoundShapeRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = concentricity_tolerance)]
#[holder(generate_deserialize)]
pub struct ConcentricityTolerance {
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub description: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub magnitude: MeasureWithUnitAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub toleranced_shape_aspect: ShapeAspectAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance_with_datum_reference")]
    pub datum_system: Vec<DatumReferenceAny>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = concept_feature_operator)]
#[holder(generate_deserialize)]
pub struct ConceptFeatureOperator {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = concept_feature_relationship)]
#[holder(generate_deserialize)]
pub struct ConceptFeatureRelationship {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub relating_product_concept_feature: ProductConceptFeatureAny,
    #[holder(use_place_holder)]
    pub related_product_concept_feature: ProductConceptFeatureAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ConceptFeatureRelationshipAny {
    #[holder(use_place_holder)]
    ConceptFeatureRelationship(Box<ConceptFeatureRelationship>),
    #[holder(use_place_holder)]
    ConceptFeatureRelationshipWithCondition(Box<ConceptFeatureRelationshipWithCondition>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = concept_feature_relationship_with_condition)]
#[holder(generate_deserialize)]
pub struct ConceptFeatureRelationshipWithCondition {
    #[holder(use_place_holder)]
    #[holder(supertype = "concept_feature_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "concept_feature_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "concept_feature_relationship")]
    pub relating_product_concept_feature: ProductConceptFeatureAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "concept_feature_relationship")]
    pub related_product_concept_feature: ProductConceptFeatureAny,
    #[holder(use_place_holder)]
    pub conditional_operator: ConceptFeatureOperator,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = conditional_concept_feature)]
#[holder(generate_deserialize)]
pub struct ConditionalConceptFeature {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_concept_feature")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_concept_feature")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_concept_feature")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub condition: ConceptFeatureRelationshipWithCondition,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ConditionalConceptFeatureAny {
    #[holder(use_place_holder)]
    ConditionalConceptFeature(Box<ConditionalConceptFeature>),
    #[holder(use_place_holder)]
    InclusionProductConceptFeature(Box<InclusionProductConceptFeature>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = conductance_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct ConductanceMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = conductance_unit)]
#[holder(generate_deserialize)]
pub struct ConductanceUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ConductanceUnitAny {
    #[holder(use_place_holder)]
    ConductanceUnit(Box<ConductanceUnit>),
    #[holder(use_place_holder)]
    SiConductanceUnit(Box<SiConductanceUnit>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = configurable_item)]
#[holder(generate_deserialize)]
pub struct ConfigurableItem {
    #[holder(use_place_holder)]
    #[holder(supertype = "configuration_item")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "configuration_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "configuration_item")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "configuration_item")]
    pub item_concept: ProductConceptAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "configuration_item")]
    pub purpose: Option<Label>,
    #[holder(use_place_holder)]
    pub item_concept_feature: Vec<ProductConceptFeatureAssociation>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ConfigurableItemAny {
    #[holder(use_place_holder)]
    ConfigurableItem(Box<ConfigurableItem>),
    #[holder(use_place_holder)]
    ProductSpecification(Box<ProductSpecification>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = configuration_design)]
#[holder(generate_deserialize)]
pub struct ConfigurationDesign {
    #[holder(use_place_holder)]
    pub configuration: ConfigurationItemAny,
    #[holder(use_place_holder)]
    pub design: ConfigurationDesignItem,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = configuration_effectivity)]
#[holder(generate_deserialize)]
pub struct ConfigurationEffectivity {
    #[holder(use_place_holder)]
    #[holder(supertype = "effectivity")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_effectivity")]
    pub usage: ProductDefinitionRelationshipAny,
    #[holder(use_place_holder)]
    pub configuration: ConfigurationDesign,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = configuration_item)]
#[holder(generate_deserialize)]
pub struct ConfigurationItem {
    #[holder(use_place_holder)]
    pub id: Identifier,
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub item_concept: ProductConceptAny,
    #[holder(use_place_holder)]
    pub purpose: Option<Label>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ConfigurationItemAny {
    #[holder(use_place_holder)]
    ConfigurationItem(Box<ConfigurationItem>),
    #[holder(use_place_holder)]
    ConfigurableItem(Box<ConfigurableItemAny>),
    #[holder(use_place_holder)]
    ProductIdentification(Box<ProductIdentificationAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = configuration_item_hierarchical_relationship)]
#[holder(generate_deserialize)]
pub struct ConfigurationItemHierarchicalRelationship {
    #[holder(use_place_holder)]
    #[holder(supertype = "configuration_item_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "configuration_item_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "configuration_item_relationship")]
    pub relating_configuration_item: ConfigurationItemAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "configuration_item_relationship")]
    pub related_configuration_item: ConfigurationItemAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = configuration_item_relationship)]
#[holder(generate_deserialize)]
pub struct ConfigurationItemRelationship {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub relating_configuration_item: ConfigurationItemAny,
    #[holder(use_place_holder)]
    pub related_configuration_item: ConfigurationItemAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ConfigurationItemRelationshipAny {
    #[holder(use_place_holder)]
    ConfigurationItemRelationship(Box<ConfigurationItemRelationship>),
    #[holder(use_place_holder)]
    ConfigurationItemHierarchicalRelationship(Box<ConfigurationItemHierarchicalRelationship>),
    #[holder(use_place_holder)]
    ConfigurationItemRevisionSequence(Box<ConfigurationItemRevisionSequence>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = configuration_item_revision_sequence)]
#[holder(generate_deserialize)]
pub struct ConfigurationItemRevisionSequence {
    #[holder(use_place_holder)]
    #[holder(supertype = "configuration_item_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "configuration_item_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "configuration_item_relationship")]
    pub relating_configuration_item: ConfigurationItemAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "configuration_item_relationship")]
    pub related_configuration_item: ConfigurationItemAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = configured_effectivity_assignment)]
#[holder(generate_deserialize)]
pub struct ConfiguredEffectivityAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "effectivity_assignment")]
    pub assigned_effectivity: EffectivityAny,
    #[holder(use_place_holder)]
    pub items: Vec<ConfiguredEffectivityItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = configured_effectivity_context_assignment)]
#[holder(generate_deserialize)]
pub struct ConfiguredEffectivityContextAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "effectivity_context_assignment")]
    pub assigned_effectivity_assignment: EffectivityAssignmentAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "effectivity_context_assignment")]
    pub role: EffectivityContextRole,
    #[holder(use_place_holder)]
    pub items: Vec<ConfiguredEffectivityContextItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = conic)]
#[holder(generate_deserialize)]
pub struct Conic {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub position: Axis2Placement,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ConicAny {
    #[holder(use_place_holder)]
    Conic(Box<Conic>),
    #[holder(use_place_holder)]
    Circle(Box<Circle>),
    #[holder(use_place_holder)]
    Ellipse(Box<Ellipse>),
    #[holder(use_place_holder)]
    Hyperbola(Box<Hyperbola>),
    #[holder(use_place_holder)]
    Parabola(Box<Parabola>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = conical_stepped_hole_transition)]
#[holder(generate_deserialize)]
pub struct ConicalSteppedHoleTransition {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub transition_number: PositiveInteger,
    #[holder(use_place_holder)]
    pub cone_apex_angle: PlaneAngleMeasure,
    #[holder(use_place_holder)]
    pub cone_base_radius: PositiveLengthMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = conical_surface)]
#[holder(generate_deserialize)]
pub struct ConicalSurface {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "elementary_surface")]
    pub position: Axis2Placement3D,
    #[holder(use_place_holder)]
    pub radius: LengthMeasure,
    #[holder(use_place_holder)]
    pub semi_angle: PlaneAngleMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = connected_edge_set)]
#[holder(generate_deserialize)]
pub struct ConnectedEdgeSet {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub ces_edges: Vec<EdgeAny>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = connected_face_set)]
#[holder(generate_deserialize)]
pub struct ConnectedFaceSet {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub cfs_faces: Vec<FaceAny>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ConnectedFaceSetAny {
    #[holder(use_place_holder)]
    ConnectedFaceSet(Box<ConnectedFaceSet>),
    #[holder(use_place_holder)]
    ClosedShell(Box<ClosedShellAny>),
    #[holder(use_place_holder)]
    ConnectedFaceSubSet(Box<ConnectedFaceSubSet>),
    #[holder(use_place_holder)]
    OpenShell(Box<OpenShellAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = connected_face_sub_set)]
#[holder(generate_deserialize)]
pub struct ConnectedFaceSubSet {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "connected_face_set")]
    pub cfs_faces: Vec<FaceAny>,
    #[holder(use_place_holder)]
    pub parent_face_set: ConnectedFaceSetAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = constructive_geometry_representation)]
#[holder(generate_deserialize)]
pub struct ConstructiveGeometryRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = constructive_geometry_representation_relationship)]
#[holder(generate_deserialize)]
pub struct ConstructiveGeometryRepresentationRelationship {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub rep_1: RepresentationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub rep_2: RepresentationAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = contact_ratio_representation)]
#[holder(generate_deserialize)]
pub struct ContactRatioRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = context_dependent_invisibility)]
#[holder(generate_deserialize)]
pub struct ContextDependentInvisibility {
    #[holder(use_place_holder)]
    #[holder(supertype = "invisibility")]
    pub invisible_items: Vec<InvisibleItem>,
    #[holder(use_place_holder)]
    pub presentation_context: InvisibilityContext,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = context_dependent_over_riding_styled_item)]
#[holder(generate_deserialize)]
pub struct ContextDependentOverRidingStyledItem {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "styled_item")]
    pub styles: Vec<PresentationStyleAssignmentAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "styled_item")]
    pub item: RepresentationItemAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "over_riding_styled_item")]
    pub over_ridden_style: StyledItemAny,
    #[holder(use_place_holder)]
    pub style_context: Vec<StyleContextSelect>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ContextDependentOverRidingStyledItemAny {
    #[holder(use_place_holder)]
    ContextDependentOverRidingStyledItem(Box<ContextDependentOverRidingStyledItem>),
    #[holder(use_place_holder)]
    HiddenElementOverRidingStyledItem(Box<HiddenElementOverRidingStyledItem>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = context_dependent_shape_representation)]
#[holder(generate_deserialize)]
pub struct ContextDependentShapeRepresentation {
    #[holder(use_place_holder)]
    pub representation_relation: ShapeRepresentationRelationshipAny,
    #[holder(use_place_holder)]
    pub represented_product_relation: ProductDefinitionShape,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = context_dependent_unit)]
#[holder(generate_deserialize)]
pub struct ContextDependentUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "named_unit")]
    pub dimensions: DimensionalExponents,
    #[holder(use_place_holder)]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ContextDependentUnitAny {
    #[holder(use_place_holder)]
    ContextDependentUnit(Box<ContextDependentUnit>),
    #[holder(use_place_holder)]
    Currency(Box<CurrencyAny>),
    #[holder(use_place_holder)]
    ExpressionConversionBasedUnit(Box<ExpressionConversionBasedUnit>),
    #[holder(use_place_holder)]
    ExternallyDefinedContextDependentUnit(Box<ExternallyDefinedContextDependentUnitAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = contract)]
#[holder(generate_deserialize)]
pub struct Contract {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub purpose: Text,
    #[holder(use_place_holder)]
    pub kind: ContractType,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = contract_assignment)]
#[holder(generate_deserialize)]
pub struct ContractAssignment {
    #[holder(use_place_holder)]
    pub assigned_contract: Contract,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ContractAssignmentAny {
    #[holder(use_place_holder)]
    ContractAssignment(Box<ContractAssignment>),
    #[holder(use_place_holder)]
    AppliedContractAssignment(Box<AppliedContractAssignment>),
    #[holder(use_place_holder)]
    CcDesignContract(Box<CcDesignContract>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = contract_relationship)]
#[holder(generate_deserialize)]
pub struct ContractRelationship {
    #[holder(use_place_holder)]
    pub id: Identifier,
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub relating_contract: Contract,
    #[holder(use_place_holder)]
    pub related_contract: Contract,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = contract_type)]
#[holder(generate_deserialize)]
pub struct ContractType {
    #[holder(use_place_holder)]
    pub description: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = conversion_based_unit)]
#[holder(generate_deserialize)]
pub struct ConversionBasedUnit {
    #[holder(derived)]
    #[holder(supertype = "named_unit")]
    pub dimensions: Derived<DimensionalExponents>,
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub conversion_factor: MeasureWithUnitAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ConversionBasedUnitAny {
    #[holder(use_place_holder)]
    ConversionBasedUnit(Box<ConversionBasedUnit>),
    #[holder(use_place_holder)]
    ExternallyDefinedConversionBasedUnit(Box<ExternallyDefinedConversionBasedUnit>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = coordinated_universal_time_offset)]
#[holder(generate_deserialize)]
pub struct CoordinatedUniversalTimeOffset {
    pub hour_offset: i64,
    pub minute_offset: Option<i64>,
    pub sense: AheadOrBehind,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = csg_shape_representation)]
#[holder(generate_deserialize)]
pub struct CsgShapeRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = csg_solid)]
#[holder(generate_deserialize)]
pub struct CsgSolid {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub tree_root_expression: CsgSelect,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = currency)]
#[holder(generate_deserialize)]
pub struct Currency {
    #[holder(use_place_holder)]
    #[holder(supertype = "named_unit")]
    pub dimensions: DimensionalExponents,
    #[holder(use_place_holder)]
    #[holder(supertype = "context_dependent_unit")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CurrencyAny {
    #[holder(use_place_holder)]
    Currency(Box<Currency>),
    #[holder(use_place_holder)]
    ExternallyDefinedCurrency(Box<ExternallyDefinedCurrency>),
    #[holder(use_place_holder)]
    Iso4217Currency(Box<Iso4217Currency>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = currency_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct CurrencyMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = curve)]
#[holder(generate_deserialize)]
pub struct Curve {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CurveAny {
    #[holder(use_place_holder)]
    Curve(Box<Curve>),
    #[holder(use_place_holder)]
    BoundedCurve(Box<BoundedCurveAny>),
    #[holder(use_place_holder)]
    Conic(Box<ConicAny>),
    #[holder(use_place_holder)]
    CurveReplica(Box<CurveReplica>),
    #[holder(use_place_holder)]
    Line(Box<Line>),
    #[holder(use_place_holder)]
    OffsetCurve2D(Box<OffsetCurve2D>),
    #[holder(use_place_holder)]
    OffsetCurve3D(Box<OffsetCurve3D>),
    #[holder(use_place_holder)]
    Pcurve(Box<PcurveAny>),
    #[holder(use_place_holder)]
    SurfaceCurve(Box<SurfaceCurveAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = curve_bounded_surface)]
#[holder(generate_deserialize)]
pub struct CurveBoundedSurface {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub basis_surface: SurfaceAny,
    #[holder(use_place_holder)]
    pub boundaries: Vec<BoundaryCurveAny>,
    pub implicit_outer: bool,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = curve_dimension)]
#[holder(generate_deserialize)]
pub struct CurveDimension {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "draughting_callout")]
    pub contents: Vec<DraughtingCalloutElement>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = curve_replica)]
#[holder(generate_deserialize)]
pub struct CurveReplica {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub parent_curve: CurveAny,
    #[holder(use_place_holder)]
    pub transformation: CartesianTransformationOperatorAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = curve_style)]
#[holder(generate_deserialize)]
pub struct CurveStyle {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub curve_font: CurveFontOrScaledCurveFontSelect,
    #[holder(use_place_holder)]
    pub curve_width: SizeSelect,
    #[holder(use_place_holder)]
    pub curve_colour: ColourAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CurveStyleAny {
    #[holder(use_place_holder)]
    CurveStyle(Box<CurveStyle>),
    #[holder(use_place_holder)]
    VectorStyle(Box<VectorStyle>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = curve_style_font)]
#[holder(generate_deserialize)]
pub struct CurveStyleFont {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub pattern_list: Vec<CurveStyleFontPattern>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum CurveStyleFontAny {
    #[holder(use_place_holder)]
    CurveStyleFont(Box<CurveStyleFont>),
    #[holder(use_place_holder)]
    UserDefinedCurveFont(Box<UserDefinedCurveFont>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = curve_style_font_and_scaling)]
#[holder(generate_deserialize)]
pub struct CurveStyleFontAndScaling {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub curve_font: CurveStyleFontSelect,
    pub curve_font_scaling: f64,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = curve_style_font_pattern)]
#[holder(generate_deserialize)]
pub struct CurveStyleFontPattern {
    #[holder(use_place_holder)]
    pub visible_segment_length: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    pub invisible_segment_length: PositiveLengthMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = curve_style_rendering)]
#[holder(generate_deserialize)]
pub struct CurveStyleRendering {
    pub rendering_method: ShadingCurveMethod,
    #[holder(use_place_holder)]
    pub rendering_properties: SurfaceRenderingProperties,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = curve_swept_solid_shape_representation)]
#[holder(generate_deserialize)]
pub struct CurveSweptSolidShapeRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = cylindrical_surface)]
#[holder(generate_deserialize)]
pub struct CylindricalSurface {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "elementary_surface")]
    pub position: Axis2Placement3D,
    #[holder(use_place_holder)]
    pub radius: PositiveLengthMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = cylindricity_tolerance)]
#[holder(generate_deserialize)]
pub struct CylindricityTolerance {
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub description: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub magnitude: MeasureWithUnitAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub toleranced_shape_aspect: ShapeAspectAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = data_environment)]
#[holder(generate_deserialize)]
pub struct DataEnvironment {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Text,
    #[holder(use_place_holder)]
    pub elements: Vec<PropertyDefinitionRepresentationAny>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = date)]
#[holder(generate_deserialize)]
pub struct Date {
    #[holder(use_place_holder)]
    pub year_component: YearNumber,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DateAny {
    #[holder(use_place_holder)]
    Date(Box<Date>),
    #[holder(use_place_holder)]
    CalendarDate(Box<CalendarDate>),
    #[holder(use_place_holder)]
    DateRepresentationItem(Box<DateRepresentationItem>),
    #[holder(use_place_holder)]
    OrdinalDate(Box<OrdinalDate>),
    #[holder(use_place_holder)]
    WeekOfYearAndDayDate(Box<WeekOfYearAndDayDate>),
    #[holder(use_place_holder)]
    YearMonth(Box<YearMonth>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = date_and_time)]
#[holder(generate_deserialize)]
pub struct DateAndTime {
    #[holder(use_place_holder)]
    pub date_component: DateAny,
    #[holder(use_place_holder)]
    pub time_component: LocalTime,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DateAndTimeAny {
    #[holder(use_place_holder)]
    DateAndTime(Box<DateAndTime>),
    #[holder(use_place_holder)]
    DateTimeRepresentationItem(Box<DateTimeRepresentationItem>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = date_and_time_assignment)]
#[holder(generate_deserialize)]
pub struct DateAndTimeAssignment {
    #[holder(use_place_holder)]
    pub assigned_date_and_time: DateAndTimeAny,
    #[holder(use_place_holder)]
    pub role: DateTimeRole,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DateAndTimeAssignmentAny {
    #[holder(use_place_holder)]
    DateAndTimeAssignment(Box<DateAndTimeAssignment>),
    #[holder(use_place_holder)]
    AppliedDateAndTimeAssignment(Box<AppliedDateAndTimeAssignment>),
    #[holder(use_place_holder)]
    CcDesignDateAndTimeAssignment(Box<CcDesignDateAndTimeAssignment>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = date_assignment)]
#[holder(generate_deserialize)]
pub struct DateAssignment {
    #[holder(use_place_holder)]
    pub assigned_date: DateAny,
    #[holder(use_place_holder)]
    pub role: DateRole,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DateAssignmentAny {
    #[holder(use_place_holder)]
    DateAssignment(Box<DateAssignment>),
    #[holder(use_place_holder)]
    AppliedDateAssignment(Box<AppliedDateAssignment>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = date_representation_item)]
#[holder(generate_deserialize)]
pub struct DateRepresentationItem {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "date")]
    pub year_component: YearNumber,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = date_role)]
#[holder(generate_deserialize)]
pub struct DateRole {
    #[holder(use_place_holder)]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = date_time_representation_item)]
#[holder(generate_deserialize)]
pub struct DateTimeRepresentationItem {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "date_and_time")]
    pub date_component: DateAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "date_and_time")]
    pub time_component: LocalTime,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = date_time_role)]
#[holder(generate_deserialize)]
pub struct DateTimeRole {
    #[holder(use_place_holder)]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = dated_effectivity)]
#[holder(generate_deserialize)]
pub struct DatedEffectivity {
    #[holder(use_place_holder)]
    #[holder(supertype = "effectivity")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    pub effectivity_end_date: Option<DateTimeOrEventOccurrence>,
    #[holder(use_place_holder)]
    pub effectivity_start_date: DateTimeOrEventOccurrence,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = datum)]
#[holder(generate_deserialize)]
pub struct Datum {
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub of_shape: ProductDefinitionShape,
    #[holder(supertype = "shape_aspect")]
    pub product_definitional: Logical,
    #[holder(use_place_holder)]
    pub identification: Identifier,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DatumAny {
    #[holder(use_place_holder)]
    Datum(Box<Datum>),
    #[holder(use_place_holder)]
    CommonDatum(Box<CommonDatum>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = datum_feature)]
#[holder(generate_deserialize)]
pub struct DatumFeature {
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub of_shape: ProductDefinitionShape,
    #[holder(supertype = "shape_aspect")]
    pub product_definitional: Logical,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = datum_feature_callout)]
#[holder(generate_deserialize)]
pub struct DatumFeatureCallout {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "draughting_callout")]
    pub contents: Vec<DraughtingCalloutElement>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = datum_reference)]
#[holder(generate_deserialize)]
pub struct DatumReference {
    pub precedence: i64,
    #[holder(use_place_holder)]
    pub referenced_datum: DatumAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DatumReferenceAny {
    #[holder(use_place_holder)]
    DatumReference(Box<DatumReference>),
    #[holder(use_place_holder)]
    ReferencedModifiedDatum(Box<ReferencedModifiedDatum>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = datum_target)]
#[holder(generate_deserialize)]
pub struct DatumTarget {
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub of_shape: ProductDefinitionShape,
    #[holder(supertype = "shape_aspect")]
    pub product_definitional: Logical,
    #[holder(use_place_holder)]
    pub target_id: Identifier,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DatumTargetAny {
    #[holder(use_place_holder)]
    DatumTarget(Box<DatumTarget>),
    #[holder(use_place_holder)]
    PlacedDatumTargetFeature(Box<PlacedDatumTargetFeature>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = datum_target_callout)]
#[holder(generate_deserialize)]
pub struct DatumTargetCallout {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "draughting_callout")]
    pub contents: Vec<DraughtingCalloutElement>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = default_tolerance_table)]
#[holder(generate_deserialize)]
pub struct DefaultToleranceTable {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = default_tolerance_table_cell)]
#[holder(generate_deserialize)]
pub struct DefaultToleranceTableCell {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "compound_representation_item")]
    pub item_element: CompoundItemDefinition,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = defined_symbol)]
#[holder(generate_deserialize)]
pub struct DefinedSymbol {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub definition: DefinedSymbolSelect,
    #[holder(use_place_holder)]
    pub target: SymbolTarget,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = definitional_representation)]
#[holder(generate_deserialize)]
pub struct DefinitionalRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = definitional_representation_relationship)]
#[holder(generate_deserialize)]
pub struct DefinitionalRepresentationRelationship {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub rep_1: RepresentationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub rep_2: RepresentationAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DefinitionalRepresentationRelationshipAny {
    #[holder(use_place_holder)]
    DefinitionalRepresentationRelationship(Box<DefinitionalRepresentationRelationship>),
    #[holder(use_place_holder)]
    DefinitionalRepresentationRelationshipWithSameContext(
        Box<DefinitionalRepresentationRelationshipWithSameContextAny>,
    ),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = definitional_representation_relationship_with_same_context)]
#[holder(generate_deserialize)]
pub struct DefinitionalRepresentationRelationshipWithSameContext {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub rep_1: RepresentationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub rep_2: RepresentationAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DefinitionalRepresentationRelationshipWithSameContextAny {
    #[holder(use_place_holder)]
    DefinitionalRepresentationRelationshipWithSameContext(
        Box<DefinitionalRepresentationRelationshipWithSameContext>,
    ),
    #[holder(use_place_holder)]
    MechanicalDesignAndDraughtingRelationship(Box<MechanicalDesignAndDraughtingRelationship>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = degenerate_pcurve)]
#[holder(generate_deserialize)]
pub struct DegeneratePcurve {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub basis_surface: SurfaceAny,
    #[holder(use_place_holder)]
    pub reference_to_curve: DefinitionalRepresentation,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DegeneratePcurveAny {
    #[holder(use_place_holder)]
    DegeneratePcurve(Box<DegeneratePcurve>),
    #[holder(use_place_holder)]
    EvaluatedDegeneratePcurve(Box<EvaluatedDegeneratePcurve>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = degenerate_toroidal_surface)]
#[holder(generate_deserialize)]
pub struct DegenerateToroidalSurface {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "elementary_surface")]
    pub position: Axis2Placement3D,
    #[holder(use_place_holder)]
    #[holder(supertype = "toroidal_surface")]
    pub major_radius: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    #[holder(supertype = "toroidal_surface")]
    pub minor_radius: PositiveLengthMeasure,
    pub select_outer: bool,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = derived_shape_aspect)]
#[holder(generate_deserialize)]
pub struct DerivedShapeAspect {
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub of_shape: ProductDefinitionShape,
    #[holder(supertype = "shape_aspect")]
    pub product_definitional: Logical,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DerivedShapeAspectAny {
    #[holder(use_place_holder)]
    DerivedShapeAspect(Box<DerivedShapeAspect>),
    #[holder(use_place_holder)]
    Apex(Box<Apex>),
    #[holder(use_place_holder)]
    CentreOfSymmetry(Box<CentreOfSymmetry>),
    #[holder(use_place_holder)]
    Extension(Box<Extension>),
    #[holder(use_place_holder)]
    GeometricAlignment(Box<GeometricAlignment>),
    #[holder(use_place_holder)]
    GeometricIntersection(Box<GeometricIntersection>),
    #[holder(use_place_holder)]
    ParallelOffset(Box<ParallelOffset>),
    #[holder(use_place_holder)]
    PerpendicularTo(Box<PerpendicularTo>),
    #[holder(use_place_holder)]
    Tangent(Box<Tangent>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = derived_unit)]
#[holder(generate_deserialize)]
pub struct DerivedUnit {
    #[holder(use_place_holder)]
    pub elements: Vec<DerivedUnitElement>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DerivedUnitAny {
    #[holder(use_place_holder)]
    DerivedUnit(Box<DerivedUnit>),
    #[holder(use_place_holder)]
    AbsorbedDoseUnit(Box<AbsorbedDoseUnitAny>),
    #[holder(use_place_holder)]
    AccelerationUnit(Box<AccelerationUnit>),
    #[holder(use_place_holder)]
    AreaUnit(Box<AreaUnit>),
    #[holder(use_place_holder)]
    CapacitanceUnit(Box<CapacitanceUnitAny>),
    #[holder(use_place_holder)]
    ConductanceUnit(Box<ConductanceUnitAny>),
    #[holder(use_place_holder)]
    DoseEquivalentUnit(Box<DoseEquivalentUnitAny>),
    #[holder(use_place_holder)]
    ElectricChargeUnit(Box<ElectricChargeUnitAny>),
    #[holder(use_place_holder)]
    ElectricPotentialUnit(Box<ElectricPotentialUnitAny>),
    #[holder(use_place_holder)]
    EnergyUnit(Box<EnergyUnitAny>),
    #[holder(use_place_holder)]
    ForceUnit(Box<ForceUnitAny>),
    #[holder(use_place_holder)]
    FrequencyUnit(Box<FrequencyUnitAny>),
    #[holder(use_place_holder)]
    IlluminanceUnit(Box<IlluminanceUnitAny>),
    #[holder(use_place_holder)]
    InductanceUnit(Box<InductanceUnitAny>),
    #[holder(use_place_holder)]
    MagneticFluxDensityUnit(Box<MagneticFluxDensityUnitAny>),
    #[holder(use_place_holder)]
    MagneticFluxUnit(Box<MagneticFluxUnitAny>),
    #[holder(use_place_holder)]
    PowerUnit(Box<PowerUnitAny>),
    #[holder(use_place_holder)]
    PressureUnit(Box<PressureUnitAny>),
    #[holder(use_place_holder)]
    RadioactivityUnit(Box<RadioactivityUnitAny>),
    #[holder(use_place_holder)]
    ResistanceUnit(Box<ResistanceUnitAny>),
    #[holder(use_place_holder)]
    ThermalResistanceUnit(Box<ThermalResistanceUnit>),
    #[holder(use_place_holder)]
    VelocityUnit(Box<VelocityUnit>),
    #[holder(use_place_holder)]
    VolumeUnit(Box<VolumeUnit>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = derived_unit_element)]
#[holder(generate_deserialize)]
pub struct DerivedUnitElement {
    #[holder(use_place_holder)]
    pub unit: NamedUnitAny,
    pub exponent: f64,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = description_attribute)]
#[holder(generate_deserialize)]
pub struct DescriptionAttribute {
    #[holder(use_place_holder)]
    pub attribute_value: Text,
    #[holder(use_place_holder)]
    pub described_item: DescriptionAttributeSelect,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = descriptive_representation_item)]
#[holder(generate_deserialize)]
pub struct DescriptiveRepresentationItem {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Text,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DescriptiveRepresentationItemAny {
    #[holder(use_place_holder)]
    DescriptiveRepresentationItem(Box<DescriptiveRepresentationItem>),
    #[holder(use_place_holder)]
    EnumReferencePrefix(Box<EnumReferencePrefix>),
    #[holder(use_place_holder)]
    RangeCharacteristic(Box<RangeCharacteristic>),
    #[holder(use_place_holder)]
    TaggedTextItem(Box<TaggedTextItem>),
    #[holder(use_place_holder)]
    UniformResourceIdentifier(Box<UniformResourceIdentifier>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = design_context)]
#[holder(generate_deserialize)]
pub struct DesignContext {
    #[holder(use_place_holder)]
    #[holder(supertype = "application_context_element")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "application_context_element")]
    pub frame_of_reference: ApplicationContext,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_context")]
    pub life_cycle_stage: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = design_make_from_relationship)]
#[holder(generate_deserialize)]
pub struct DesignMakeFromRelationship {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub relating_product_definition: ProductDefinitionAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub related_product_definition: ProductDefinitionAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = diameter_dimension)]
#[holder(generate_deserialize)]
pub struct DiameterDimension {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "draughting_callout")]
    pub contents: Vec<DraughtingCalloutElement>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = dielectric_constant_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct DielectricConstantMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = dimension_callout)]
#[holder(generate_deserialize)]
pub struct DimensionCallout {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "draughting_callout")]
    pub contents: Vec<DraughtingCalloutElement>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = dimension_callout_component_relationship)]
#[holder(generate_deserialize)]
pub struct DimensionCalloutComponentRelationship {
    #[holder(use_place_holder)]
    #[holder(supertype = "draughting_callout_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "draughting_callout_relationship")]
    pub description: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "draughting_callout_relationship")]
    pub relating_draughting_callout: DraughtingCalloutAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "draughting_callout_relationship")]
    pub related_draughting_callout: DraughtingCalloutAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = dimension_callout_relationship)]
#[holder(generate_deserialize)]
pub struct DimensionCalloutRelationship {
    #[holder(use_place_holder)]
    #[holder(supertype = "draughting_callout_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "draughting_callout_relationship")]
    pub description: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "draughting_callout_relationship")]
    pub relating_draughting_callout: DraughtingCalloutAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "draughting_callout_relationship")]
    pub related_draughting_callout: DraughtingCalloutAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = dimension_curve)]
#[holder(generate_deserialize)]
pub struct DimensionCurve {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "styled_item")]
    pub styles: Vec<PresentationStyleAssignmentAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "styled_item")]
    pub item: RepresentationItemAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = dimension_curve_directed_callout)]
#[holder(generate_deserialize)]
pub struct DimensionCurveDirectedCallout {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "draughting_callout")]
    pub contents: Vec<DraughtingCalloutElement>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DimensionCurveDirectedCalloutAny {
    #[holder(use_place_holder)]
    DimensionCurveDirectedCallout(Box<DimensionCurveDirectedCallout>),
    #[holder(use_place_holder)]
    AngularDimension(Box<AngularDimension>),
    #[holder(use_place_holder)]
    CurveDimension(Box<CurveDimension>),
    #[holder(use_place_holder)]
    DiameterDimension(Box<DiameterDimension>),
    #[holder(use_place_holder)]
    LinearDimension(Box<LinearDimension>),
    #[holder(use_place_holder)]
    RadiusDimension(Box<RadiusDimension>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = dimension_curve_terminator)]
#[holder(generate_deserialize)]
pub struct DimensionCurveTerminator {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "styled_item")]
    pub styles: Vec<PresentationStyleAssignmentAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "styled_item")]
    pub item: RepresentationItemAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "terminator_symbol")]
    pub annotated_curve: AnnotationCurveOccurrenceAny,
    pub role: DimensionExtentUsage,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = dimension_curve_terminator_to_projection_curve_associativity)]
#[holder(generate_deserialize)]
pub struct DimensionCurveTerminatorToProjectionCurveAssociativity {
    #[holder(use_place_holder)]
    #[holder(supertype = "annotation_occurrence_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "annotation_occurrence_relationship")]
    pub description: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "annotation_occurrence_relationship")]
    pub relating_annotation_occurrence: AnnotationOccurrenceAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "annotation_occurrence_relationship")]
    pub related_annotation_occurrence: AnnotationOccurrenceAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = dimension_pair)]
#[holder(generate_deserialize)]
pub struct DimensionPair {
    #[holder(use_place_holder)]
    #[holder(supertype = "draughting_callout_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "draughting_callout_relationship")]
    pub description: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "draughting_callout_relationship")]
    pub relating_draughting_callout: DraughtingCalloutAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "draughting_callout_relationship")]
    pub related_draughting_callout: DraughtingCalloutAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = dimension_related_tolerance_zone_element)]
#[holder(generate_deserialize)]
pub struct DimensionRelatedToleranceZoneElement {
    #[holder(use_place_holder)]
    pub related_dimension: DimensionalLocationAny,
    #[holder(use_place_holder)]
    pub related_element: ToleranceZoneDefinitionAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = dimension_text_associativity)]
#[holder(generate_deserialize)]
pub struct DimensionTextAssociativity {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "text_literal")]
    pub literal: PresentableText,
    #[holder(use_place_holder)]
    #[holder(supertype = "text_literal")]
    pub placement: Axis2Placement,
    #[holder(use_place_holder)]
    #[holder(supertype = "text_literal")]
    pub alignment: TextAlignment,
    #[holder(supertype = "text_literal")]
    pub path: TextPath,
    #[holder(use_place_holder)]
    #[holder(supertype = "text_literal")]
    pub font: FontSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "mapped_item")]
    pub mapping_source: RepresentationMapAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "mapped_item")]
    pub mapping_target: RepresentationItemAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = dimensional_characteristic_representation)]
#[holder(generate_deserialize)]
pub struct DimensionalCharacteristicRepresentation {
    #[holder(use_place_holder)]
    pub dimension: DimensionalCharacteristic,
    #[holder(use_place_holder)]
    pub representation: ShapeDimensionRepresentation,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = dimensional_exponents)]
#[holder(generate_deserialize)]
pub struct DimensionalExponents {
    pub length_exponent: f64,
    pub mass_exponent: f64,
    pub time_exponent: f64,
    pub electric_current_exponent: f64,
    pub thermodynamic_temperature_exponent: f64,
    pub amount_of_substance_exponent: f64,
    pub luminous_intensity_exponent: f64,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = dimensional_location)]
#[holder(generate_deserialize)]
pub struct DimensionalLocation {
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect_relationship")]
    pub relating_shape_aspect: ShapeAspectAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect_relationship")]
    pub related_shape_aspect: ShapeAspectAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DimensionalLocationAny {
    #[holder(use_place_holder)]
    DimensionalLocation(Box<DimensionalLocation>),
    #[holder(use_place_holder)]
    AngularLocation(Box<AngularLocation>),
    #[holder(use_place_holder)]
    DimensionalLocationWithPath(Box<DimensionalLocationWithPath>),
    #[holder(use_place_holder)]
    DirectedDimensionalLocation(Box<DirectedDimensionalLocation>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = dimensional_location_with_path)]
#[holder(generate_deserialize)]
pub struct DimensionalLocationWithPath {
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect_relationship")]
    pub relating_shape_aspect: ShapeAspectAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect_relationship")]
    pub related_shape_aspect: ShapeAspectAny,
    #[holder(use_place_holder)]
    pub path: ShapeAspectAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = dimensional_size)]
#[holder(generate_deserialize)]
pub struct DimensionalSize {
    #[holder(use_place_holder)]
    pub applies_to: ShapeAspectAny,
    #[holder(use_place_holder)]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DimensionalSizeAny {
    #[holder(use_place_holder)]
    DimensionalSize(Box<DimensionalSize>),
    #[holder(use_place_holder)]
    AngularSize(Box<AngularSize>),
    #[holder(use_place_holder)]
    DimensionalSizeWithPath(Box<DimensionalSizeWithPath>),
    #[holder(use_place_holder)]
    ExternallyDefinedDimensionDefinition(Box<ExternallyDefinedDimensionDefinition>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = dimensional_size_with_path)]
#[holder(generate_deserialize)]
pub struct DimensionalSizeWithPath {
    #[holder(use_place_holder)]
    #[holder(supertype = "dimensional_size")]
    pub applies_to: ShapeAspectAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "dimensional_size")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub path: ShapeAspectAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = directed_action)]
#[holder(generate_deserialize)]
pub struct DirectedAction {
    #[holder(use_place_holder)]
    #[holder(supertype = "action")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "action")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "action")]
    pub chosen_method: ActionMethodAny,
    #[holder(use_place_holder)]
    pub directive: ActionDirective,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = directed_dimensional_location)]
#[holder(generate_deserialize)]
pub struct DirectedDimensionalLocation {
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect_relationship")]
    pub relating_shape_aspect: ShapeAspectAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect_relationship")]
    pub related_shape_aspect: ShapeAspectAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = direction)]
#[holder(generate_deserialize)]
pub struct Direction {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    pub direction_ratios: Vec<f64>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = document)]
#[holder(generate_deserialize)]
pub struct Document {
    #[holder(use_place_holder)]
    pub id: Identifier,
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub kind: DocumentType,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DocumentAny {
    #[holder(use_place_holder)]
    Document(Box<Document>),
    #[holder(use_place_holder)]
    DocumentFile(Box<DocumentFile>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = document_file)]
#[holder(generate_deserialize)]
pub struct DocumentFile {
    #[holder(use_place_holder)]
    #[holder(supertype = "document")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "document")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "document")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "document")]
    pub kind: DocumentType,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = document_identifier)]
#[holder(generate_deserialize)]
pub struct DocumentIdentifier {
    #[holder(use_place_holder)]
    #[holder(supertype = "group")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "group")]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = document_identifier_assignment)]
#[holder(generate_deserialize)]
pub struct DocumentIdentifierAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "group_assignment")]
    pub assigned_group: GroupAny,
    #[holder(use_place_holder)]
    pub items: Vec<DocumentIdentifierAssignedItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = document_product_association)]
#[holder(generate_deserialize)]
pub struct DocumentProductAssociation {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub relating_document: DocumentAny,
    #[holder(use_place_holder)]
    pub related_product: ProductOrFormationOrDefinition,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DocumentProductAssociationAny {
    #[holder(use_place_holder)]
    DocumentProductAssociation(Box<DocumentProductAssociation>),
    #[holder(use_place_holder)]
    DocumentProductEquivalence(Box<DocumentProductEquivalence>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = document_product_equivalence)]
#[holder(generate_deserialize)]
pub struct DocumentProductEquivalence {
    #[holder(use_place_holder)]
    #[holder(supertype = "document_product_association")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "document_product_association")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "document_product_association")]
    pub relating_document: DocumentAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "document_product_association")]
    pub related_product: ProductOrFormationOrDefinition,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = document_reference)]
#[holder(generate_deserialize)]
pub struct DocumentReference {
    #[holder(use_place_holder)]
    pub assigned_document: DocumentAny,
    #[holder(use_place_holder)]
    pub source: Label,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DocumentReferenceAny {
    #[holder(use_place_holder)]
    DocumentReference(Box<DocumentReference>),
    #[holder(use_place_holder)]
    AppliedDocumentReference(Box<AppliedDocumentReference>),
    #[holder(use_place_holder)]
    CcDesignSpecificationReference(Box<CcDesignSpecificationReference>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = document_relationship)]
#[holder(generate_deserialize)]
pub struct DocumentRelationship {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub relating_document: DocumentAny,
    #[holder(use_place_holder)]
    pub related_document: DocumentAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = document_representation_type)]
#[holder(generate_deserialize)]
pub struct DocumentRepresentationType {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub represented_document: DocumentAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = document_type)]
#[holder(generate_deserialize)]
pub struct DocumentType {
    #[holder(use_place_holder)]
    pub product_data_type: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = document_usage_constraint)]
#[holder(generate_deserialize)]
pub struct DocumentUsageConstraint {
    #[holder(use_place_holder)]
    pub source: DocumentAny,
    #[holder(use_place_holder)]
    pub subject_element: Label,
    #[holder(use_place_holder)]
    pub subject_element_value: Text,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = document_usage_constraint_assignment)]
#[holder(generate_deserialize)]
pub struct DocumentUsageConstraintAssignment {
    #[holder(use_place_holder)]
    pub assigned_document_usage: DocumentUsageConstraint,
    #[holder(use_place_holder)]
    pub role: DocumentUsageRole,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DocumentUsageConstraintAssignmentAny {
    #[holder(use_place_holder)]
    DocumentUsageConstraintAssignment(Box<DocumentUsageConstraintAssignment>),
    #[holder(use_place_holder)]
    AppliedDocumentUsageConstraintAssignment(Box<AppliedDocumentUsageConstraintAssignmentAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = document_usage_role)]
#[holder(generate_deserialize)]
pub struct DocumentUsageRole {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = dose_equivalent_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct DoseEquivalentMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = dose_equivalent_unit)]
#[holder(generate_deserialize)]
pub struct DoseEquivalentUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DoseEquivalentUnitAny {
    #[holder(use_place_holder)]
    DoseEquivalentUnit(Box<DoseEquivalentUnit>),
    #[holder(use_place_holder)]
    SiDoseEquivalentUnit(Box<SiDoseEquivalentUnit>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = double_offset_shelled_solid)]
#[holder(generate_deserialize)]
pub struct DoubleOffsetShelledSolid {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "shelled_solid")]
    pub deleted_face_set: Vec<FaceSurfaceAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "shelled_solid")]
    pub thickness: LengthMeasure,
    #[holder(use_place_holder)]
    pub thickness2: LengthMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = draped_defined_transformation)]
#[holder(generate_deserialize)]
pub struct DrapedDefinedTransformation {
    #[holder(use_place_holder)]
    #[holder(supertype = "item_defined_transformation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "item_defined_transformation")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "item_defined_transformation")]
    pub transform_item_1: RepresentationItemAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "item_defined_transformation")]
    pub transform_item_2: RepresentationItemAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = draughting_annotation_occurrence)]
#[holder(generate_deserialize)]
pub struct DraughtingAnnotationOccurrence {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "styled_item")]
    pub styles: Vec<PresentationStyleAssignmentAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "styled_item")]
    pub item: RepresentationItemAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = draughting_callout)]
#[holder(generate_deserialize)]
pub struct DraughtingCallout {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub contents: Vec<DraughtingCalloutElement>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DraughtingCalloutAny {
    #[holder(use_place_holder)]
    DraughtingCallout(Box<DraughtingCallout>),
    #[holder(use_place_holder)]
    DatumFeatureCallout(Box<DatumFeatureCallout>),
    #[holder(use_place_holder)]
    DatumTargetCallout(Box<DatumTargetCallout>),
    #[holder(use_place_holder)]
    DimensionCallout(Box<DimensionCallout>),
    #[holder(use_place_holder)]
    DimensionCurveDirectedCallout(Box<DimensionCurveDirectedCalloutAny>),
    #[holder(use_place_holder)]
    DraughtingElements(Box<DraughtingElements>),
    #[holder(use_place_holder)]
    GeometricalToleranceCallout(Box<GeometricalToleranceCallout>),
    #[holder(use_place_holder)]
    LeaderDirectedCallout(Box<LeaderDirectedCalloutAny>),
    #[holder(use_place_holder)]
    ProjectionDirectedCallout(Box<ProjectionDirectedCalloutAny>),
    #[holder(use_place_holder)]
    StructuredDimensionCallout(Box<StructuredDimensionCallout>),
    #[holder(use_place_holder)]
    SurfaceConditionCallout(Box<SurfaceConditionCallout>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = draughting_callout_relationship)]
#[holder(generate_deserialize)]
pub struct DraughtingCalloutRelationship {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Text,
    #[holder(use_place_holder)]
    pub relating_draughting_callout: DraughtingCalloutAny,
    #[holder(use_place_holder)]
    pub related_draughting_callout: DraughtingCalloutAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum DraughtingCalloutRelationshipAny {
    #[holder(use_place_holder)]
    DraughtingCalloutRelationship(Box<DraughtingCalloutRelationship>),
    #[holder(use_place_holder)]
    DimensionCalloutComponentRelationship(Box<DimensionCalloutComponentRelationship>),
    #[holder(use_place_holder)]
    DimensionCalloutRelationship(Box<DimensionCalloutRelationship>),
    #[holder(use_place_holder)]
    DimensionPair(Box<DimensionPair>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = draughting_elements)]
#[holder(generate_deserialize)]
pub struct DraughtingElements {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "draughting_callout")]
    pub contents: Vec<DraughtingCalloutElement>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = draughting_model)]
#[holder(generate_deserialize)]
pub struct DraughtingModel {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = draughting_model_item_association)]
#[holder(generate_deserialize)]
pub struct DraughtingModelItemAssociation {
    #[holder(use_place_holder)]
    #[holder(supertype = "item_identified_representation_usage")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "item_identified_representation_usage")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "item_identified_representation_usage")]
    pub definition: RepresentedDefinition,
    #[holder(use_place_holder)]
    #[holder(supertype = "item_identified_representation_usage")]
    pub used_representation: RepresentationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "item_identified_representation_usage")]
    pub identified_item: RepresentationItemAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = draughting_pre_defined_colour)]
#[holder(generate_deserialize)]
pub struct DraughtingPreDefinedColour {
    #[holder(use_place_holder)]
    #[holder(supertype = "pre_defined_item")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = draughting_pre_defined_curve_font)]
#[holder(generate_deserialize)]
pub struct DraughtingPreDefinedCurveFont {
    #[holder(use_place_holder)]
    #[holder(supertype = "pre_defined_item")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = draughting_pre_defined_text_font)]
#[holder(generate_deserialize)]
pub struct DraughtingPreDefinedTextFont {
    #[holder(use_place_holder)]
    #[holder(supertype = "pre_defined_item")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = draughting_subfigure_representation)]
#[holder(generate_deserialize)]
pub struct DraughtingSubfigureRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = draughting_symbol_representation)]
#[holder(generate_deserialize)]
pub struct DraughtingSymbolRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = draughting_text_literal_with_delineation)]
#[holder(generate_deserialize)]
pub struct DraughtingTextLiteralWithDelineation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "text_literal")]
    pub literal: PresentableText,
    #[holder(use_place_holder)]
    #[holder(supertype = "text_literal")]
    pub placement: Axis2Placement,
    #[holder(use_place_holder)]
    #[holder(supertype = "text_literal")]
    pub alignment: TextAlignment,
    #[holder(supertype = "text_literal")]
    pub path: TextPath,
    #[holder(use_place_holder)]
    #[holder(supertype = "text_literal")]
    pub font: FontSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "text_literal_with_delineation")]
    pub delineation: TextDelineation,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = draughting_title)]
#[holder(generate_deserialize)]
pub struct DraughtingTitle {
    #[holder(use_place_holder)]
    pub items: Vec<DraughtingTitledItem>,
    #[holder(use_place_holder)]
    pub language: Label,
    #[holder(use_place_holder)]
    pub contents: Text,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = drawing_definition)]
#[holder(generate_deserialize)]
pub struct DrawingDefinition {
    #[holder(use_place_holder)]
    pub drawing_number: Identifier,
    #[holder(use_place_holder)]
    pub drawing_type: Option<Label>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = drawing_revision)]
#[holder(generate_deserialize)]
pub struct DrawingRevision {
    #[holder(use_place_holder)]
    pub revision_identifier: Identifier,
    #[holder(use_place_holder)]
    pub drawing_identifier: DrawingDefinition,
    #[holder(use_place_holder)]
    pub intended_scale: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = drawing_revision_sequence)]
#[holder(generate_deserialize)]
pub struct DrawingRevisionSequence {
    #[holder(use_place_holder)]
    pub predecessor: DrawingRevision,
    #[holder(use_place_holder)]
    pub successor: DrawingRevision,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = drawing_sheet_revision)]
#[holder(generate_deserialize)]
pub struct DrawingSheetRevision {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
    #[holder(use_place_holder)]
    pub revision_identifier: Identifier,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = drawing_sheet_revision_sequence)]
#[holder(generate_deserialize)]
pub struct DrawingSheetRevisionSequence {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub rep_1: RepresentationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub rep_2: RepresentationAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = drawing_sheet_revision_usage)]
#[holder(generate_deserialize)]
pub struct DrawingSheetRevisionUsage {
    #[holder(use_place_holder)]
    #[holder(supertype = "area_in_set")]
    pub area: PresentationAreaAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "area_in_set")]
    pub in_set: PresentationSetAny,
    #[holder(use_place_holder)]
    pub sheet_number: Identifier,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = edge)]
#[holder(generate_deserialize)]
pub struct Edge {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub edge_start: VertexAny,
    #[holder(use_place_holder)]
    pub edge_end: VertexAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum EdgeAny {
    #[holder(use_place_holder)]
    Edge(Box<Edge>),
    #[holder(use_place_holder)]
    EdgeCurve(Box<EdgeCurve>),
    #[holder(use_place_holder)]
    OrientedEdge(Box<OrientedEdge>),
    #[holder(use_place_holder)]
    Subedge(Box<Subedge>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = edge_based_wireframe_model)]
#[holder(generate_deserialize)]
pub struct EdgeBasedWireframeModel {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub ebwm_boundary: Vec<ConnectedEdgeSet>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = edge_based_wireframe_shape_representation)]
#[holder(generate_deserialize)]
pub struct EdgeBasedWireframeShapeRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = edge_blended_solid)]
#[holder(generate_deserialize)]
pub struct EdgeBlendedSolid {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    pub blended_edges: Vec<EdgeCurve>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum EdgeBlendedSolidAny {
    #[holder(use_place_holder)]
    EdgeBlendedSolid(Box<EdgeBlendedSolid>),
    #[holder(use_place_holder)]
    SolidWithChamferedEdges(Box<SolidWithChamferedEdgesAny>),
    #[holder(use_place_holder)]
    SolidWithConstantRadiusEdgeBlend(Box<SolidWithConstantRadiusEdgeBlend>),
    #[holder(use_place_holder)]
    SolidWithVariableRadiusEdgeBlend(Box<SolidWithVariableRadiusEdgeBlend>),
    #[holder(use_place_holder)]
    TrackBlendedSolid(Box<TrackBlendedSolidAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = edge_curve)]
#[holder(generate_deserialize)]
pub struct EdgeCurve {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "edge")]
    pub edge_start: VertexAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "edge")]
    pub edge_end: VertexAny,
    #[holder(use_place_holder)]
    pub edge_geometry: CurveAny,
    pub same_sense: bool,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = edge_loop)]
#[holder(generate_deserialize)]
pub struct EdgeLoop {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "path")]
    pub edge_list: Vec<OrientedEdge>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = effectivity)]
#[holder(generate_deserialize)]
pub struct Effectivity {
    #[holder(use_place_holder)]
    pub id: Identifier,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum EffectivityAny {
    #[holder(use_place_holder)]
    Effectivity(Box<Effectivity>),
    #[holder(use_place_holder)]
    DatedEffectivity(Box<DatedEffectivity>),
    #[holder(use_place_holder)]
    LotEffectivity(Box<LotEffectivity>),
    #[holder(use_place_holder)]
    ProductDefinitionEffectivity(Box<ProductDefinitionEffectivityAny>),
    #[holder(use_place_holder)]
    SerialNumberedEffectivity(Box<SerialNumberedEffectivity>),
    #[holder(use_place_holder)]
    TimeIntervalBasedEffectivity(Box<TimeIntervalBasedEffectivity>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = effectivity_assignment)]
#[holder(generate_deserialize)]
pub struct EffectivityAssignment {
    #[holder(use_place_holder)]
    pub assigned_effectivity: EffectivityAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum EffectivityAssignmentAny {
    #[holder(use_place_holder)]
    EffectivityAssignment(Box<EffectivityAssignment>),
    #[holder(use_place_holder)]
    AppliedEffectivityAssignment(Box<AppliedEffectivityAssignment>),
    #[holder(use_place_holder)]
    ConfiguredEffectivityAssignment(Box<ConfiguredEffectivityAssignment>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = effectivity_context_assignment)]
#[holder(generate_deserialize)]
pub struct EffectivityContextAssignment {
    #[holder(use_place_holder)]
    pub assigned_effectivity_assignment: EffectivityAssignmentAny,
    #[holder(use_place_holder)]
    pub role: EffectivityContextRole,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum EffectivityContextAssignmentAny {
    #[holder(use_place_holder)]
    EffectivityContextAssignment(Box<EffectivityContextAssignment>),
    #[holder(use_place_holder)]
    ClassUsageEffectivityContextAssignment(Box<ClassUsageEffectivityContextAssignment>),
    #[holder(use_place_holder)]
    ConfiguredEffectivityContextAssignment(Box<ConfiguredEffectivityContextAssignment>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = effectivity_context_role)]
#[holder(generate_deserialize)]
pub struct EffectivityContextRole {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = effectivity_relationship)]
#[holder(generate_deserialize)]
pub struct EffectivityRelationship {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub related_effectivity: EffectivityAny,
    #[holder(use_place_holder)]
    pub relating_effectivity: EffectivityAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = electric_charge_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct ElectricChargeMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = electric_charge_unit)]
#[holder(generate_deserialize)]
pub struct ElectricChargeUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ElectricChargeUnitAny {
    #[holder(use_place_holder)]
    ElectricChargeUnit(Box<ElectricChargeUnit>),
    #[holder(use_place_holder)]
    SiElectricChargeUnit(Box<SiElectricChargeUnit>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = electric_current_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct ElectricCurrentMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = electric_current_unit)]
#[holder(generate_deserialize)]
pub struct ElectricCurrentUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "named_unit")]
    pub dimensions: DimensionalExponents,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = electric_potential_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct ElectricPotentialMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = electric_potential_unit)]
#[holder(generate_deserialize)]
pub struct ElectricPotentialUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ElectricPotentialUnitAny {
    #[holder(use_place_holder)]
    ElectricPotentialUnit(Box<ElectricPotentialUnit>),
    #[holder(use_place_holder)]
    SiElectricPotentialUnit(Box<SiElectricPotentialUnit>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = elementary_brep_shape_representation)]
#[holder(generate_deserialize)]
pub struct ElementaryBrepShapeRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = elementary_surface)]
#[holder(generate_deserialize)]
pub struct ElementarySurface {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub position: Axis2Placement3D,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ElementarySurfaceAny {
    #[holder(use_place_holder)]
    ElementarySurface(Box<ElementarySurface>),
    #[holder(use_place_holder)]
    ConicalSurface(Box<ConicalSurface>),
    #[holder(use_place_holder)]
    CylindricalSurface(Box<CylindricalSurface>),
    #[holder(use_place_holder)]
    Plane(Box<Plane>),
    #[holder(use_place_holder)]
    SphericalSurface(Box<SphericalSurface>),
    #[holder(use_place_holder)]
    ToroidalSurface(Box<ToroidalSurfaceAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = ellipse)]
#[holder(generate_deserialize)]
pub struct Ellipse {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "conic")]
    pub position: Axis2Placement,
    #[holder(use_place_holder)]
    pub semi_axis_1: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    pub semi_axis_2: PositiveLengthMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = energy_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct EnergyMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = energy_unit)]
#[holder(generate_deserialize)]
pub struct EnergyUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum EnergyUnitAny {
    #[holder(use_place_holder)]
    EnergyUnit(Box<EnergyUnit>),
    #[holder(use_place_holder)]
    SiEnergyUnit(Box<SiEnergyUnit>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = entity_assertion)]
#[holder(generate_deserialize)]
pub struct EntityAssertion {
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition")]
    pub definition: CharacterizedDefinition,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = enum_reference_prefix)]
#[holder(generate_deserialize)]
pub struct EnumReferencePrefix {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "descriptive_representation_item")]
    pub description: Text,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = environment)]
#[holder(generate_deserialize)]
pub struct Environment {
    #[holder(use_place_holder)]
    pub syntactic_representation: GenericVariable,
    #[holder(use_place_holder)]
    pub semantics: VariableSemanticsAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = evaluated_characteristic)]
#[holder(generate_deserialize)]
pub struct EvaluatedCharacteristic {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub rep_1: RepresentationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub rep_2: RepresentationAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = evaluated_degenerate_pcurve)]
#[holder(generate_deserialize)]
pub struct EvaluatedDegeneratePcurve {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "degenerate_pcurve")]
    pub basis_surface: SurfaceAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "degenerate_pcurve")]
    pub reference_to_curve: DefinitionalRepresentation,
    #[holder(use_place_holder)]
    pub equivalent_point: CartesianPoint,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = evaluation_product_definition)]
#[holder(generate_deserialize)]
pub struct EvaluationProductDefinition {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub formation: ProductDefinitionFormationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub frame_of_reference: ProductDefinitionContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = event_occurrence)]
#[holder(generate_deserialize)]
pub struct EventOccurrence {
    #[holder(use_place_holder)]
    pub id: Identifier,
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum EventOccurrenceAny {
    #[holder(use_place_holder)]
    EventOccurrence(Box<EventOccurrence>),
    #[holder(use_place_holder)]
    RelativeEventOccurrence(Box<RelativeEventOccurrence>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = event_occurrence_assignment)]
#[holder(generate_deserialize)]
pub struct EventOccurrenceAssignment {
    #[holder(use_place_holder)]
    pub assigned_event_occurrence: EventOccurrenceAny,
    #[holder(use_place_holder)]
    pub role: EventOccurrenceRole,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum EventOccurrenceAssignmentAny {
    #[holder(use_place_holder)]
    EventOccurrenceAssignment(Box<EventOccurrenceAssignment>),
    #[holder(use_place_holder)]
    AppliedEventOccurrenceAssignment(Box<AppliedEventOccurrenceAssignment>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = event_occurrence_relationship)]
#[holder(generate_deserialize)]
pub struct EventOccurrenceRelationship {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub relating_event: EventOccurrenceAny,
    #[holder(use_place_holder)]
    pub related_event: EventOccurrenceAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = event_occurrence_role)]
#[holder(generate_deserialize)]
pub struct EventOccurrenceRole {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = exclusive_product_concept_feature_category)]
#[holder(generate_deserialize)]
pub struct ExclusiveProductConceptFeatureCategory {
    #[holder(use_place_holder)]
    #[holder(supertype = "group")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "group")]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = executed_action)]
#[holder(generate_deserialize)]
pub struct ExecutedAction {
    #[holder(use_place_holder)]
    #[holder(supertype = "action")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "action")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "action")]
    pub chosen_method: ActionMethodAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ExecutedActionAny {
    #[holder(use_place_holder)]
    ExecutedAction(Box<ExecutedAction>),
    #[holder(use_place_holder)]
    DirectedAction(Box<DirectedAction>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = expanded_uncertainty)]
#[holder(generate_deserialize)]
pub struct ExpandedUncertainty {
    #[holder(use_place_holder)]
    #[holder(supertype = "uncertainty_qualifier")]
    pub measure_name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "uncertainty_qualifier")]
    pub description: Text,
    #[holder(supertype = "standard_uncertainty")]
    pub uncertainty_value: f64,
    pub coverage_factor: f64,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = explicit_procedural_geometric_representation_item_relationship)]
#[holder(generate_deserialize)]
pub struct ExplicitProceduralGeometricRepresentationItemRelationship {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item_relationship")]
    pub relating_representation_item: RepresentationItemAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item_relationship")]
    pub related_representation_item: RepresentationItemAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = explicit_procedural_representation_item_relationship)]
#[holder(generate_deserialize)]
pub struct ExplicitProceduralRepresentationItemRelationship {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item_relationship")]
    pub relating_representation_item: RepresentationItemAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item_relationship")]
    pub related_representation_item: RepresentationItemAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ExplicitProceduralRepresentationItemRelationshipAny {
    #[holder(use_place_holder)]
    ExplicitProceduralRepresentationItemRelationship(
        Box<ExplicitProceduralRepresentationItemRelationship>,
    ),
    #[holder(use_place_holder)]
    ExplicitProceduralGeometricRepresentationItemRelationship(
        Box<ExplicitProceduralGeometricRepresentationItemRelationship>,
    ),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = explicit_procedural_representation_relationship)]
#[holder(generate_deserialize)]
pub struct ExplicitProceduralRepresentationRelationship {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub rep_1: RepresentationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub rep_2: RepresentationAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ExplicitProceduralRepresentationRelationshipAny {
    #[holder(use_place_holder)]
    ExplicitProceduralRepresentationRelationship(Box<ExplicitProceduralRepresentationRelationship>),
    #[holder(use_place_holder)]
    ExplicitProceduralShapeRepresentationRelationship(
        Box<ExplicitProceduralShapeRepresentationRelationship>,
    ),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = explicit_procedural_shape_representation_relationship)]
#[holder(generate_deserialize)]
pub struct ExplicitProceduralShapeRepresentationRelationship {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub rep_1: RepresentationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub rep_2: RepresentationAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = expression)]
#[holder(generate_deserialize)]
pub struct Expression {}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ExpressionAny {
    #[holder(use_place_holder)]
    Expression(Box<Expression>),
    #[holder(use_place_holder)]
    BooleanExpression(Box<BooleanExpressionAny>),
    #[holder(use_place_holder)]
    NumericExpression(Box<NumericExpressionAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = expression_conversion_based_unit)]
#[holder(generate_deserialize)]
pub struct ExpressionConversionBasedUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "named_unit")]
    pub dimensions: DimensionalExponents,
    #[holder(use_place_holder)]
    #[holder(supertype = "context_dependent_unit")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = extension)]
#[holder(generate_deserialize)]
pub struct Extension {
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub of_shape: ProductDefinitionShape,
    #[holder(supertype = "shape_aspect")]
    pub product_definitional: Logical,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = extent)]
#[holder(generate_deserialize)]
pub struct Extent {
    #[holder(use_place_holder)]
    #[holder(supertype = "characterized_object")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "characterized_object")]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = external_class_library)]
#[holder(generate_deserialize)]
pub struct ExternalClassLibrary {
    #[holder(use_place_holder)]
    #[holder(supertype = "external_source")]
    pub source_id: SourceItem,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = external_identification_assignment)]
#[holder(generate_deserialize)]
pub struct ExternalIdentificationAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "identification_assignment")]
    pub assigned_id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "identification_assignment")]
    pub role: IdentificationRole,
    #[holder(use_place_holder)]
    pub source: ExternalSourceAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ExternalIdentificationAssignmentAny {
    #[holder(use_place_holder)]
    ExternalIdentificationAssignment(Box<ExternalIdentificationAssignment>),
    #[holder(use_place_holder)]
    AppliedExternalIdentificationAssignment(Box<AppliedExternalIdentificationAssignment>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = external_source)]
#[holder(generate_deserialize)]
pub struct ExternalSource {
    #[holder(use_place_holder)]
    pub source_id: SourceItem,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ExternalSourceAny {
    #[holder(use_place_holder)]
    ExternalSource(Box<ExternalSource>),
    #[holder(use_place_holder)]
    ExternalClassLibrary(Box<ExternalClassLibrary>),
    #[holder(use_place_holder)]
    KnownSource(Box<KnownSource>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = external_source_relationship)]
#[holder(generate_deserialize)]
pub struct ExternalSourceRelationship {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub relating_source: ExternalSourceAny,
    #[holder(use_place_holder)]
    pub related_source: ExternalSourceAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = externally_defined_class)]
#[holder(generate_deserialize)]
pub struct ExternallyDefinedClass {
    #[holder(use_place_holder)]
    #[holder(supertype = "group")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "group")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "externally_defined_item")]
    pub item_id: SourceItem,
    #[holder(use_place_holder)]
    #[holder(supertype = "externally_defined_item")]
    pub source: ExternalSourceAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = externally_defined_colour)]
#[holder(generate_deserialize)]
pub struct ExternallyDefinedColour {
    #[holder(use_place_holder)]
    #[holder(supertype = "colour_specification")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "externally_defined_item")]
    pub item_id: SourceItem,
    #[holder(use_place_holder)]
    #[holder(supertype = "externally_defined_item")]
    pub source: ExternalSourceAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = externally_defined_context_dependent_unit)]
#[holder(generate_deserialize)]
pub struct ExternallyDefinedContextDependentUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "named_unit")]
    pub dimensions: DimensionalExponents,
    #[holder(use_place_holder)]
    #[holder(supertype = "context_dependent_unit")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "externally_defined_item")]
    pub item_id: SourceItem,
    #[holder(use_place_holder)]
    #[holder(supertype = "externally_defined_item")]
    pub source: ExternalSourceAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ExternallyDefinedContextDependentUnitAny {
    #[holder(use_place_holder)]
    ExternallyDefinedContextDependentUnit(Box<ExternallyDefinedContextDependentUnit>),
    #[holder(use_place_holder)]
    ExternallyDefinedCurrency(Box<ExternallyDefinedCurrency>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = externally_defined_conversion_based_unit)]
#[holder(generate_deserialize)]
pub struct ExternallyDefinedConversionBasedUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "named_unit")]
    pub dimensions: DimensionalExponents,
    #[holder(use_place_holder)]
    #[holder(supertype = "conversion_based_unit")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "conversion_based_unit")]
    pub conversion_factor: MeasureWithUnitAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "externally_defined_item")]
    pub item_id: SourceItem,
    #[holder(use_place_holder)]
    #[holder(supertype = "externally_defined_item")]
    pub source: ExternalSourceAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = externally_defined_currency)]
#[holder(generate_deserialize)]
pub struct ExternallyDefinedCurrency {
    #[holder(use_place_holder)]
    #[holder(supertype = "named_unit")]
    pub dimensions: DimensionalExponents,
    #[holder(use_place_holder)]
    #[holder(supertype = "context_dependent_unit")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "externally_defined_item")]
    pub item_id: SourceItem,
    #[holder(use_place_holder)]
    #[holder(supertype = "externally_defined_item")]
    pub source: ExternalSourceAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = externally_defined_curve_font)]
#[holder(generate_deserialize)]
pub struct ExternallyDefinedCurveFont {
    #[holder(use_place_holder)]
    #[holder(supertype = "externally_defined_item")]
    pub item_id: SourceItem,
    #[holder(use_place_holder)]
    #[holder(supertype = "externally_defined_item")]
    pub source: ExternalSourceAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = externally_defined_dimension_definition)]
#[holder(generate_deserialize)]
pub struct ExternallyDefinedDimensionDefinition {
    #[holder(use_place_holder)]
    #[holder(supertype = "dimensional_size")]
    pub applies_to: ShapeAspectAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "dimensional_size")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "externally_defined_item")]
    pub item_id: SourceItem,
    #[holder(use_place_holder)]
    #[holder(supertype = "externally_defined_item")]
    pub source: ExternalSourceAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = externally_defined_general_property)]
#[holder(generate_deserialize)]
pub struct ExternallyDefinedGeneralProperty {
    #[holder(use_place_holder)]
    #[holder(supertype = "general_property")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "general_property")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "general_property")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "externally_defined_item")]
    pub item_id: SourceItem,
    #[holder(use_place_holder)]
    #[holder(supertype = "externally_defined_item")]
    pub source: ExternalSourceAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = externally_defined_hatch_style)]
#[holder(generate_deserialize)]
pub struct ExternallyDefinedHatchStyle {
    #[holder(use_place_holder)]
    #[holder(supertype = "externally_defined_item")]
    pub item_id: SourceItem,
    #[holder(use_place_holder)]
    #[holder(supertype = "externally_defined_item")]
    pub source: ExternalSourceAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = externally_defined_item)]
#[holder(generate_deserialize)]
pub struct ExternallyDefinedItem {
    #[holder(use_place_holder)]
    pub item_id: SourceItem,
    #[holder(use_place_holder)]
    pub source: ExternalSourceAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ExternallyDefinedItemAny {
    #[holder(use_place_holder)]
    ExternallyDefinedItem(Box<ExternallyDefinedItem>),
    #[holder(use_place_holder)]
    ExternallyDefinedClass(Box<ExternallyDefinedClass>),
    #[holder(use_place_holder)]
    ExternallyDefinedColour(Box<ExternallyDefinedColour>),
    #[holder(use_place_holder)]
    ExternallyDefinedContextDependentUnit(Box<ExternallyDefinedContextDependentUnitAny>),
    #[holder(use_place_holder)]
    ExternallyDefinedConversionBasedUnit(Box<ExternallyDefinedConversionBasedUnit>),
    #[holder(use_place_holder)]
    ExternallyDefinedCurveFont(Box<ExternallyDefinedCurveFont>),
    #[holder(use_place_holder)]
    ExternallyDefinedDimensionDefinition(Box<ExternallyDefinedDimensionDefinition>),
    #[holder(use_place_holder)]
    ExternallyDefinedGeneralProperty(Box<ExternallyDefinedGeneralProperty>),
    #[holder(use_place_holder)]
    ExternallyDefinedHatchStyle(Box<ExternallyDefinedHatchStyle>),
    #[holder(use_place_holder)]
    ExternallyDefinedRepresentationItem(Box<ExternallyDefinedRepresentationItemAny>),
    #[holder(use_place_holder)]
    ExternallyDefinedSymbol(Box<ExternallyDefinedSymbolAny>),
    #[holder(use_place_holder)]
    ExternallyDefinedTextFont(Box<ExternallyDefinedTextFont>),
    #[holder(use_place_holder)]
    ExternallyDefinedTile(Box<ExternallyDefinedTile>),
    #[holder(use_place_holder)]
    ExternallyDefinedTileStyle(Box<ExternallyDefinedTileStyle>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = externally_defined_item_relationship)]
#[holder(generate_deserialize)]
pub struct ExternallyDefinedItemRelationship {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub relating_item: ExternallyDefinedItemAny,
    #[holder(use_place_holder)]
    pub related_item: ExternallyDefinedItemAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = externally_defined_marker)]
#[holder(generate_deserialize)]
pub struct ExternallyDefinedMarker {
    #[holder(use_place_holder)]
    #[holder(supertype = "externally_defined_item")]
    pub item_id: SourceItem,
    #[holder(use_place_holder)]
    #[holder(supertype = "externally_defined_item")]
    pub source: ExternalSourceAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "pre_defined_item")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = externally_defined_picture_representation_item)]
#[holder(generate_deserialize)]
pub struct ExternallyDefinedPictureRepresentationItem {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(supertype = "binary_representation_item")]
    pub binary_value: Binary,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = externally_defined_representation_item)]
#[holder(generate_deserialize)]
pub struct ExternallyDefinedRepresentationItem {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "externally_defined_item")]
    pub item_id: SourceItem,
    #[holder(use_place_holder)]
    #[holder(supertype = "externally_defined_item")]
    pub source: ExternalSourceAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ExternallyDefinedRepresentationItemAny {
    #[holder(use_place_holder)]
    ExternallyDefinedRepresentationItem(Box<ExternallyDefinedRepresentationItem>),
    #[holder(use_place_holder)]
    ExternallyDefinedString(Box<ExternallyDefinedString>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = externally_defined_string)]
#[holder(generate_deserialize)]
pub struct ExternallyDefinedString {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "externally_defined_item")]
    pub item_id: SourceItem,
    #[holder(use_place_holder)]
    #[holder(supertype = "externally_defined_item")]
    pub source: ExternalSourceAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = externally_defined_symbol)]
#[holder(generate_deserialize)]
pub struct ExternallyDefinedSymbol {
    #[holder(use_place_holder)]
    #[holder(supertype = "externally_defined_item")]
    pub item_id: SourceItem,
    #[holder(use_place_holder)]
    #[holder(supertype = "externally_defined_item")]
    pub source: ExternalSourceAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ExternallyDefinedSymbolAny {
    #[holder(use_place_holder)]
    ExternallyDefinedSymbol(Box<ExternallyDefinedSymbol>),
    #[holder(use_place_holder)]
    ExternallyDefinedMarker(Box<ExternallyDefinedMarker>),
    #[holder(use_place_holder)]
    ExternallyDefinedTerminatorSymbol(Box<ExternallyDefinedTerminatorSymbol>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = externally_defined_terminator_symbol)]
#[holder(generate_deserialize)]
pub struct ExternallyDefinedTerminatorSymbol {
    #[holder(use_place_holder)]
    #[holder(supertype = "externally_defined_item")]
    pub item_id: SourceItem,
    #[holder(use_place_holder)]
    #[holder(supertype = "externally_defined_item")]
    pub source: ExternalSourceAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = externally_defined_text_font)]
#[holder(generate_deserialize)]
pub struct ExternallyDefinedTextFont {
    #[holder(use_place_holder)]
    #[holder(supertype = "externally_defined_item")]
    pub item_id: SourceItem,
    #[holder(use_place_holder)]
    #[holder(supertype = "externally_defined_item")]
    pub source: ExternalSourceAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = externally_defined_tile)]
#[holder(generate_deserialize)]
pub struct ExternallyDefinedTile {
    #[holder(use_place_holder)]
    #[holder(supertype = "externally_defined_item")]
    pub item_id: SourceItem,
    #[holder(use_place_holder)]
    #[holder(supertype = "externally_defined_item")]
    pub source: ExternalSourceAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = externally_defined_tile_style)]
#[holder(generate_deserialize)]
pub struct ExternallyDefinedTileStyle {
    #[holder(use_place_holder)]
    #[holder(supertype = "externally_defined_item")]
    pub item_id: SourceItem,
    #[holder(use_place_holder)]
    #[holder(supertype = "externally_defined_item")]
    pub source: ExternalSourceAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = extruded_area_solid)]
#[holder(generate_deserialize)]
pub struct ExtrudedAreaSolid {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "swept_area_solid")]
    pub swept_area: CurveBoundedSurface,
    #[holder(use_place_holder)]
    pub extruded_direction: Direction,
    #[holder(use_place_holder)]
    pub depth: PositiveLengthMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = extruded_face_solid)]
#[holder(generate_deserialize)]
pub struct ExtrudedFaceSolid {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "swept_face_solid")]
    pub swept_face: FaceSurfaceAny,
    #[holder(use_place_holder)]
    pub extruded_direction: Direction,
    #[holder(use_place_holder)]
    pub depth: PositiveLengthMeasure,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ExtrudedFaceSolidAny {
    #[holder(use_place_holder)]
    ExtrudedFaceSolid(Box<ExtrudedFaceSolid>),
    #[holder(use_place_holder)]
    ExtrudedFaceSolidWithTrimConditions(Box<ExtrudedFaceSolidWithTrimConditionsAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = extruded_face_solid_with_draft_angle)]
#[holder(generate_deserialize)]
pub struct ExtrudedFaceSolidWithDraftAngle {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "swept_face_solid")]
    pub swept_face: FaceSurfaceAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "extruded_face_solid")]
    pub extruded_direction: Direction,
    #[holder(use_place_holder)]
    #[holder(supertype = "extruded_face_solid")]
    pub depth: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    #[holder(supertype = "extruded_face_solid_with_trim_conditions")]
    pub first_trim_condition: TrimConditionSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "extruded_face_solid_with_trim_conditions")]
    pub second_trim_condition: TrimConditionSelect,
    #[holder(supertype = "extruded_face_solid_with_trim_conditions")]
    pub first_trim_intent: TrimIntent,
    #[holder(supertype = "extruded_face_solid_with_trim_conditions")]
    pub second_trim_intent: TrimIntent,
    #[holder(use_place_holder)]
    #[holder(supertype = "extruded_face_solid_with_trim_conditions")]
    pub first_offset: NonNegativeLengthMeasure,
    #[holder(use_place_holder)]
    #[holder(supertype = "extruded_face_solid_with_trim_conditions")]
    pub second_offset: NonNegativeLengthMeasure,
    #[holder(use_place_holder)]
    pub draft_angle: PlaneAngleMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = extruded_face_solid_with_multiple_draft_angles)]
#[holder(generate_deserialize)]
pub struct ExtrudedFaceSolidWithMultipleDraftAngles {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "swept_face_solid")]
    pub swept_face: FaceSurfaceAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "extruded_face_solid")]
    pub extruded_direction: Direction,
    #[holder(use_place_holder)]
    #[holder(supertype = "extruded_face_solid")]
    pub depth: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    #[holder(supertype = "extruded_face_solid_with_trim_conditions")]
    pub first_trim_condition: TrimConditionSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "extruded_face_solid_with_trim_conditions")]
    pub second_trim_condition: TrimConditionSelect,
    #[holder(supertype = "extruded_face_solid_with_trim_conditions")]
    pub first_trim_intent: TrimIntent,
    #[holder(supertype = "extruded_face_solid_with_trim_conditions")]
    pub second_trim_intent: TrimIntent,
    #[holder(use_place_holder)]
    #[holder(supertype = "extruded_face_solid_with_trim_conditions")]
    pub first_offset: NonNegativeLengthMeasure,
    #[holder(use_place_holder)]
    #[holder(supertype = "extruded_face_solid_with_trim_conditions")]
    pub second_offset: NonNegativeLengthMeasure,
    #[holder(use_place_holder)]
    pub drafted_edges: Vec<Vec<EdgeCurve>>,
    #[holder(use_place_holder)]
    pub draft_angles: Vec<PlaneAngleMeasure>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = extruded_face_solid_with_trim_conditions)]
#[holder(generate_deserialize)]
pub struct ExtrudedFaceSolidWithTrimConditions {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "swept_face_solid")]
    pub swept_face: FaceSurfaceAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "extruded_face_solid")]
    pub extruded_direction: Direction,
    #[holder(use_place_holder)]
    #[holder(supertype = "extruded_face_solid")]
    pub depth: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    pub first_trim_condition: TrimConditionSelect,
    #[holder(use_place_holder)]
    pub second_trim_condition: TrimConditionSelect,
    pub first_trim_intent: TrimIntent,
    pub second_trim_intent: TrimIntent,
    #[holder(use_place_holder)]
    pub first_offset: NonNegativeLengthMeasure,
    #[holder(use_place_holder)]
    pub second_offset: NonNegativeLengthMeasure,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ExtrudedFaceSolidWithTrimConditionsAny {
    #[holder(use_place_holder)]
    ExtrudedFaceSolidWithTrimConditions(Box<ExtrudedFaceSolidWithTrimConditions>),
    #[holder(use_place_holder)]
    ExtrudedFaceSolidWithDraftAngle(Box<ExtrudedFaceSolidWithDraftAngle>),
    #[holder(use_place_holder)]
    ExtrudedFaceSolidWithMultipleDraftAngles(Box<ExtrudedFaceSolidWithMultipleDraftAngles>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = face)]
#[holder(generate_deserialize)]
pub struct Face {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub bounds: Vec<FaceBoundAny>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum FaceAny {
    #[holder(use_place_holder)]
    Face(Box<Face>),
    #[holder(use_place_holder)]
    FaceSurface(Box<FaceSurfaceAny>),
    #[holder(use_place_holder)]
    OrientedFace(Box<OrientedFace>),
    #[holder(use_place_holder)]
    Subface(Box<Subface>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = face_based_surface_model)]
#[holder(generate_deserialize)]
pub struct FaceBasedSurfaceModel {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub fbsm_faces: Vec<ConnectedFaceSetAny>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = face_bound)]
#[holder(generate_deserialize)]
pub struct FaceBound {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub bound: LoopAny,
    pub orientation: bool,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum FaceBoundAny {
    #[holder(use_place_holder)]
    FaceBound(Box<FaceBound>),
    #[holder(use_place_holder)]
    FaceOuterBound(Box<FaceOuterBound>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = face_outer_bound)]
#[holder(generate_deserialize)]
pub struct FaceOuterBound {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "face_bound")]
    pub bound: LoopAny,
    #[holder(supertype = "face_bound")]
    pub orientation: bool,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = face_surface)]
#[holder(generate_deserialize)]
pub struct FaceSurface {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "face")]
    pub bounds: Vec<FaceBoundAny>,
    #[holder(use_place_holder)]
    pub face_geometry: SurfaceAny,
    pub same_sense: bool,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum FaceSurfaceAny {
    #[holder(use_place_holder)]
    FaceSurface(Box<FaceSurface>),
    #[holder(use_place_holder)]
    AdvancedFace(Box<AdvancedFace>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = faceted_brep)]
#[holder(generate_deserialize)]
pub struct FacetedBrep {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "manifold_solid_brep")]
    pub outer: ClosedShellAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = faceted_brep_shape_representation)]
#[holder(generate_deserialize)]
pub struct FacetedBrepShapeRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = fact_type)]
#[holder(generate_deserialize)]
pub struct FactType {
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition")]
    pub definition: CharacterizedDefinition,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum FactTypeAny {
    #[holder(use_place_holder)]
    FactType(Box<FactType>),
    #[holder(use_place_holder)]
    AttributeAssertion(Box<AttributeAssertion>),
    #[holder(use_place_holder)]
    EntityAssertion(Box<EntityAssertion>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = fill_area_style)]
#[holder(generate_deserialize)]
pub struct FillAreaStyle {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub fill_styles: Vec<FillStyleSelect>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = fill_area_style_colour)]
#[holder(generate_deserialize)]
pub struct FillAreaStyleColour {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub fill_colour: ColourAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = fill_area_style_hatching)]
#[holder(generate_deserialize)]
pub struct FillAreaStyleHatching {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub hatch_line_appearance: CurveStyleAny,
    #[holder(use_place_holder)]
    pub start_of_next_hatch_line: OneDirectionRepeatFactorAny,
    #[holder(use_place_holder)]
    pub point_of_reference_hatch_line: CartesianPoint,
    #[holder(use_place_holder)]
    pub pattern_start: CartesianPoint,
    #[holder(use_place_holder)]
    pub hatch_line_angle: PlaneAngleMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = fill_area_style_tile_coloured_region)]
#[holder(generate_deserialize)]
pub struct FillAreaStyleTileColouredRegion {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub closed_curve: CurveOrAnnotationCurveOccurrence,
    #[holder(use_place_holder)]
    pub region_colour: ColourAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = fill_area_style_tile_curve_with_style)]
#[holder(generate_deserialize)]
pub struct FillAreaStyleTileCurveWithStyle {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub styled_curve: AnnotationCurveOccurrenceAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = fill_area_style_tile_symbol_with_style)]
#[holder(generate_deserialize)]
pub struct FillAreaStyleTileSymbolWithStyle {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub symbol: AnnotationSymbolOccurrenceAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = fill_area_style_tiles)]
#[holder(generate_deserialize)]
pub struct FillAreaStyleTiles {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub tiling_pattern: TwoDirectionRepeatFactor,
    #[holder(use_place_holder)]
    pub tiles: Vec<FillAreaStyleTileShapeSelect>,
    #[holder(use_place_holder)]
    pub tiling_scale: PositiveRatioMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = flat_pattern_ply_representation_relationship)]
#[holder(generate_deserialize)]
pub struct FlatPatternPlyRepresentationRelationship {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub rep_1: RepresentationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub rep_2: RepresentationAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = flatness_tolerance)]
#[holder(generate_deserialize)]
pub struct FlatnessTolerance {
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub description: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub magnitude: MeasureWithUnitAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub toleranced_shape_aspect: ShapeAspectAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = force_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct ForceMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = force_unit)]
#[holder(generate_deserialize)]
pub struct ForceUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ForceUnitAny {
    #[holder(use_place_holder)]
    ForceUnit(Box<ForceUnit>),
    #[holder(use_place_holder)]
    SiForceUnit(Box<SiForceUnit>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = forward_chaining_rule)]
#[holder(generate_deserialize)]
pub struct ForwardChainingRule {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub formation: ProductDefinitionFormationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub frame_of_reference: ProductDefinitionContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = forward_chaining_rule_premise)]
#[holder(generate_deserialize)]
pub struct ForwardChainingRulePremise {
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition")]
    pub definition: CharacterizedDefinition,
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition_representation")]
    pub used_representation: RepresentationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = founded_item)]
#[holder(generate_deserialize)]
pub struct FoundedItem {}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum FoundedItemAny {
    #[holder(use_place_holder)]
    FoundedItem(Box<FoundedItem>),
    #[holder(use_place_holder)]
    BoxDomain(Box<BoxDomain>),
    #[holder(use_place_holder)]
    CharacterGlyphStyleOutline(Box<CharacterGlyphStyleOutline>),
    #[holder(use_place_holder)]
    CharacterGlyphStyleStroke(Box<CharacterGlyphStyleStroke>),
    #[holder(use_place_holder)]
    CompositeCurveSegment(Box<CompositeCurveSegmentAny>),
    #[holder(use_place_holder)]
    CurveStyle(Box<CurveStyleAny>),
    #[holder(use_place_holder)]
    CurveStyleFont(Box<CurveStyleFontAny>),
    #[holder(use_place_holder)]
    CurveStyleFontAndScaling(Box<CurveStyleFontAndScaling>),
    #[holder(use_place_holder)]
    CurveStyleFontPattern(Box<CurveStyleFontPattern>),
    #[holder(use_place_holder)]
    FillAreaStyle(Box<FillAreaStyle>),
    #[holder(use_place_holder)]
    PointStyle(Box<PointStyle>),
    #[holder(use_place_holder)]
    PresentationStyleAssignment(Box<PresentationStyleAssignmentAny>),
    #[holder(use_place_holder)]
    SurfacePatch(Box<SurfacePatch>),
    #[holder(use_place_holder)]
    SurfaceSideStyle(Box<SurfaceSideStyle>),
    #[holder(use_place_holder)]
    SurfaceStyleBoundary(Box<SurfaceStyleBoundary>),
    #[holder(use_place_holder)]
    SurfaceStyleControlGrid(Box<SurfaceStyleControlGrid>),
    #[holder(use_place_holder)]
    SurfaceStyleFillArea(Box<SurfaceStyleFillArea>),
    #[holder(use_place_holder)]
    SurfaceStyleParameterLine(Box<SurfaceStyleParameterLine>),
    #[holder(use_place_holder)]
    SurfaceStyleSegmentationCurve(Box<SurfaceStyleSegmentationCurve>),
    #[holder(use_place_holder)]
    SurfaceStyleSilhouette(Box<SurfaceStyleSilhouette>),
    #[holder(use_place_holder)]
    SurfaceStyleUsage(Box<SurfaceStyleUsage>),
    #[holder(use_place_holder)]
    SymbolStyle(Box<SymbolStyle>),
    #[holder(use_place_holder)]
    TextStyle(Box<TextStyleAny>),
    #[holder(use_place_holder)]
    ViewVolume(Box<ViewVolume>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = frequency_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct FrequencyMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = frequency_unit)]
#[holder(generate_deserialize)]
pub struct FrequencyUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum FrequencyUnitAny {
    #[holder(use_place_holder)]
    FrequencyUnit(Box<FrequencyUnit>),
    #[holder(use_place_holder)]
    SiFrequencyUnit(Box<SiFrequencyUnit>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = func)]
#[holder(generate_deserialize)]
pub struct Func {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "compound_representation_item")]
    pub item_element: CompoundItemDefinition,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = functional_breakdown_context)]
#[holder(generate_deserialize)]
pub struct FunctionalBreakdownContext {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub relating_product_definition: ProductDefinitionAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub related_product_definition: ProductDefinitionAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = functional_element_usage)]
#[holder(generate_deserialize)]
pub struct FunctionalElementUsage {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub relating_product_definition: ProductDefinitionAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub related_product_definition: ProductDefinitionAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = functionally_defined_transformation)]
#[holder(generate_deserialize)]
pub struct FunctionallyDefinedTransformation {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum FunctionallyDefinedTransformationAny {
    #[holder(use_place_holder)]
    FunctionallyDefinedTransformation(Box<FunctionallyDefinedTransformation>),
    #[holder(use_place_holder)]
    CartesianTransformationOperator(Box<CartesianTransformationOperatorAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = general_material_property)]
#[holder(generate_deserialize)]
pub struct GeneralMaterialProperty {
    #[holder(use_place_holder)]
    #[holder(supertype = "general_property")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "general_property")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "general_property")]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = general_property)]
#[holder(generate_deserialize)]
pub struct GeneralProperty {
    #[holder(use_place_holder)]
    pub id: Identifier,
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum GeneralPropertyAny {
    #[holder(use_place_holder)]
    GeneralProperty(Box<GeneralProperty>),
    #[holder(use_place_holder)]
    CharacteristicDataColumnHeader(Box<CharacteristicDataColumnHeader>),
    #[holder(use_place_holder)]
    CharacteristicDataTableHeader(Box<CharacteristicDataTableHeader>),
    #[holder(use_place_holder)]
    ExternallyDefinedGeneralProperty(Box<ExternallyDefinedGeneralProperty>),
    #[holder(use_place_holder)]
    GeneralMaterialProperty(Box<GeneralMaterialProperty>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = general_property_association)]
#[holder(generate_deserialize)]
pub struct GeneralPropertyAssociation {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub base_definition: GeneralPropertyAny,
    #[holder(use_place_holder)]
    pub derived_definition: DerivedPropertySelect,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = general_property_relationship)]
#[holder(generate_deserialize)]
pub struct GeneralPropertyRelationship {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub relating_property: GeneralPropertyAny,
    #[holder(use_place_holder)]
    pub related_property: GeneralPropertyAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum GeneralPropertyRelationshipAny {
    #[holder(use_place_holder)]
    GeneralPropertyRelationship(Box<GeneralPropertyRelationship>),
    #[holder(use_place_holder)]
    CharacteristicDataColumnHeaderLink(Box<CharacteristicDataColumnHeaderLink>),
    #[holder(use_place_holder)]
    CharacteristicDataTableHeaderDecomposition(Box<CharacteristicDataTableHeaderDecomposition>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = generic_character_glyph_symbol)]
#[holder(generate_deserialize)]
pub struct GenericCharacterGlyphSymbol {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum GenericCharacterGlyphSymbolAny {
    #[holder(use_place_holder)]
    GenericCharacterGlyphSymbol(Box<GenericCharacterGlyphSymbol>),
    #[holder(use_place_holder)]
    CharacterGlyphSymbol(Box<CharacterGlyphSymbolAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = generic_expression)]
#[holder(generate_deserialize)]
pub struct GenericExpression {}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum GenericExpressionAny {
    #[holder(use_place_holder)]
    GenericExpression(Box<GenericExpression>),
    #[holder(use_place_holder)]
    BinaryGenericExpression(Box<BinaryGenericExpressionAny>),
    #[holder(use_place_holder)]
    Expression(Box<ExpressionAny>),
    #[holder(use_place_holder)]
    MultipleArityGenericExpression(Box<MultipleArityGenericExpressionAny>),
    #[holder(use_place_holder)]
    SimpleGenericExpression(Box<SimpleGenericExpressionAny>),
    #[holder(use_place_holder)]
    UnaryGenericExpression(Box<UnaryGenericExpressionAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = generic_literal)]
#[holder(generate_deserialize)]
pub struct GenericLiteral {}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum GenericLiteralAny {
    #[holder(use_place_holder)]
    GenericLiteral(Box<GenericLiteral>),
    #[holder(use_place_holder)]
    BooleanLiteral(Box<BooleanLiteralAny>),
    #[holder(use_place_holder)]
    LiteralNumber(Box<LiteralNumberAny>),
    #[holder(use_place_holder)]
    LogicalLiteral(Box<LogicalLiteralAny>),
    #[holder(use_place_holder)]
    PolarComplexNumberLiteral(Box<PolarComplexNumberLiteralAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = generic_variable)]
#[holder(generate_deserialize)]
pub struct GenericVariable {}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = geometric_alignment)]
#[holder(generate_deserialize)]
pub struct GeometricAlignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub of_shape: ProductDefinitionShape,
    #[holder(supertype = "shape_aspect")]
    pub product_definitional: Logical,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = geometric_curve_set)]
#[holder(generate_deserialize)]
pub struct GeometricCurveSet {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_set")]
    pub elements: Vec<GeometricSetSelect>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = geometric_intersection)]
#[holder(generate_deserialize)]
pub struct GeometricIntersection {
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub of_shape: ProductDefinitionShape,
    #[holder(supertype = "shape_aspect")]
    pub product_definitional: Logical,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = geometric_item_specific_usage)]
#[holder(generate_deserialize)]
pub struct GeometricItemSpecificUsage {
    #[holder(use_place_holder)]
    #[holder(supertype = "item_identified_representation_usage")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "item_identified_representation_usage")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "item_identified_representation_usage")]
    pub definition: RepresentedDefinition,
    #[holder(use_place_holder)]
    #[holder(supertype = "item_identified_representation_usage")]
    pub used_representation: RepresentationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "item_identified_representation_usage")]
    pub identified_item: RepresentationItemAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = geometric_model_element_relationship)]
#[holder(generate_deserialize)]
pub struct GeometricModelElementRelationship {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item_relationship")]
    pub relating_representation_item: RepresentationItemAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item_relationship")]
    pub related_representation_item: RepresentationItemAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = geometric_representation_context)]
#[holder(generate_deserialize)]
pub struct GeometricRepresentationContext {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_context")]
    pub context_identifier: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_context")]
    pub context_type: Text,
    #[holder(use_place_holder)]
    pub coordinate_space_dimension: DimensionCount,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = geometric_representation_item)]
#[holder(generate_deserialize)]
pub struct GeometricRepresentationItem {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum GeometricRepresentationItemAny {
    #[holder(use_place_holder)]
    GeometricRepresentationItem(Box<GeometricRepresentationItem>),
    #[holder(use_place_holder)]
    AngleDirectionReference(Box<AngleDirectionReference>),
    #[holder(use_place_holder)]
    AnnotationFillArea(Box<AnnotationFillArea>),
    #[holder(use_place_holder)]
    AnnotationPlane(Box<AnnotationPlane>),
    #[holder(use_place_holder)]
    AuxiliaryGeometricRepresentationItem(Box<AuxiliaryGeometricRepresentationItem>),
    #[holder(use_place_holder)]
    Block(Box<Block>),
    #[holder(use_place_holder)]
    BooleanResult(Box<BooleanResult>),
    #[holder(use_place_holder)]
    CameraModel(Box<CameraModelAny>),
    #[holder(use_place_holder)]
    CameraModelD3MultiClippingIntersection(Box<CameraModelD3MultiClippingIntersection>),
    #[holder(use_place_holder)]
    CameraModelD3MultiClippingUnion(Box<CameraModelD3MultiClippingUnion>),
    #[holder(use_place_holder)]
    CartesianTransformationOperator(Box<CartesianTransformationOperatorAny>),
    #[holder(use_place_holder)]
    CompositeText(Box<CompositeTextAny>),
    #[holder(use_place_holder)]
    ConicalSteppedHoleTransition(Box<ConicalSteppedHoleTransition>),
    #[holder(use_place_holder)]
    Curve(Box<CurveAny>),
    #[holder(use_place_holder)]
    DefinedSymbol(Box<DefinedSymbol>),
    #[holder(use_place_holder)]
    Direction(Box<Direction>),
    #[holder(use_place_holder)]
    DraughtingCallout(Box<DraughtingCalloutAny>),
    #[holder(use_place_holder)]
    EdgeBasedWireframeModel(Box<EdgeBasedWireframeModel>),
    #[holder(use_place_holder)]
    EdgeCurve(Box<EdgeCurve>),
    #[holder(use_place_holder)]
    ExternallyDefinedHatchStyle(Box<ExternallyDefinedHatchStyle>),
    #[holder(use_place_holder)]
    ExternallyDefinedTileStyle(Box<ExternallyDefinedTileStyle>),
    #[holder(use_place_holder)]
    FaceBasedSurfaceModel(Box<FaceBasedSurfaceModel>),
    #[holder(use_place_holder)]
    FaceSurface(Box<FaceSurfaceAny>),
    #[holder(use_place_holder)]
    FillAreaStyleHatching(Box<FillAreaStyleHatching>),
    #[holder(use_place_holder)]
    FillAreaStyleTileColouredRegion(Box<FillAreaStyleTileColouredRegion>),
    #[holder(use_place_holder)]
    FillAreaStyleTileCurveWithStyle(Box<FillAreaStyleTileCurveWithStyle>),
    #[holder(use_place_holder)]
    FillAreaStyleTileSymbolWithStyle(Box<FillAreaStyleTileSymbolWithStyle>),
    #[holder(use_place_holder)]
    FillAreaStyleTiles(Box<FillAreaStyleTiles>),
    #[holder(use_place_holder)]
    GeometricModelElementRelationship(Box<GeometricModelElementRelationship>),
    #[holder(use_place_holder)]
    GeometricSet(Box<GeometricSetAny>),
    #[holder(use_place_holder)]
    HalfSpaceSolid(Box<HalfSpaceSolidAny>),
    #[holder(use_place_holder)]
    LightSource(Box<LightSourceAny>),
    #[holder(use_place_holder)]
    MinAndMajorPlyOrientationBasis(Box<MinAndMajorPlyOrientationBasis>),
    #[holder(use_place_holder)]
    OneDirectionRepeatFactor(Box<OneDirectionRepeatFactorAny>),
    #[holder(use_place_holder)]
    Placement(Box<PlacementAny>),
    #[holder(use_place_holder)]
    PlanarExtent(Box<PlanarExtentAny>),
    #[holder(use_place_holder)]
    Point(Box<PointAny>),
    #[holder(use_place_holder)]
    PointAndVector(Box<PointAndVector>),
    #[holder(use_place_holder)]
    PointPath(Box<PointPath>),
    #[holder(use_place_holder)]
    PolyLoop(Box<PolyLoop>),
    #[holder(use_place_holder)]
    PositionedSketch(Box<PositionedSketch>),
    #[holder(use_place_holder)]
    ProceduralShapeRepresentationSequence(Box<ProceduralShapeRepresentationSequence>),
    #[holder(use_place_holder)]
    RightAngularWedge(Box<RightAngularWedge>),
    #[holder(use_place_holder)]
    RightCircularCone(Box<RightCircularCone>),
    #[holder(use_place_holder)]
    RightCircularCylinder(Box<RightCircularCylinder>),
    #[holder(use_place_holder)]
    ShellBasedSurfaceModel(Box<ShellBasedSurfaceModel>),
    #[holder(use_place_holder)]
    ShellBasedWireframeModel(Box<ShellBasedWireframeModel>),
    #[holder(use_place_holder)]
    SolidModel(Box<SolidModelAny>),
    #[holder(use_place_holder)]
    Sphere(Box<Sphere>),
    #[holder(use_place_holder)]
    Surface(Box<SurfaceAny>),
    #[holder(use_place_holder)]
    SymbolTarget(Box<SymbolTarget>),
    #[holder(use_place_holder)]
    TextLiteral(Box<TextLiteralAny>),
    #[holder(use_place_holder)]
    Torus(Box<Torus>),
    #[holder(use_place_holder)]
    Vector(Box<Vector>),
    #[holder(use_place_holder)]
    VertexPoint(Box<VertexPoint>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = geometric_set)]
#[holder(generate_deserialize)]
pub struct GeometricSet {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub elements: Vec<GeometricSetSelect>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum GeometricSetAny {
    #[holder(use_place_holder)]
    GeometricSet(Box<GeometricSet>),
    #[holder(use_place_holder)]
    GeometricCurveSet(Box<GeometricCurveSet>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = geometric_tolerance)]
#[holder(generate_deserialize)]
pub struct GeometricTolerance {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Text,
    #[holder(use_place_holder)]
    pub magnitude: MeasureWithUnitAny,
    #[holder(use_place_holder)]
    pub toleranced_shape_aspect: ShapeAspectAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum GeometricToleranceAny {
    #[holder(use_place_holder)]
    GeometricTolerance(Box<GeometricTolerance>),
    #[holder(use_place_holder)]
    CylindricityTolerance(Box<CylindricityTolerance>),
    #[holder(use_place_holder)]
    FlatnessTolerance(Box<FlatnessTolerance>),
    #[holder(use_place_holder)]
    GeometricToleranceWithDatumReference(Box<GeometricToleranceWithDatumReferenceAny>),
    #[holder(use_place_holder)]
    GeometricToleranceWithDefinedUnit(Box<GeometricToleranceWithDefinedUnit>),
    #[holder(use_place_holder)]
    LineProfileTolerance(Box<LineProfileTolerance>),
    #[holder(use_place_holder)]
    ModifiedGeometricTolerance(Box<ModifiedGeometricTolerance>),
    #[holder(use_place_holder)]
    PositionTolerance(Box<PositionTolerance>),
    #[holder(use_place_holder)]
    RoundnessTolerance(Box<RoundnessTolerance>),
    #[holder(use_place_holder)]
    StraightnessTolerance(Box<StraightnessTolerance>),
    #[holder(use_place_holder)]
    SurfaceProfileTolerance(Box<SurfaceProfileTolerance>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = geometric_tolerance_relationship)]
#[holder(generate_deserialize)]
pub struct GeometricToleranceRelationship {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Text,
    #[holder(use_place_holder)]
    pub relating_geometric_tolerance: GeometricToleranceAny,
    #[holder(use_place_holder)]
    pub related_geometric_tolerance: GeometricToleranceAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = geometric_tolerance_with_datum_reference)]
#[holder(generate_deserialize)]
pub struct GeometricToleranceWithDatumReference {
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub description: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub magnitude: MeasureWithUnitAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub toleranced_shape_aspect: ShapeAspectAny,
    #[holder(use_place_holder)]
    pub datum_system: Vec<DatumReferenceAny>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum GeometricToleranceWithDatumReferenceAny {
    #[holder(use_place_holder)]
    GeometricToleranceWithDatumReference(Box<GeometricToleranceWithDatumReference>),
    #[holder(use_place_holder)]
    AngularityTolerance(Box<AngularityTolerance>),
    #[holder(use_place_holder)]
    CircularRunoutTolerance(Box<CircularRunoutTolerance>),
    #[holder(use_place_holder)]
    CoaxialityTolerance(Box<CoaxialityTolerance>),
    #[holder(use_place_holder)]
    ConcentricityTolerance(Box<ConcentricityTolerance>),
    #[holder(use_place_holder)]
    ParallelismTolerance(Box<ParallelismTolerance>),
    #[holder(use_place_holder)]
    PerpendicularityTolerance(Box<PerpendicularityTolerance>),
    #[holder(use_place_holder)]
    SymmetryTolerance(Box<SymmetryTolerance>),
    #[holder(use_place_holder)]
    TotalRunoutTolerance(Box<TotalRunoutTolerance>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = geometric_tolerance_with_defined_unit)]
#[holder(generate_deserialize)]
pub struct GeometricToleranceWithDefinedUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub description: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub magnitude: MeasureWithUnitAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub toleranced_shape_aspect: ShapeAspectAny,
    #[holder(use_place_holder)]
    pub unit_size: MeasureWithUnitAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = geometrical_tolerance_callout)]
#[holder(generate_deserialize)]
pub struct GeometricalToleranceCallout {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "draughting_callout")]
    pub contents: Vec<DraughtingCalloutElement>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = geometrically_bounded_2d_wireframe_representation)]
#[holder(generate_deserialize)]
pub struct GeometricallyBounded2DWireframeRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = geometrically_bounded_surface_shape_representation)]
#[holder(generate_deserialize)]
pub struct GeometricallyBoundedSurfaceShapeRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = geometrically_bounded_wireframe_shape_representation)]
#[holder(generate_deserialize)]
pub struct GeometricallyBoundedWireframeShapeRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = global_assignment)]
#[holder(generate_deserialize)]
pub struct GlobalAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item_relationship")]
    pub relating_representation_item: RepresentationItemAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item_relationship")]
    pub related_representation_item: RepresentationItemAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = global_uncertainty_assigned_context)]
#[holder(generate_deserialize)]
pub struct GlobalUncertaintyAssignedContext {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_context")]
    pub context_identifier: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_context")]
    pub context_type: Text,
    #[holder(use_place_holder)]
    pub uncertainty: Vec<UncertaintyMeasureWithUnit>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = global_unit_assigned_context)]
#[holder(generate_deserialize)]
pub struct GlobalUnitAssignedContext {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_context")]
    pub context_identifier: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_context")]
    pub context_type: Text,
    #[holder(use_place_holder)]
    pub units: Vec<Unit>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = ground_fact)]
#[holder(generate_deserialize)]
pub struct GroundFact {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "compound_representation_item")]
    pub item_element: CompoundItemDefinition,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = group)]
#[holder(generate_deserialize)]
pub struct Group {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum GroupAny {
    #[holder(use_place_holder)]
    Group(Box<Group>),
    #[holder(use_place_holder)]
    CharacteristicType(Box<CharacteristicType>),
    #[holder(use_place_holder)]
    Class(Box<ClassAny>),
    #[holder(use_place_holder)]
    ClassSystem(Box<ClassSystem>),
    #[holder(use_place_holder)]
    DocumentIdentifier(Box<DocumentIdentifier>),
    #[holder(use_place_holder)]
    Language(Box<Language>),
    #[holder(use_place_holder)]
    ProductConceptFeatureCategory(Box<ProductConceptFeatureCategoryAny>),
    #[holder(use_place_holder)]
    ProductDefinitionElementRelationship(Box<ProductDefinitionElementRelationshipAny>),
    #[holder(use_place_holder)]
    RepItemGroup(Box<RepItemGroup>),
    #[holder(use_place_holder)]
    RequirementAssignment(Box<RequirementAssignment>),
    #[holder(use_place_holder)]
    RequirementSource(Box<RequirementSource>),
    #[holder(use_place_holder)]
    SatisfiesRequirement(Box<SatisfiesRequirement>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = group_assignment)]
#[holder(generate_deserialize)]
pub struct GroupAssignment {
    #[holder(use_place_holder)]
    pub assigned_group: GroupAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum GroupAssignmentAny {
    #[holder(use_place_holder)]
    GroupAssignment(Box<GroupAssignment>),
    #[holder(use_place_holder)]
    AppliedGroupAssignment(Box<AppliedGroupAssignment>),
    #[holder(use_place_holder)]
    AssignedRequirement(Box<AssignedRequirement>),
    #[holder(use_place_holder)]
    BreakdownElementGroupAssignment(Box<BreakdownElementGroupAssignment>),
    #[holder(use_place_holder)]
    DocumentIdentifierAssignment(Box<DocumentIdentifierAssignment>),
    #[holder(use_place_holder)]
    ProductConceptFeatureCategoryUsage(Box<ProductConceptFeatureCategoryUsage>),
    #[holder(use_place_holder)]
    ProductDefinitionGroupAssignment(Box<ProductDefinitionGroupAssignment>),
    #[holder(use_place_holder)]
    RequirementAssignedObject(Box<RequirementAssignedObject>),
    #[holder(use_place_holder)]
    SatisfiedRequirement(Box<SatisfiedRequirement>),
    #[holder(use_place_holder)]
    SatisfyingItem(Box<SatisfyingItem>),
    #[holder(use_place_holder)]
    SourceForRequirement(Box<SourceForRequirement>),
    #[holder(use_place_holder)]
    SourcedRequirement(Box<SourcedRequirement>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = group_relationship)]
#[holder(generate_deserialize)]
pub struct GroupRelationship {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub relating_group: GroupAny,
    #[holder(use_place_holder)]
    pub related_group: GroupAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = half_space_solid)]
#[holder(generate_deserialize)]
pub struct HalfSpaceSolid {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub base_surface: SurfaceAny,
    pub agreement_flag: bool,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum HalfSpaceSolidAny {
    #[holder(use_place_holder)]
    HalfSpaceSolid(Box<HalfSpaceSolid>),
    #[holder(use_place_holder)]
    BoxedHalfSpace(Box<BoxedHalfSpace>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = hardness_representation)]
#[holder(generate_deserialize)]
pub struct HardnessRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = hidden_element_over_riding_styled_item)]
#[holder(generate_deserialize)]
pub struct HiddenElementOverRidingStyledItem {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "styled_item")]
    pub styles: Vec<PresentationStyleAssignmentAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "styled_item")]
    pub item: RepresentationItemAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "over_riding_styled_item")]
    pub over_ridden_style: StyledItemAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "context_dependent_over_riding_styled_item")]
    pub style_context: Vec<StyleContextSelect>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = hyperbola)]
#[holder(generate_deserialize)]
pub struct Hyperbola {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "conic")]
    pub position: Axis2Placement,
    #[holder(use_place_holder)]
    pub semi_axis: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    pub semi_imag_axis: PositiveLengthMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = id_attribute)]
#[holder(generate_deserialize)]
pub struct IdAttribute {
    #[holder(use_place_holder)]
    pub attribute_value: Identifier,
    #[holder(use_place_holder)]
    pub identified_item: IdAttributeSelect,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = identification_assignment)]
#[holder(generate_deserialize)]
pub struct IdentificationAssignment {
    #[holder(use_place_holder)]
    pub assigned_id: Identifier,
    #[holder(use_place_holder)]
    pub role: IdentificationRole,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum IdentificationAssignmentAny {
    #[holder(use_place_holder)]
    IdentificationAssignment(Box<IdentificationAssignment>),
    #[holder(use_place_holder)]
    AppliedIdentificationAssignment(Box<AppliedIdentificationAssignment>),
    #[holder(use_place_holder)]
    ExternalIdentificationAssignment(Box<ExternalIdentificationAssignmentAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = identification_role)]
#[holder(generate_deserialize)]
pub struct IdentificationRole {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = illuminance_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct IlluminanceMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = illuminance_unit)]
#[holder(generate_deserialize)]
pub struct IlluminanceUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum IlluminanceUnitAny {
    #[holder(use_place_holder)]
    IlluminanceUnit(Box<IlluminanceUnit>),
    #[holder(use_place_holder)]
    SiIlluminanceUnit(Box<SiIlluminanceUnit>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = included_text_block)]
#[holder(generate_deserialize)]
pub struct IncludedTextBlock {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "mapped_item")]
    pub mapping_source: RepresentationMapAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "mapped_item")]
    pub mapping_target: RepresentationItemAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = inclusion_product_concept_feature)]
#[holder(generate_deserialize)]
pub struct InclusionProductConceptFeature {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_concept_feature")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_concept_feature")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_concept_feature")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "conditional_concept_feature")]
    pub condition: ConceptFeatureRelationshipWithCondition,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = indirectly_selected_elements)]
#[holder(generate_deserialize)]
pub struct IndirectlySelectedElements {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "user_selected_elements")]
    pub picked_items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    pub indirectly_picked_items: Vec<RepresentationItemAny>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum IndirectlySelectedElementsAny {
    #[holder(use_place_holder)]
    IndirectlySelectedElements(Box<IndirectlySelectedElements>),
    #[holder(use_place_holder)]
    IndirectlySelectedShapeElements(Box<IndirectlySelectedShapeElements>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = indirectly_selected_shape_elements)]
#[holder(generate_deserialize)]
pub struct IndirectlySelectedShapeElements {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "user_selected_elements")]
    pub picked_items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "indirectly_selected_elements")]
    pub indirectly_picked_items: Vec<RepresentationItemAny>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = inductance_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct InductanceMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = inductance_unit)]
#[holder(generate_deserialize)]
pub struct InductanceUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum InductanceUnitAny {
    #[holder(use_place_holder)]
    InductanceUnit(Box<InductanceUnit>),
    #[holder(use_place_holder)]
    SiInductanceUnit(Box<SiInductanceUnit>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = information_right)]
#[holder(generate_deserialize)]
pub struct InformationRight {
    #[holder(use_place_holder)]
    #[holder(supertype = "action_method")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "action_method")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "action_method")]
    pub consequence: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "action_method")]
    pub purpose: Text,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = information_usage_right)]
#[holder(generate_deserialize)]
pub struct InformationUsageRight {
    #[holder(use_place_holder)]
    #[holder(supertype = "action_method")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "action_method")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "action_method")]
    pub consequence: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "action_method")]
    pub purpose: Text,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = instance_usage_context_assignment)]
#[holder(generate_deserialize)]
pub struct InstanceUsageContextAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "application_context_element")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "application_context_element")]
    pub frame_of_reference: ApplicationContext,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_context")]
    pub life_cycle_stage: Label,
    #[holder(use_place_holder)]
    pub items: Vec<InstanceUsageContextSelect>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = instanced_feature)]
#[holder(generate_deserialize)]
pub struct InstancedFeature {
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub of_shape: ProductDefinitionShape,
    #[holder(supertype = "shape_aspect")]
    pub product_definitional: Logical,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = int_literal)]
#[holder(generate_deserialize)]
pub struct IntLiteral {
    #[holder(supertype = "literal_number")]
    pub the_value: f64,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum IntLiteralAny {
    #[holder(use_place_holder)]
    IntLiteral(Box<IntLiteral>),
    #[holder(use_place_holder)]
    IntegerRepresentationItem(Box<IntegerRepresentationItem>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = integer_representation_item)]
#[holder(generate_deserialize)]
pub struct IntegerRepresentationItem {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(supertype = "literal_number")]
    pub the_value: f64,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = intersection_curve)]
#[holder(generate_deserialize)]
pub struct IntersectionCurve {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "surface_curve")]
    pub curve_3d: CurveAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "surface_curve")]
    pub associated_geometry: Vec<PcurveOrSurface>,
    #[holder(supertype = "surface_curve")]
    pub master_representation: PreferredSurfaceCurveRepresentation,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = interval_expression)]
#[holder(generate_deserialize)]
pub struct IntervalExpression {
    #[holder(use_place_holder)]
    #[holder(supertype = "multiple_arity_generic_expression")]
    pub operands: Vec<GenericExpressionAny>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = invisibility)]
#[holder(generate_deserialize)]
pub struct Invisibility {
    #[holder(use_place_holder)]
    pub invisible_items: Vec<InvisibleItem>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum InvisibilityAny {
    #[holder(use_place_holder)]
    Invisibility(Box<Invisibility>),
    #[holder(use_place_holder)]
    ContextDependentInvisibility(Box<ContextDependentInvisibility>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = iso4217_currency)]
#[holder(generate_deserialize)]
pub struct Iso4217Currency {
    #[holder(use_place_holder)]
    #[holder(supertype = "named_unit")]
    pub dimensions: DimensionalExponents,
    #[holder(use_place_holder)]
    #[holder(supertype = "context_dependent_unit")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = item_defined_transformation)]
#[holder(generate_deserialize)]
pub struct ItemDefinedTransformation {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub transform_item_1: RepresentationItemAny,
    #[holder(use_place_holder)]
    pub transform_item_2: RepresentationItemAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ItemDefinedTransformationAny {
    #[holder(use_place_holder)]
    ItemDefinedTransformation(Box<ItemDefinedTransformation>),
    #[holder(use_place_holder)]
    TransformationWithDerivedAngle(Box<TransformationWithDerivedAngleAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = item_identified_representation_usage)]
#[holder(generate_deserialize)]
pub struct ItemIdentifiedRepresentationUsage {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub definition: RepresentedDefinition,
    #[holder(use_place_holder)]
    pub used_representation: RepresentationAny,
    #[holder(use_place_holder)]
    pub identified_item: RepresentationItemAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ItemIdentifiedRepresentationUsageAny {
    #[holder(use_place_holder)]
    ItemIdentifiedRepresentationUsage(Box<ItemIdentifiedRepresentationUsage>),
    #[holder(use_place_holder)]
    DraughtingModelItemAssociation(Box<DraughtingModelItemAssociation>),
    #[holder(use_place_holder)]
    GeometricItemSpecificUsage(Box<GeometricItemSpecificUsage>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = known_source)]
#[holder(generate_deserialize)]
pub struct KnownSource {
    #[holder(use_place_holder)]
    #[holder(supertype = "external_source")]
    pub source_id: SourceItem,
    #[holder(use_place_holder)]
    #[holder(supertype = "pre_defined_item")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = laid_defined_transformation)]
#[holder(generate_deserialize)]
pub struct LaidDefinedTransformation {
    #[holder(use_place_holder)]
    #[holder(supertype = "item_defined_transformation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "item_defined_transformation")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "item_defined_transformation")]
    pub transform_item_1: RepresentationItemAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "item_defined_transformation")]
    pub transform_item_2: RepresentationItemAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = laminate_table)]
#[holder(generate_deserialize)]
pub struct LaminateTable {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub formation: ProductDefinitionFormationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub frame_of_reference: ProductDefinitionContextAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum LaminateTableAny {
    #[holder(use_place_holder)]
    LaminateTable(Box<LaminateTable>),
    #[holder(use_place_holder)]
    PartLaminateTable(Box<PartLaminateTableAny>),
    #[holder(use_place_holder)]
    ZoneStructuralMakeup(Box<ZoneStructuralMakeupAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = language)]
#[holder(generate_deserialize)]
pub struct Language {
    #[holder(use_place_holder)]
    #[holder(supertype = "group")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "group")]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = leader_curve)]
#[holder(generate_deserialize)]
pub struct LeaderCurve {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "styled_item")]
    pub styles: Vec<PresentationStyleAssignmentAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "styled_item")]
    pub item: RepresentationItemAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = leader_directed_callout)]
#[holder(generate_deserialize)]
pub struct LeaderDirectedCallout {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "draughting_callout")]
    pub contents: Vec<DraughtingCalloutElement>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum LeaderDirectedCalloutAny {
    #[holder(use_place_holder)]
    LeaderDirectedCallout(Box<LeaderDirectedCallout>),
    #[holder(use_place_holder)]
    LeaderDirectedDimension(Box<LeaderDirectedDimension>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = leader_directed_dimension)]
#[holder(generate_deserialize)]
pub struct LeaderDirectedDimension {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "draughting_callout")]
    pub contents: Vec<DraughtingCalloutElement>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = leader_terminator)]
#[holder(generate_deserialize)]
pub struct LeaderTerminator {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "styled_item")]
    pub styles: Vec<PresentationStyleAssignmentAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "styled_item")]
    pub item: RepresentationItemAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "terminator_symbol")]
    pub annotated_curve: AnnotationCurveOccurrenceAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = length_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct LengthMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = length_unit)]
#[holder(generate_deserialize)]
pub struct LengthUnit {
    #[holder(derived)]
    #[holder(supertype = "named_unit")]
    pub dimensions: Derived<DimensionalExponents>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = light_source)]
#[holder(generate_deserialize)]
pub struct LightSource {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub light_colour: ColourAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum LightSourceAny {
    #[holder(use_place_holder)]
    LightSource(Box<LightSource>),
    #[holder(use_place_holder)]
    LightSourceAmbient(Box<LightSourceAmbient>),
    #[holder(use_place_holder)]
    LightSourceDirectional(Box<LightSourceDirectional>),
    #[holder(use_place_holder)]
    LightSourcePositional(Box<LightSourcePositional>),
    #[holder(use_place_holder)]
    LightSourceSpot(Box<LightSourceSpot>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = light_source_ambient)]
#[holder(generate_deserialize)]
pub struct LightSourceAmbient {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "light_source")]
    pub light_colour: ColourAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = light_source_directional)]
#[holder(generate_deserialize)]
pub struct LightSourceDirectional {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "light_source")]
    pub light_colour: ColourAny,
    #[holder(use_place_holder)]
    pub orientation: Direction,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = light_source_positional)]
#[holder(generate_deserialize)]
pub struct LightSourcePositional {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "light_source")]
    pub light_colour: ColourAny,
    #[holder(use_place_holder)]
    pub position: CartesianPoint,
    pub constant_attenuation: f64,
    pub distance_attenuation: f64,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = light_source_spot)]
#[holder(generate_deserialize)]
pub struct LightSourceSpot {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "light_source")]
    pub light_colour: ColourAny,
    #[holder(use_place_holder)]
    pub position: CartesianPoint,
    #[holder(use_place_holder)]
    pub orientation: Direction,
    pub concentration_exponent: f64,
    pub constant_attenuation: f64,
    pub distance_attenuation: f64,
    #[holder(use_place_holder)]
    pub spread_angle: PositivePlaneAngleMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = limits_and_fits)]
#[holder(generate_deserialize)]
pub struct LimitsAndFits {
    #[holder(use_place_holder)]
    pub form_variance: Label,
    #[holder(use_place_holder)]
    pub zone_variance: Label,
    #[holder(use_place_holder)]
    pub grade: Label,
    #[holder(use_place_holder)]
    pub source: Text,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = line)]
#[holder(generate_deserialize)]
pub struct Line {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub pnt: CartesianPoint,
    #[holder(use_place_holder)]
    pub dir: Vector,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = line_profile_tolerance)]
#[holder(generate_deserialize)]
pub struct LineProfileTolerance {
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub description: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub magnitude: MeasureWithUnitAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub toleranced_shape_aspect: ShapeAspectAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = linear_dimension)]
#[holder(generate_deserialize)]
pub struct LinearDimension {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "draughting_callout")]
    pub contents: Vec<DraughtingCalloutElement>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = literal_conjunction)]
#[holder(generate_deserialize)]
pub struct LiteralConjunction {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "compound_representation_item")]
    pub item_element: CompoundItemDefinition,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = literal_disjunction)]
#[holder(generate_deserialize)]
pub struct LiteralDisjunction {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "compound_representation_item")]
    pub item_element: CompoundItemDefinition,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = literal_number)]
#[holder(generate_deserialize)]
pub struct LiteralNumber {
    pub the_value: f64,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum LiteralNumberAny {
    #[holder(use_place_holder)]
    LiteralNumber(Box<LiteralNumber>),
    #[holder(use_place_holder)]
    IntLiteral(Box<IntLiteralAny>),
    #[holder(use_place_holder)]
    RealLiteral(Box<RealLiteralAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = local_time)]
#[holder(generate_deserialize)]
pub struct LocalTime {
    #[holder(use_place_holder)]
    pub hour_component: HourInDay,
    #[holder(use_place_holder)]
    pub minute_component: Option<MinuteInHour>,
    #[holder(use_place_holder)]
    pub second_component: Option<SecondInMinute>,
    #[holder(use_place_holder)]
    pub zone: CoordinatedUniversalTimeOffset,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = logical_literal)]
#[holder(generate_deserialize)]
pub struct LogicalLiteral {
    pub lit_value: Logical,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum LogicalLiteralAny {
    #[holder(use_place_holder)]
    LogicalLiteral(Box<LogicalLiteral>),
    #[holder(use_place_holder)]
    LogicalRepresentationItem(Box<LogicalRepresentationItem>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = logical_representation_item)]
#[holder(generate_deserialize)]
pub struct LogicalRepresentationItem {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(supertype = "logical_literal")]
    pub lit_value: Logical,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = r#loop)]
#[holder(generate_deserialize)]
pub struct Loop {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum LoopAny {
    #[holder(use_place_holder)]
    Loop(Box<Loop>),
    #[holder(use_place_holder)]
    EdgeLoop(Box<EdgeLoop>),
    #[holder(use_place_holder)]
    PolyLoop(Box<PolyLoop>),
    #[holder(use_place_holder)]
    VertexLoop(Box<VertexLoop>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = loss_tangent_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct LossTangentMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = lot_effectivity)]
#[holder(generate_deserialize)]
pub struct LotEffectivity {
    #[holder(use_place_holder)]
    #[holder(supertype = "effectivity")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    pub effectivity_lot_id: Identifier,
    #[holder(use_place_holder)]
    pub effectivity_lot_size: MeasureWithUnitAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = luminous_flux_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct LuminousFluxMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = luminous_flux_unit)]
#[holder(generate_deserialize)]
pub struct LuminousFluxUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "named_unit")]
    pub dimensions: DimensionalExponents,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = luminous_intensity_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct LuminousIntensityMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = luminous_intensity_unit)]
#[holder(generate_deserialize)]
pub struct LuminousIntensityUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "named_unit")]
    pub dimensions: DimensionalExponents,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = magnetic_flux_density_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct MagneticFluxDensityMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = magnetic_flux_density_unit)]
#[holder(generate_deserialize)]
pub struct MagneticFluxDensityUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum MagneticFluxDensityUnitAny {
    #[holder(use_place_holder)]
    MagneticFluxDensityUnit(Box<MagneticFluxDensityUnit>),
    #[holder(use_place_holder)]
    SiMagneticFluxDensityUnit(Box<SiMagneticFluxDensityUnit>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = magnetic_flux_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct MagneticFluxMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = magnetic_flux_unit)]
#[holder(generate_deserialize)]
pub struct MagneticFluxUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum MagneticFluxUnitAny {
    #[holder(use_place_holder)]
    MagneticFluxUnit(Box<MagneticFluxUnit>),
    #[holder(use_place_holder)]
    SiMagneticFluxUnit(Box<SiMagneticFluxUnit>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = make_from_usage_option)]
#[holder(generate_deserialize)]
pub struct MakeFromUsageOption {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub relating_product_definition: ProductDefinitionAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub related_product_definition: ProductDefinitionAny,
    pub ranking: i64,
    #[holder(use_place_holder)]
    pub ranking_rationale: Text,
    #[holder(use_place_holder)]
    pub quantity: MeasureWithUnitAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = manifold_solid_brep)]
#[holder(generate_deserialize)]
pub struct ManifoldSolidBrep {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub outer: ClosedShellAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ManifoldSolidBrepAny {
    #[holder(use_place_holder)]
    ManifoldSolidBrep(Box<ManifoldSolidBrep>),
    #[holder(use_place_holder)]
    BrepWithVoids(Box<BrepWithVoids>),
    #[holder(use_place_holder)]
    FacetedBrep(Box<FacetedBrep>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = manifold_subsurface_shape_representation)]
#[holder(generate_deserialize)]
pub struct ManifoldSubsurfaceShapeRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = manifold_surface_shape_representation)]
#[holder(generate_deserialize)]
pub struct ManifoldSurfaceShapeRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = mapped_item)]
#[holder(generate_deserialize)]
pub struct MappedItem {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub mapping_source: RepresentationMapAny,
    #[holder(use_place_holder)]
    pub mapping_target: RepresentationItemAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum MappedItemAny {
    #[holder(use_place_holder)]
    MappedItem(Box<MappedItem>),
    #[holder(use_place_holder)]
    AnnotationSymbol(Box<AnnotationSymbol>),
    #[holder(use_place_holder)]
    AnnotationText(Box<AnnotationText>),
    #[holder(use_place_holder)]
    AnnotationTextCharacter(Box<AnnotationTextCharacter>),
    #[holder(use_place_holder)]
    CameraImage(Box<CameraImageAny>),
    #[holder(use_place_holder)]
    DimensionTextAssociativity(Box<DimensionTextAssociativity>),
    #[holder(use_place_holder)]
    IncludedTextBlock(Box<IncludedTextBlock>),
    #[holder(use_place_holder)]
    UserDefinedCurveFont(Box<UserDefinedCurveFont>),
    #[holder(use_place_holder)]
    UserDefinedMarker(Box<UserDefinedMarker>),
    #[holder(use_place_holder)]
    UserDefinedTerminatorSymbol(Box<UserDefinedTerminatorSymbol>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = mass_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct MassMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = mass_unit)]
#[holder(generate_deserialize)]
pub struct MassUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "named_unit")]
    pub dimensions: DimensionalExponents,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = material_designation)]
#[holder(generate_deserialize)]
pub struct MaterialDesignation {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub definitions: Vec<CharacterizedDefinition>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum MaterialDesignationAny {
    #[holder(use_place_holder)]
    MaterialDesignation(Box<MaterialDesignation>),
    #[holder(use_place_holder)]
    CompositeMaterialDesignation(Box<CompositeMaterialDesignation>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = material_designation_characterization)]
#[holder(generate_deserialize)]
pub struct MaterialDesignationCharacterization {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Text,
    #[holder(use_place_holder)]
    pub designation: MaterialDesignationAny,
    #[holder(use_place_holder)]
    pub property: CharacterizedMaterialProperty,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = material_property)]
#[holder(generate_deserialize)]
pub struct MaterialProperty {
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition")]
    pub definition: CharacterizedDefinition,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = material_property_representation)]
#[holder(generate_deserialize)]
pub struct MaterialPropertyRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition_representation")]
    pub definition: RepresentedDefinition,
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition_representation")]
    pub used_representation: RepresentationAny,
    #[holder(use_place_holder)]
    pub dependent_environment: DataEnvironment,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = measure_qualification)]
#[holder(generate_deserialize)]
pub struct MeasureQualification {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Text,
    #[holder(use_place_holder)]
    pub qualified_measure: MeasureWithUnitAny,
    #[holder(use_place_holder)]
    pub qualifiers: Vec<ValueQualifier>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = measure_representation_item)]
#[holder(generate_deserialize)]
pub struct MeasureRepresentationItem {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = measure_with_unit)]
#[holder(generate_deserialize)]
pub struct MeasureWithUnit {
    #[holder(use_place_holder)]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum MeasureWithUnitAny {
    #[holder(use_place_holder)]
    MeasureWithUnit(Box<MeasureWithUnit>),
    #[holder(use_place_holder)]
    AbsorbedDoseMeasureWithUnit(Box<AbsorbedDoseMeasureWithUnit>),
    #[holder(use_place_holder)]
    AccelerationMeasureWithUnit(Box<AccelerationMeasureWithUnit>),
    #[holder(use_place_holder)]
    AmountOfSubstanceMeasureWithUnit(Box<AmountOfSubstanceMeasureWithUnit>),
    #[holder(use_place_holder)]
    AreaMeasureWithUnit(Box<AreaMeasureWithUnit>),
    #[holder(use_place_holder)]
    CapacitanceMeasureWithUnit(Box<CapacitanceMeasureWithUnit>),
    #[holder(use_place_holder)]
    CelsiusTemperatureMeasureWithUnit(Box<CelsiusTemperatureMeasureWithUnit>),
    #[holder(use_place_holder)]
    ConductanceMeasureWithUnit(Box<ConductanceMeasureWithUnit>),
    #[holder(use_place_holder)]
    CurrencyMeasureWithUnit(Box<CurrencyMeasureWithUnit>),
    #[holder(use_place_holder)]
    DoseEquivalentMeasureWithUnit(Box<DoseEquivalentMeasureWithUnit>),
    #[holder(use_place_holder)]
    ElectricChargeMeasureWithUnit(Box<ElectricChargeMeasureWithUnit>),
    #[holder(use_place_holder)]
    ElectricCurrentMeasureWithUnit(Box<ElectricCurrentMeasureWithUnit>),
    #[holder(use_place_holder)]
    ElectricPotentialMeasureWithUnit(Box<ElectricPotentialMeasureWithUnit>),
    #[holder(use_place_holder)]
    EnergyMeasureWithUnit(Box<EnergyMeasureWithUnit>),
    #[holder(use_place_holder)]
    ForceMeasureWithUnit(Box<ForceMeasureWithUnit>),
    #[holder(use_place_holder)]
    FrequencyMeasureWithUnit(Box<FrequencyMeasureWithUnit>),
    #[holder(use_place_holder)]
    IlluminanceMeasureWithUnit(Box<IlluminanceMeasureWithUnit>),
    #[holder(use_place_holder)]
    InductanceMeasureWithUnit(Box<InductanceMeasureWithUnit>),
    #[holder(use_place_holder)]
    LengthMeasureWithUnit(Box<LengthMeasureWithUnit>),
    #[holder(use_place_holder)]
    LuminousFluxMeasureWithUnit(Box<LuminousFluxMeasureWithUnit>),
    #[holder(use_place_holder)]
    LuminousIntensityMeasureWithUnit(Box<LuminousIntensityMeasureWithUnit>),
    #[holder(use_place_holder)]
    MagneticFluxDensityMeasureWithUnit(Box<MagneticFluxDensityMeasureWithUnit>),
    #[holder(use_place_holder)]
    MagneticFluxMeasureWithUnit(Box<MagneticFluxMeasureWithUnit>),
    #[holder(use_place_holder)]
    MassMeasureWithUnit(Box<MassMeasureWithUnit>),
    #[holder(use_place_holder)]
    MeasureRepresentationItem(Box<MeasureRepresentationItem>),
    #[holder(use_place_holder)]
    PlaneAngleMeasureWithUnit(Box<PlaneAngleMeasureWithUnit>),
    #[holder(use_place_holder)]
    PowerMeasureWithUnit(Box<PowerMeasureWithUnit>),
    #[holder(use_place_holder)]
    PressureMeasureWithUnit(Box<PressureMeasureWithUnit>),
    #[holder(use_place_holder)]
    RadioactivityMeasureWithUnit(Box<RadioactivityMeasureWithUnit>),
    #[holder(use_place_holder)]
    RatioMeasureWithUnit(Box<RatioMeasureWithUnitAny>),
    #[holder(use_place_holder)]
    ResistanceMeasureWithUnit(Box<ResistanceMeasureWithUnit>),
    #[holder(use_place_holder)]
    SolidAngleMeasureWithUnit(Box<SolidAngleMeasureWithUnit>),
    #[holder(use_place_holder)]
    ThermalResistanceMeasureWithUnit(Box<ThermalResistanceMeasureWithUnit>),
    #[holder(use_place_holder)]
    ThermodynamicTemperatureMeasureWithUnit(Box<ThermodynamicTemperatureMeasureWithUnit>),
    #[holder(use_place_holder)]
    TimeMeasureWithUnit(Box<TimeMeasureWithUnit>),
    #[holder(use_place_holder)]
    UncertaintyMeasureWithUnit(Box<UncertaintyMeasureWithUnit>),
    #[holder(use_place_holder)]
    VelocityMeasureWithUnit(Box<VelocityMeasureWithUnit>),
    #[holder(use_place_holder)]
    VolumeMeasureWithUnit(Box<VolumeMeasureWithUnit>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = mechanical_context)]
#[holder(generate_deserialize)]
pub struct MechanicalContext {
    #[holder(use_place_holder)]
    #[holder(supertype = "application_context_element")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "application_context_element")]
    pub frame_of_reference: ApplicationContext,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_context")]
    pub discipline_type: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = mechanical_design_and_draughting_relationship)]
#[holder(generate_deserialize)]
pub struct MechanicalDesignAndDraughtingRelationship {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub rep_1: RepresentationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub rep_2: RepresentationAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = mechanical_design_geometric_presentation_area)]
#[holder(generate_deserialize)]
pub struct MechanicalDesignGeometricPresentationArea {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = mechanical_design_geometric_presentation_representation)]
#[holder(generate_deserialize)]
pub struct MechanicalDesignGeometricPresentationRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = mechanical_design_presentation_representation_with_draughting)]
#[holder(generate_deserialize)]
pub struct MechanicalDesignPresentationRepresentationWithDraughting {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = mechanical_design_shaded_presentation_area)]
#[holder(generate_deserialize)]
pub struct MechanicalDesignShadedPresentationArea {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = mechanical_design_shaded_presentation_representation)]
#[holder(generate_deserialize)]
pub struct MechanicalDesignShadedPresentationRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = min_and_major_ply_orientation_basis)]
#[holder(generate_deserialize)]
pub struct MinAndMajorPlyOrientationBasis {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item_relationship")]
    pub relating_representation_item: RepresentationItemAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item_relationship")]
    pub related_representation_item: RepresentationItemAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = modified_geometric_tolerance)]
#[holder(generate_deserialize)]
pub struct ModifiedGeometricTolerance {
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub description: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub magnitude: MeasureWithUnitAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub toleranced_shape_aspect: ShapeAspectAny,
    pub modifier: LimitCondition,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = modified_solid)]
#[holder(generate_deserialize)]
pub struct ModifiedSolid {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub rationale: Text,
    #[holder(use_place_holder)]
    pub base_solid: BaseSolidSelect,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ModifiedSolidAny {
    #[holder(use_place_holder)]
    ModifiedSolid(Box<ModifiedSolid>),
    #[holder(use_place_holder)]
    EdgeBlendedSolid(Box<EdgeBlendedSolidAny>),
    #[holder(use_place_holder)]
    ModifiedSolidWithPlacedConfiguration(Box<ModifiedSolidWithPlacedConfigurationAny>),
    #[holder(use_place_holder)]
    SculpturedSolid(Box<SculpturedSolid>),
    #[holder(use_place_holder)]
    ShelledSolid(Box<ShelledSolidAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = modified_solid_with_placed_configuration)]
#[holder(generate_deserialize)]
pub struct ModifiedSolidWithPlacedConfiguration {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    pub placing: Axis2Placement3D,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ModifiedSolidWithPlacedConfigurationAny {
    #[holder(use_place_holder)]
    ModifiedSolidWithPlacedConfiguration(Box<ModifiedSolidWithPlacedConfiguration>),
    #[holder(use_place_holder)]
    SolidWithDepression(Box<SolidWithDepressionAny>),
    #[holder(use_place_holder)]
    SolidWithProtrusion(Box<SolidWithProtrusionAny>),
    #[holder(use_place_holder)]
    SolidWithShapeElementPattern(Box<SolidWithShapeElementPatternAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = moments_of_inertia_representation)]
#[holder(generate_deserialize)]
pub struct MomentsOfInertiaRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = multi_language_attribute_assignment)]
#[holder(generate_deserialize)]
pub struct MultiLanguageAttributeAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "attribute_value_assignment")]
    pub attribute_name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "attribute_value_assignment")]
    pub attribute_value: AttributeType,
    #[holder(use_place_holder)]
    #[holder(supertype = "attribute_value_assignment")]
    pub role: AttributeValueRole,
    #[holder(use_place_holder)]
    pub items: Vec<MultiLanguageAttributeItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = multiple_arity_boolean_expression)]
#[holder(generate_deserialize)]
pub struct MultipleArityBooleanExpression {
    #[holder(use_place_holder)]
    #[holder(supertype = "multiple_arity_generic_expression")]
    pub operands: Vec<GenericExpressionAny>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = multiple_arity_generic_expression)]
#[holder(generate_deserialize)]
pub struct MultipleArityGenericExpression {
    #[holder(use_place_holder)]
    pub operands: Vec<GenericExpressionAny>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum MultipleArityGenericExpressionAny {
    #[holder(use_place_holder)]
    MultipleArityGenericExpression(Box<MultipleArityGenericExpression>),
    #[holder(use_place_holder)]
    IntervalExpression(Box<IntervalExpression>),
    #[holder(use_place_holder)]
    MultipleArityBooleanExpression(Box<MultipleArityBooleanExpression>),
    #[holder(use_place_holder)]
    MultipleArityNumericExpression(Box<MultipleArityNumericExpression>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = multiple_arity_numeric_expression)]
#[holder(generate_deserialize)]
pub struct MultipleArityNumericExpression {
    #[holder(use_place_holder)]
    #[holder(supertype = "multiple_arity_generic_expression")]
    pub operands: Vec<GenericExpressionAny>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = name_assignment)]
#[holder(generate_deserialize)]
pub struct NameAssignment {
    #[holder(use_place_holder)]
    pub assigned_name: Label,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum NameAssignmentAny {
    #[holder(use_place_holder)]
    NameAssignment(Box<NameAssignment>),
    #[holder(use_place_holder)]
    AppliedNameAssignment(Box<AppliedNameAssignment>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = name_attribute)]
#[holder(generate_deserialize)]
pub struct NameAttribute {
    #[holder(use_place_holder)]
    pub attribute_value: Label,
    #[holder(use_place_holder)]
    pub named_item: NameAttributeSelect,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = named_unit)]
#[holder(generate_deserialize)]
pub struct NamedUnit {
    #[holder(derived)]
    pub dimensions: Derived<DimensionalExponents>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum NamedUnitAny {
    #[holder(use_place_holder)]
    NamedUnit(Box<NamedUnit>),
    #[holder(use_place_holder)]
    AmountOfSubstanceUnit(Box<AmountOfSubstanceUnit>),
    #[holder(use_place_holder)]
    ContextDependentUnit(Box<ContextDependentUnitAny>),
    #[holder(use_place_holder)]
    ConversionBasedUnit(Box<ConversionBasedUnitAny>),
    #[holder(use_place_holder)]
    ElectricCurrentUnit(Box<ElectricCurrentUnit>),
    #[holder(use_place_holder)]
    LengthUnit(Box<LengthUnit>),
    #[holder(use_place_holder)]
    LuminousFluxUnit(Box<LuminousFluxUnit>),
    #[holder(use_place_holder)]
    LuminousIntensityUnit(Box<LuminousIntensityUnit>),
    #[holder(use_place_holder)]
    MassUnit(Box<MassUnit>),
    #[holder(use_place_holder)]
    PlaneAngleUnit(Box<PlaneAngleUnit>),
    #[holder(use_place_holder)]
    RatioUnit(Box<RatioUnit>),
    #[holder(use_place_holder)]
    SiUnit(Box<SiUnitAny>),
    #[holder(use_place_holder)]
    SolidAngleUnit(Box<SolidAngleUnit>),
    #[holder(use_place_holder)]
    ThermodynamicTemperatureUnit(Box<ThermodynamicTemperatureUnit>),
    #[holder(use_place_holder)]
    TimeUnit(Box<TimeUnit>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = next_assembly_usage_occurrence)]
#[holder(generate_deserialize)]
pub struct NextAssemblyUsageOccurrence {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub relating_product_definition: ProductDefinitionAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub related_product_definition: ProductDefinitionAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "assembly_component_usage")]
    pub reference_designator: Option<Identifier>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = non_manifold_surface_shape_representation)]
#[holder(generate_deserialize)]
pub struct NonManifoldSurfaceShapeRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = null_representation_item)]
#[holder(generate_deserialize)]
pub struct NullRepresentationItem {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = numeric_expression)]
#[holder(generate_deserialize)]
pub struct NumericExpression {}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum NumericExpressionAny {
    #[holder(use_place_holder)]
    NumericExpression(Box<NumericExpression>),
    #[holder(use_place_holder)]
    BinaryNumericExpression(Box<BinaryNumericExpressionAny>),
    #[holder(use_place_holder)]
    MultipleArityNumericExpression(Box<MultipleArityNumericExpression>),
    #[holder(use_place_holder)]
    SimpleNumericExpression(Box<SimpleNumericExpressionAny>),
    #[holder(use_place_holder)]
    UnaryNumericExpression(Box<UnaryNumericExpression>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = object_role)]
#[holder(generate_deserialize)]
pub struct ObjectRole {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = offset_curve_2d)]
#[holder(generate_deserialize)]
pub struct OffsetCurve2D {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub basis_curve: CurveAny,
    #[holder(use_place_holder)]
    pub distance: LengthMeasure,
    pub self_intersect: Logical,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = offset_curve_3d)]
#[holder(generate_deserialize)]
pub struct OffsetCurve3D {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub basis_curve: CurveAny,
    #[holder(use_place_holder)]
    pub distance: LengthMeasure,
    pub self_intersect: Logical,
    #[holder(use_place_holder)]
    pub ref_direction: Direction,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = offset_surface)]
#[holder(generate_deserialize)]
pub struct OffsetSurface {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub basis_surface: SurfaceAny,
    #[holder(use_place_holder)]
    pub distance: LengthMeasure,
    pub self_intersect: Logical,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = one_direction_repeat_factor)]
#[holder(generate_deserialize)]
pub struct OneDirectionRepeatFactor {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub repeat_factor: Vector,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum OneDirectionRepeatFactorAny {
    #[holder(use_place_holder)]
    OneDirectionRepeatFactor(Box<OneDirectionRepeatFactor>),
    #[holder(use_place_holder)]
    TwoDirectionRepeatFactor(Box<TwoDirectionRepeatFactor>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = open_shell)]
#[holder(generate_deserialize)]
pub struct OpenShell {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "connected_face_set")]
    pub cfs_faces: Vec<FaceAny>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum OpenShellAny {
    #[holder(use_place_holder)]
    OpenShell(Box<OpenShell>),
    #[holder(use_place_holder)]
    OrientedOpenShell(Box<OrientedOpenShell>),
    #[holder(use_place_holder)]
    SurfacedOpenShell(Box<SurfacedOpenShell>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = ordinal_date)]
#[holder(generate_deserialize)]
pub struct OrdinalDate {
    #[holder(use_place_holder)]
    #[holder(supertype = "date")]
    pub year_component: YearNumber,
    #[holder(use_place_holder)]
    pub day_component: DayInYearNumber,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = ordinate_dimension)]
#[holder(generate_deserialize)]
pub struct OrdinateDimension {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "draughting_callout")]
    pub contents: Vec<DraughtingCalloutElement>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = organization)]
#[holder(generate_deserialize)]
pub struct Organization {
    #[holder(use_place_holder)]
    pub id: Option<Identifier>,
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = organization_assignment)]
#[holder(generate_deserialize)]
pub struct OrganizationAssignment {
    #[holder(use_place_holder)]
    pub assigned_organization: Organization,
    #[holder(use_place_holder)]
    pub role: OrganizationRole,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum OrganizationAssignmentAny {
    #[holder(use_place_holder)]
    OrganizationAssignment(Box<OrganizationAssignment>),
    #[holder(use_place_holder)]
    AppliedOrganizationAssignment(Box<AppliedOrganizationAssignment>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = organization_relationship)]
#[holder(generate_deserialize)]
pub struct OrganizationRelationship {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub relating_organization: Organization,
    #[holder(use_place_holder)]
    pub related_organization: Organization,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = organization_role)]
#[holder(generate_deserialize)]
pub struct OrganizationRole {
    #[holder(use_place_holder)]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = organizational_address)]
#[holder(generate_deserialize)]
pub struct OrganizationalAddress {
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub internal_location: Option<Label>,
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub street_number: Option<Label>,
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub street: Option<Label>,
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub postal_box: Option<Label>,
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub town: Option<Label>,
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub region: Option<Label>,
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub postal_code: Option<Label>,
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub country: Option<Label>,
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub facsimile_number: Option<Label>,
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub telephone_number: Option<Label>,
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub electronic_mail_address: Option<Label>,
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub telex_number: Option<Label>,
    #[holder(use_place_holder)]
    pub organizations: Vec<Organization>,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum OrganizationalAddressAny {
    #[holder(use_place_holder)]
    OrganizationalAddress(Box<OrganizationalAddress>),
    #[holder(use_place_holder)]
    PersonAndOrganizationAddress(Box<PersonAndOrganizationAddress>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = organizational_project)]
#[holder(generate_deserialize)]
pub struct OrganizationalProject {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub responsible_organizations: Vec<Organization>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = organizational_project_assignment)]
#[holder(generate_deserialize)]
pub struct OrganizationalProjectAssignment {
    #[holder(use_place_holder)]
    pub assigned_organizational_project: OrganizationalProject,
    #[holder(use_place_holder)]
    pub role: OrganizationalProjectRole,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum OrganizationalProjectAssignmentAny {
    #[holder(use_place_holder)]
    OrganizationalProjectAssignment(Box<OrganizationalProjectAssignment>),
    #[holder(use_place_holder)]
    AppliedOrganizationalProjectAssignment(Box<AppliedOrganizationalProjectAssignment>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = organizational_project_relationship)]
#[holder(generate_deserialize)]
pub struct OrganizationalProjectRelationship {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub relating_organizational_project: OrganizationalProject,
    #[holder(use_place_holder)]
    pub related_organizational_project: OrganizationalProject,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = organizational_project_role)]
#[holder(generate_deserialize)]
pub struct OrganizationalProjectRole {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = oriented_closed_shell)]
#[holder(generate_deserialize)]
pub struct OrientedClosedShell {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(derived)]
    #[holder(supertype = "connected_face_set")]
    pub cfs_faces: Derived<Vec<FaceAny>>,
    #[holder(use_place_holder)]
    pub closed_shell_element: ClosedShellAny,
    pub orientation: bool,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = oriented_edge)]
#[holder(generate_deserialize)]
pub struct OrientedEdge {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(derived)]
    #[holder(supertype = "edge")]
    pub edge_start: Derived<VertexAny>,
    #[holder(derived)]
    #[holder(supertype = "edge")]
    pub edge_end: Derived<VertexAny>,
    #[holder(use_place_holder)]
    pub edge_element: EdgeAny,
    pub orientation: bool,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = oriented_face)]
#[holder(generate_deserialize)]
pub struct OrientedFace {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(derived)]
    #[holder(supertype = "face")]
    pub bounds: Derived<Vec<FaceBoundAny>>,
    #[holder(use_place_holder)]
    pub face_element: FaceAny,
    pub orientation: bool,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = oriented_open_shell)]
#[holder(generate_deserialize)]
pub struct OrientedOpenShell {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(derived)]
    #[holder(supertype = "connected_face_set")]
    pub cfs_faces: Derived<Vec<FaceAny>>,
    #[holder(use_place_holder)]
    pub open_shell_element: OpenShellAny,
    pub orientation: bool,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = oriented_path)]
#[holder(generate_deserialize)]
pub struct OrientedPath {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(derived)]
    #[holder(supertype = "path")]
    pub edge_list: Derived<Vec<OrientedEdge>>,
    #[holder(use_place_holder)]
    pub path_element: PathAny,
    pub orientation: bool,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = oriented_surface)]
#[holder(generate_deserialize)]
pub struct OrientedSurface {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    pub orientation: bool,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = outer_boundary_curve)]
#[holder(generate_deserialize)]
pub struct OuterBoundaryCurve {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "composite_curve")]
    pub segments: Vec<CompositeCurveSegmentAny>,
    #[holder(supertype = "composite_curve")]
    pub self_intersect: Logical,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = over_riding_styled_item)]
#[holder(generate_deserialize)]
pub struct OverRidingStyledItem {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "styled_item")]
    pub styles: Vec<PresentationStyleAssignmentAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "styled_item")]
    pub item: RepresentationItemAny,
    #[holder(use_place_holder)]
    pub over_ridden_style: StyledItemAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum OverRidingStyledItemAny {
    #[holder(use_place_holder)]
    OverRidingStyledItem(Box<OverRidingStyledItem>),
    #[holder(use_place_holder)]
    ContextDependentOverRidingStyledItem(Box<ContextDependentOverRidingStyledItemAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = package_product_concept_feature)]
#[holder(generate_deserialize)]
pub struct PackageProductConceptFeature {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_concept_feature")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_concept_feature")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_concept_feature")]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = parabola)]
#[holder(generate_deserialize)]
pub struct Parabola {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "conic")]
    pub position: Axis2Placement,
    #[holder(use_place_holder)]
    pub focal_dist: LengthMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = parallel_offset)]
#[holder(generate_deserialize)]
pub struct ParallelOffset {
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub of_shape: ProductDefinitionShape,
    #[holder(supertype = "shape_aspect")]
    pub product_definitional: Logical,
    #[holder(use_place_holder)]
    pub offset: MeasureWithUnitAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = parallelism_tolerance)]
#[holder(generate_deserialize)]
pub struct ParallelismTolerance {
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub description: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub magnitude: MeasureWithUnitAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub toleranced_shape_aspect: ShapeAspectAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance_with_datum_reference")]
    pub datum_system: Vec<DatumReferenceAny>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = parametric_representation_context)]
#[holder(generate_deserialize)]
pub struct ParametricRepresentationContext {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_context")]
    pub context_identifier: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_context")]
    pub context_type: Text,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = part_laminate_table)]
#[holder(generate_deserialize)]
pub struct PartLaminateTable {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub formation: ProductDefinitionFormationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub frame_of_reference: ProductDefinitionContextAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PartLaminateTableAny {
    #[holder(use_place_holder)]
    PartLaminateTable(Box<PartLaminateTable>),
    #[holder(use_place_holder)]
    CompositeAssemblyTable(Box<CompositeAssemblyTable>),
    #[holder(use_place_holder)]
    PlyLaminateTable(Box<PlyLaminateTable>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = partial_document_with_structured_text_representation_assignment)]
#[holder(generate_deserialize)]
pub struct PartialDocumentWithStructuredTextRepresentationAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "document_usage_constraint_assignment")]
    pub assigned_document_usage: DocumentUsageConstraint,
    #[holder(use_place_holder)]
    #[holder(supertype = "document_usage_constraint_assignment")]
    pub role: DocumentUsageRole,
    #[holder(use_place_holder)]
    #[holder(supertype = "applied_document_usage_constraint_assignment")]
    pub items: Vec<DocumentReferenceItem>,
    #[holder(use_place_holder)]
    #[holder(supertype = "characterized_object")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "characterized_object")]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = path)]
#[holder(generate_deserialize)]
pub struct Path {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub edge_list: Vec<OrientedEdge>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PathAny {
    #[holder(use_place_holder)]
    Path(Box<Path>),
    #[holder(use_place_holder)]
    EdgeLoop(Box<EdgeLoop>),
    #[holder(use_place_holder)]
    OrientedPath(Box<OrientedPath>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = pcurve)]
#[holder(generate_deserialize)]
pub struct Pcurve {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub basis_surface: SurfaceAny,
    #[holder(use_place_holder)]
    pub reference_to_curve: DefinitionalRepresentation,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PcurveAny {
    #[holder(use_place_holder)]
    Pcurve(Box<Pcurve>),
    #[holder(use_place_holder)]
    BoundedPcurve(Box<BoundedPcurve>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = percentage_laminate_definition)]
#[holder(generate_deserialize)]
pub struct PercentageLaminateDefinition {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub formation: ProductDefinitionFormationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub frame_of_reference: ProductDefinitionContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = percentage_laminate_table)]
#[holder(generate_deserialize)]
pub struct PercentageLaminateTable {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub formation: ProductDefinitionFormationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub frame_of_reference: ProductDefinitionContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = percentage_ply_definition)]
#[holder(generate_deserialize)]
pub struct PercentagePlyDefinition {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub formation: ProductDefinitionFormationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub frame_of_reference: ProductDefinitionContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = perpendicular_to)]
#[holder(generate_deserialize)]
pub struct PerpendicularTo {
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub of_shape: ProductDefinitionShape,
    #[holder(supertype = "shape_aspect")]
    pub product_definitional: Logical,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = perpendicularity_tolerance)]
#[holder(generate_deserialize)]
pub struct PerpendicularityTolerance {
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub description: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub magnitude: MeasureWithUnitAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub toleranced_shape_aspect: ShapeAspectAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance_with_datum_reference")]
    pub datum_system: Vec<DatumReferenceAny>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = person)]
#[holder(generate_deserialize)]
pub struct Person {
    #[holder(use_place_holder)]
    pub id: Identifier,
    #[holder(use_place_holder)]
    pub last_name: Option<Label>,
    #[holder(use_place_holder)]
    pub first_name: Option<Label>,
    #[holder(use_place_holder)]
    pub middle_names: Option<Vec<Label>>,
    #[holder(use_place_holder)]
    pub prefix_titles: Option<Vec<Label>>,
    #[holder(use_place_holder)]
    pub suffix_titles: Option<Vec<Label>>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = person_and_organization)]
#[holder(generate_deserialize)]
pub struct PersonAndOrganization {
    #[holder(use_place_holder)]
    pub the_person: Person,
    #[holder(use_place_holder)]
    pub the_organization: Organization,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = person_and_organization_address)]
#[holder(generate_deserialize)]
pub struct PersonAndOrganizationAddress {
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub internal_location: Option<Label>,
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub street_number: Option<Label>,
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub street: Option<Label>,
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub postal_box: Option<Label>,
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub town: Option<Label>,
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub region: Option<Label>,
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub postal_code: Option<Label>,
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub country: Option<Label>,
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub facsimile_number: Option<Label>,
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub telephone_number: Option<Label>,
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub electronic_mail_address: Option<Label>,
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub telex_number: Option<Label>,
    #[holder(use_place_holder)]
    #[holder(supertype = "organizational_address")]
    pub organizations: Vec<Organization>,
    #[holder(use_place_holder)]
    #[holder(supertype = "organizational_address")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "personal_address")]
    pub people: Vec<Person>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = person_and_organization_assignment)]
#[holder(generate_deserialize)]
pub struct PersonAndOrganizationAssignment {
    #[holder(use_place_holder)]
    pub assigned_person_and_organization: PersonAndOrganization,
    #[holder(use_place_holder)]
    pub role: PersonAndOrganizationRole,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PersonAndOrganizationAssignmentAny {
    #[holder(use_place_holder)]
    PersonAndOrganizationAssignment(Box<PersonAndOrganizationAssignment>),
    #[holder(use_place_holder)]
    AppliedPersonAndOrganizationAssignment(Box<AppliedPersonAndOrganizationAssignment>),
    #[holder(use_place_holder)]
    CcDesignPersonAndOrganizationAssignment(Box<CcDesignPersonAndOrganizationAssignment>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = person_and_organization_role)]
#[holder(generate_deserialize)]
pub struct PersonAndOrganizationRole {
    #[holder(use_place_holder)]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = personal_address)]
#[holder(generate_deserialize)]
pub struct PersonalAddress {
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub internal_location: Option<Label>,
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub street_number: Option<Label>,
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub street: Option<Label>,
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub postal_box: Option<Label>,
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub town: Option<Label>,
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub region: Option<Label>,
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub postal_code: Option<Label>,
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub country: Option<Label>,
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub facsimile_number: Option<Label>,
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub telephone_number: Option<Label>,
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub electronic_mail_address: Option<Label>,
    #[holder(use_place_holder)]
    #[holder(supertype = "address")]
    pub telex_number: Option<Label>,
    #[holder(use_place_holder)]
    pub people: Vec<Person>,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PersonalAddressAny {
    #[holder(use_place_holder)]
    PersonalAddress(Box<PersonalAddress>),
    #[holder(use_place_holder)]
    PersonAndOrganizationAddress(Box<PersonAndOrganizationAddress>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = physical_breakdown_context)]
#[holder(generate_deserialize)]
pub struct PhysicalBreakdownContext {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub relating_product_definition: ProductDefinitionAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub related_product_definition: ProductDefinitionAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = physical_element_usage)]
#[holder(generate_deserialize)]
pub struct PhysicalElementUsage {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub relating_product_definition: ProductDefinitionAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub related_product_definition: ProductDefinitionAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = picture_representation)]
#[holder(generate_deserialize)]
pub struct PictureRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = picture_representation_item)]
#[holder(generate_deserialize)]
pub struct PictureRepresentationItem {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(supertype = "binary_representation_item")]
    pub binary_value: Binary,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PictureRepresentationItemAny {
    #[holder(use_place_holder)]
    PictureRepresentationItem(Box<PictureRepresentationItem>),
    #[holder(use_place_holder)]
    ExternallyDefinedPictureRepresentationItem(Box<ExternallyDefinedPictureRepresentationItem>),
    #[holder(use_place_holder)]
    PredefinedPictureRepresentationItem(Box<PredefinedPictureRepresentationItem>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = placed_datum_target_feature)]
#[holder(generate_deserialize)]
pub struct PlacedDatumTargetFeature {
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub of_shape: ProductDefinitionShape,
    #[holder(supertype = "shape_aspect")]
    pub product_definitional: Logical,
    #[holder(use_place_holder)]
    #[holder(supertype = "datum_target")]
    pub target_id: Identifier,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = placed_feature)]
#[holder(generate_deserialize)]
pub struct PlacedFeature {
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub of_shape: ProductDefinitionShape,
    #[holder(supertype = "shape_aspect")]
    pub product_definitional: Logical,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = placement)]
#[holder(generate_deserialize)]
pub struct Placement {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub location: CartesianPoint,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PlacementAny {
    #[holder(use_place_holder)]
    Placement(Box<Placement>),
    #[holder(use_place_holder)]
    Axis1Placement(Box<Axis1Placement>),
    #[holder(use_place_holder)]
    Axis2Placement2D(Box<Axis2Placement2D>),
    #[holder(use_place_holder)]
    Axis2Placement3D(Box<Axis2Placement3D>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = planar_box)]
#[holder(generate_deserialize)]
pub struct PlanarBox {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "planar_extent")]
    pub size_in_x: LengthMeasure,
    #[holder(use_place_holder)]
    #[holder(supertype = "planar_extent")]
    pub size_in_y: LengthMeasure,
    #[holder(use_place_holder)]
    pub placement: Axis2Placement,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = planar_extent)]
#[holder(generate_deserialize)]
pub struct PlanarExtent {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub size_in_x: LengthMeasure,
    #[holder(use_place_holder)]
    pub size_in_y: LengthMeasure,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PlanarExtentAny {
    #[holder(use_place_holder)]
    PlanarExtent(Box<PlanarExtent>),
    #[holder(use_place_holder)]
    PlanarBox(Box<PlanarBox>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = plane)]
#[holder(generate_deserialize)]
pub struct Plane {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "elementary_surface")]
    pub position: Axis2Placement3D,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = plane_angle_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct PlaneAngleMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = plane_angle_unit)]
#[holder(generate_deserialize)]
pub struct PlaneAngleUnit {
    #[holder(derived)]
    #[holder(supertype = "named_unit")]
    pub dimensions: Derived<DimensionalExponents>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = plus_minus_tolerance)]
#[holder(generate_deserialize)]
pub struct PlusMinusTolerance {
    #[holder(use_place_holder)]
    pub range: ToleranceMethodDefinition,
    #[holder(use_place_holder)]
    pub toleranced_dimension: DimensionalCharacteristic,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = ply_laminate_definition)]
#[holder(generate_deserialize)]
pub struct PlyLaminateDefinition {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub formation: ProductDefinitionFormationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub frame_of_reference: ProductDefinitionContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = ply_laminate_sequence_definition)]
#[holder(generate_deserialize)]
pub struct PlyLaminateSequenceDefinition {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub formation: ProductDefinitionFormationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub frame_of_reference: ProductDefinitionContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = ply_laminate_table)]
#[holder(generate_deserialize)]
pub struct PlyLaminateTable {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub formation: ProductDefinitionFormationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub frame_of_reference: ProductDefinitionContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = point)]
#[holder(generate_deserialize)]
pub struct Point {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PointAny {
    #[holder(use_place_holder)]
    Point(Box<Point>),
    #[holder(use_place_holder)]
    CartesianPoint(Box<CartesianPoint>),
    #[holder(use_place_holder)]
    DegeneratePcurve(Box<DegeneratePcurveAny>),
    #[holder(use_place_holder)]
    PointOnCurve(Box<PointOnCurve>),
    #[holder(use_place_holder)]
    PointOnSurface(Box<PointOnSurface>),
    #[holder(use_place_holder)]
    PointReplica(Box<PointReplica>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = point_and_vector)]
#[holder(generate_deserialize)]
pub struct PointAndVector {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "compound_representation_item")]
    pub item_element: CompoundItemDefinition,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = point_on_curve)]
#[holder(generate_deserialize)]
pub struct PointOnCurve {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub basis_curve: CurveAny,
    #[holder(use_place_holder)]
    pub point_parameter: ParameterValue,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = point_on_surface)]
#[holder(generate_deserialize)]
pub struct PointOnSurface {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub basis_surface: SurfaceAny,
    #[holder(use_place_holder)]
    pub point_parameter_u: ParameterValue,
    #[holder(use_place_holder)]
    pub point_parameter_v: ParameterValue,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = point_path)]
#[holder(generate_deserialize)]
pub struct PointPath {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "compound_representation_item")]
    pub item_element: CompoundItemDefinition,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = point_replica)]
#[holder(generate_deserialize)]
pub struct PointReplica {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub parent_pt: PointAny,
    #[holder(use_place_holder)]
    pub transformation: CartesianTransformationOperatorAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = point_style)]
#[holder(generate_deserialize)]
pub struct PointStyle {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub marker: MarkerSelect,
    #[holder(use_place_holder)]
    pub marker_size: SizeSelect,
    #[holder(use_place_holder)]
    pub marker_colour: ColourAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = polar_complex_number_literal)]
#[holder(generate_deserialize)]
pub struct PolarComplexNumberLiteral {
    pub radius: f64,
    pub angle: f64,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PolarComplexNumberLiteralAny {
    #[holder(use_place_holder)]
    PolarComplexNumberLiteral(Box<PolarComplexNumberLiteral>),
    #[holder(use_place_holder)]
    ScatteringParameter(Box<ScatteringParameter>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = poly_loop)]
#[holder(generate_deserialize)]
pub struct PolyLoop {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub polygon: Vec<CartesianPoint>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = polyline)]
#[holder(generate_deserialize)]
pub struct Polyline {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub points: Vec<CartesianPoint>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = position_tolerance)]
#[holder(generate_deserialize)]
pub struct PositionTolerance {
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub description: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub magnitude: MeasureWithUnitAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub toleranced_shape_aspect: ShapeAspectAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = positioned_sketch)]
#[holder(generate_deserialize)]
pub struct PositionedSketch {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub sketch_basis: SketchBasisSelect,
    #[holder(use_place_holder)]
    pub auxiliary_elements: Vec<AuxiliaryGeometricRepresentationItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = power_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct PowerMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = power_unit)]
#[holder(generate_deserialize)]
pub struct PowerUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PowerUnitAny {
    #[holder(use_place_holder)]
    PowerUnit(Box<PowerUnit>),
    #[holder(use_place_holder)]
    SiPowerUnit(Box<SiPowerUnit>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = pre_defined_colour)]
#[holder(generate_deserialize)]
pub struct PreDefinedColour {
    #[holder(use_place_holder)]
    #[holder(supertype = "pre_defined_item")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PreDefinedColourAny {
    #[holder(use_place_holder)]
    PreDefinedColour(Box<PreDefinedColour>),
    #[holder(use_place_holder)]
    DraughtingPreDefinedColour(Box<DraughtingPreDefinedColour>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = pre_defined_curve_font)]
#[holder(generate_deserialize)]
pub struct PreDefinedCurveFont {
    #[holder(use_place_holder)]
    #[holder(supertype = "pre_defined_item")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PreDefinedCurveFontAny {
    #[holder(use_place_holder)]
    PreDefinedCurveFont(Box<PreDefinedCurveFont>),
    #[holder(use_place_holder)]
    DraughtingPreDefinedCurveFont(Box<DraughtingPreDefinedCurveFont>),
    #[holder(use_place_holder)]
    SolidCurveFont(Box<SolidCurveFont>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = pre_defined_dimension_symbol)]
#[holder(generate_deserialize)]
pub struct PreDefinedDimensionSymbol {
    #[holder(use_place_holder)]
    #[holder(supertype = "pre_defined_item")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = pre_defined_geometrical_tolerance_symbol)]
#[holder(generate_deserialize)]
pub struct PreDefinedGeometricalToleranceSymbol {
    #[holder(use_place_holder)]
    #[holder(supertype = "pre_defined_item")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = pre_defined_item)]
#[holder(generate_deserialize)]
pub struct PreDefinedItem {
    #[holder(use_place_holder)]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PreDefinedItemAny {
    #[holder(use_place_holder)]
    PreDefinedItem(Box<PreDefinedItem>),
    #[holder(use_place_holder)]
    KnownSource(Box<KnownSource>),
    #[holder(use_place_holder)]
    PreDefinedColour(Box<PreDefinedColourAny>),
    #[holder(use_place_holder)]
    PreDefinedCurveFont(Box<PreDefinedCurveFontAny>),
    #[holder(use_place_holder)]
    PreDefinedMarker(Box<PreDefinedMarkerAny>),
    #[holder(use_place_holder)]
    PreDefinedSurfaceSideStyle(Box<PreDefinedSurfaceSideStyle>),
    #[holder(use_place_holder)]
    PreDefinedSymbol(Box<PreDefinedSymbolAny>),
    #[holder(use_place_holder)]
    PreDefinedTextFont(Box<PreDefinedTextFontAny>),
    #[holder(use_place_holder)]
    PreDefinedTile(Box<PreDefinedTile>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = pre_defined_marker)]
#[holder(generate_deserialize)]
pub struct PreDefinedMarker {
    #[holder(use_place_holder)]
    #[holder(supertype = "pre_defined_item")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PreDefinedMarkerAny {
    #[holder(use_place_holder)]
    PreDefinedMarker(Box<PreDefinedMarker>),
    #[holder(use_place_holder)]
    ExternallyDefinedMarker(Box<ExternallyDefinedMarker>),
    #[holder(use_place_holder)]
    PreDefinedPointMarkerSymbol(Box<PreDefinedPointMarkerSymbol>),
    #[holder(use_place_holder)]
    UserDefinedMarker(Box<UserDefinedMarker>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = pre_defined_point_marker_symbol)]
#[holder(generate_deserialize)]
pub struct PreDefinedPointMarkerSymbol {
    #[holder(use_place_holder)]
    #[holder(supertype = "pre_defined_item")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = pre_defined_surface_condition_symbol)]
#[holder(generate_deserialize)]
pub struct PreDefinedSurfaceConditionSymbol {
    #[holder(use_place_holder)]
    #[holder(supertype = "pre_defined_item")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = pre_defined_surface_side_style)]
#[holder(generate_deserialize)]
pub struct PreDefinedSurfaceSideStyle {
    #[holder(use_place_holder)]
    #[holder(supertype = "pre_defined_item")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = pre_defined_symbol)]
#[holder(generate_deserialize)]
pub struct PreDefinedSymbol {
    #[holder(use_place_holder)]
    #[holder(supertype = "pre_defined_item")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PreDefinedSymbolAny {
    #[holder(use_place_holder)]
    PreDefinedSymbol(Box<PreDefinedSymbol>),
    #[holder(use_place_holder)]
    PreDefinedDimensionSymbol(Box<PreDefinedDimensionSymbol>),
    #[holder(use_place_holder)]
    PreDefinedGeometricalToleranceSymbol(Box<PreDefinedGeometricalToleranceSymbol>),
    #[holder(use_place_holder)]
    PreDefinedPointMarkerSymbol(Box<PreDefinedPointMarkerSymbol>),
    #[holder(use_place_holder)]
    PreDefinedSurfaceConditionSymbol(Box<PreDefinedSurfaceConditionSymbol>),
    #[holder(use_place_holder)]
    PreDefinedTerminatorSymbol(Box<PreDefinedTerminatorSymbolAny>),
    #[holder(use_place_holder)]
    UserDefinedTerminatorSymbol(Box<UserDefinedTerminatorSymbol>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = pre_defined_terminator_symbol)]
#[holder(generate_deserialize)]
pub struct PreDefinedTerminatorSymbol {
    #[holder(use_place_holder)]
    #[holder(supertype = "pre_defined_item")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PreDefinedTerminatorSymbolAny {
    #[holder(use_place_holder)]
    PreDefinedTerminatorSymbol(Box<PreDefinedTerminatorSymbol>),
    #[holder(use_place_holder)]
    VectorStyle(Box<VectorStyle>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = pre_defined_text_font)]
#[holder(generate_deserialize)]
pub struct PreDefinedTextFont {
    #[holder(use_place_holder)]
    #[holder(supertype = "pre_defined_item")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PreDefinedTextFontAny {
    #[holder(use_place_holder)]
    PreDefinedTextFont(Box<PreDefinedTextFont>),
    #[holder(use_place_holder)]
    DraughtingPreDefinedTextFont(Box<DraughtingPreDefinedTextFont>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = pre_defined_tile)]
#[holder(generate_deserialize)]
pub struct PreDefinedTile {
    #[holder(use_place_holder)]
    #[holder(supertype = "pre_defined_item")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = precision_qualifier)]
#[holder(generate_deserialize)]
pub struct PrecisionQualifier {
    pub precision_value: i64,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = predefined_picture_representation_item)]
#[holder(generate_deserialize)]
pub struct PredefinedPictureRepresentationItem {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(supertype = "binary_representation_item")]
    pub binary_value: Binary,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = presentation_area)]
#[holder(generate_deserialize)]
pub struct PresentationArea {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PresentationAreaAny {
    #[holder(use_place_holder)]
    PresentationArea(Box<PresentationArea>),
    #[holder(use_place_holder)]
    DrawingSheetRevision(Box<DrawingSheetRevision>),
    #[holder(use_place_holder)]
    MechanicalDesignGeometricPresentationArea(Box<MechanicalDesignGeometricPresentationArea>),
    #[holder(use_place_holder)]
    MechanicalDesignShadedPresentationArea(Box<MechanicalDesignShadedPresentationArea>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = presentation_layer_assignment)]
#[holder(generate_deserialize)]
pub struct PresentationLayerAssignment {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Text,
    #[holder(use_place_holder)]
    pub assigned_items: Vec<LayeredItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = presentation_representation)]
#[holder(generate_deserialize)]
pub struct PresentationRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PresentationRepresentationAny {
    #[holder(use_place_holder)]
    PresentationRepresentation(Box<PresentationRepresentation>),
    #[holder(use_place_holder)]
    PresentationArea(Box<PresentationAreaAny>),
    #[holder(use_place_holder)]
    PresentationView(Box<PresentationViewAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = presentation_set)]
#[holder(generate_deserialize)]
pub struct PresentationSet {}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PresentationSetAny {
    #[holder(use_place_holder)]
    PresentationSet(Box<PresentationSet>),
    #[holder(use_place_holder)]
    DrawingRevision(Box<DrawingRevision>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = presentation_size)]
#[holder(generate_deserialize)]
pub struct PresentationSize {
    #[holder(use_place_holder)]
    pub unit: PresentationSizeAssignmentSelect,
    #[holder(use_place_holder)]
    pub size: PlanarBox,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = presentation_style_assignment)]
#[holder(generate_deserialize)]
pub struct PresentationStyleAssignment {
    #[holder(use_place_holder)]
    pub styles: Vec<PresentationStyleSelect>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PresentationStyleAssignmentAny {
    #[holder(use_place_holder)]
    PresentationStyleAssignment(Box<PresentationStyleAssignment>),
    #[holder(use_place_holder)]
    PresentationStyleByContext(Box<PresentationStyleByContext>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = presentation_style_by_context)]
#[holder(generate_deserialize)]
pub struct PresentationStyleByContext {
    #[holder(use_place_holder)]
    #[holder(supertype = "presentation_style_assignment")]
    pub styles: Vec<PresentationStyleSelect>,
    #[holder(use_place_holder)]
    pub style_context: StyleContextSelect,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = presentation_view)]
#[holder(generate_deserialize)]
pub struct PresentationView {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PresentationViewAny {
    #[holder(use_place_holder)]
    PresentationView(Box<PresentationView>),
    #[holder(use_place_holder)]
    PictureRepresentation(Box<PictureRepresentation>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = presented_item)]
#[holder(generate_deserialize)]
pub struct PresentedItem {}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PresentedItemAny {
    #[holder(use_place_holder)]
    PresentedItem(Box<PresentedItem>),
    #[holder(use_place_holder)]
    AppliedPresentedItem(Box<AppliedPresentedItem>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = presented_item_representation)]
#[holder(generate_deserialize)]
pub struct PresentedItemRepresentation {
    #[holder(use_place_holder)]
    pub presentation: PresentationRepresentationSelect,
    #[holder(use_place_holder)]
    pub item: PresentedItemAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = pressure_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct PressureMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = pressure_unit)]
#[holder(generate_deserialize)]
pub struct PressureUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PressureUnitAny {
    #[holder(use_place_holder)]
    PressureUnit(Box<PressureUnit>),
    #[holder(use_place_holder)]
    SiPressureUnit(Box<SiPressureUnit>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = procedural_representation)]
#[holder(generate_deserialize)]
pub struct ProceduralRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ProceduralRepresentationAny {
    #[holder(use_place_holder)]
    ProceduralRepresentation(Box<ProceduralRepresentation>),
    #[holder(use_place_holder)]
    ProceduralShapeRepresentation(Box<ProceduralShapeRepresentation>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = procedural_representation_sequence)]
#[holder(generate_deserialize)]
pub struct ProceduralRepresentationSequence {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub elements: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    pub suppressed_items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    pub rationale: Text,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ProceduralRepresentationSequenceAny {
    #[holder(use_place_holder)]
    ProceduralRepresentationSequence(Box<ProceduralRepresentationSequence>),
    #[holder(use_place_holder)]
    ProceduralShapeRepresentationSequence(Box<ProceduralShapeRepresentationSequence>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = procedural_shape_representation)]
#[holder(generate_deserialize)]
pub struct ProceduralShapeRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = procedural_shape_representation_sequence)]
#[holder(generate_deserialize)]
pub struct ProceduralShapeRepresentationSequence {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "procedural_representation_sequence")]
    pub elements: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "procedural_representation_sequence")]
    pub suppressed_items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "procedural_representation_sequence")]
    pub rationale: Text,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = product)]
#[holder(generate_deserialize)]
pub struct Product {
    #[holder(use_place_holder)]
    pub id: Identifier,
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub frame_of_reference: Vec<ProductContextAny>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = product_category)]
#[holder(generate_deserialize)]
pub struct ProductCategory {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ProductCategoryAny {
    #[holder(use_place_holder)]
    ProductCategory(Box<ProductCategory>),
    #[holder(use_place_holder)]
    ProductRelatedProductCategory(Box<ProductRelatedProductCategory>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = product_class)]
#[holder(generate_deserialize)]
pub struct ProductClass {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_concept")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_concept")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_concept")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_concept")]
    pub market_context: ProductConceptContext,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = product_concept)]
#[holder(generate_deserialize)]
pub struct ProductConcept {
    #[holder(use_place_holder)]
    pub id: Identifier,
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub market_context: ProductConceptContext,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ProductConceptAny {
    #[holder(use_place_holder)]
    ProductConcept(Box<ProductConcept>),
    #[holder(use_place_holder)]
    ProductClass(Box<ProductClass>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = product_concept_context)]
#[holder(generate_deserialize)]
pub struct ProductConceptContext {
    #[holder(use_place_holder)]
    #[holder(supertype = "application_context_element")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "application_context_element")]
    pub frame_of_reference: ApplicationContext,
    #[holder(use_place_holder)]
    pub market_segment_type: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = product_concept_feature)]
#[holder(generate_deserialize)]
pub struct ProductConceptFeature {
    #[holder(use_place_holder)]
    pub id: Identifier,
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ProductConceptFeatureAny {
    #[holder(use_place_holder)]
    ProductConceptFeature(Box<ProductConceptFeature>),
    #[holder(use_place_holder)]
    ConditionalConceptFeature(Box<ConditionalConceptFeatureAny>),
    #[holder(use_place_holder)]
    PackageProductConceptFeature(Box<PackageProductConceptFeature>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = product_concept_feature_association)]
#[holder(generate_deserialize)]
pub struct ProductConceptFeatureAssociation {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub concept: ProductConceptAny,
    #[holder(use_place_holder)]
    pub feature: ProductConceptFeatureAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = product_concept_feature_category)]
#[holder(generate_deserialize)]
pub struct ProductConceptFeatureCategory {
    #[holder(use_place_holder)]
    #[holder(supertype = "group")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "group")]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ProductConceptFeatureCategoryAny {
    #[holder(use_place_holder)]
    ProductConceptFeatureCategory(Box<ProductConceptFeatureCategory>),
    #[holder(use_place_holder)]
    ExclusiveProductConceptFeatureCategory(Box<ExclusiveProductConceptFeatureCategory>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = product_concept_feature_category_usage)]
#[holder(generate_deserialize)]
pub struct ProductConceptFeatureCategoryUsage {
    #[holder(use_place_holder)]
    #[holder(supertype = "group_assignment")]
    pub assigned_group: GroupAny,
    #[holder(use_place_holder)]
    pub items: Vec<CategoryUsageItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = product_concept_relationship)]
#[holder(generate_deserialize)]
pub struct ProductConceptRelationship {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub relating_product_concept: ProductConceptAny,
    #[holder(use_place_holder)]
    pub related_product_concept: ProductConceptAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = product_context)]
#[holder(generate_deserialize)]
pub struct ProductContext {
    #[holder(use_place_holder)]
    #[holder(supertype = "application_context_element")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "application_context_element")]
    pub frame_of_reference: ApplicationContext,
    #[holder(use_place_holder)]
    pub discipline_type: Label,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ProductContextAny {
    #[holder(use_place_holder)]
    ProductContext(Box<ProductContext>),
    #[holder(use_place_holder)]
    MechanicalContext(Box<MechanicalContext>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = product_definition)]
#[holder(generate_deserialize)]
pub struct ProductDefinition {
    #[holder(use_place_holder)]
    pub id: Identifier,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub formation: ProductDefinitionFormationAny,
    #[holder(use_place_holder)]
    pub frame_of_reference: ProductDefinitionContextAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ProductDefinitionAny {
    #[holder(use_place_holder)]
    ProductDefinition(Box<ProductDefinition>),
    #[holder(use_place_holder)]
    CompositeAssemblyDefinition(Box<CompositeAssemblyDefinition>),
    #[holder(use_place_holder)]
    CompositeAssemblySequenceDefinition(Box<CompositeAssemblySequenceDefinition>),
    #[holder(use_place_holder)]
    EvaluationProductDefinition(Box<EvaluationProductDefinition>),
    #[holder(use_place_holder)]
    LaminateTable(Box<LaminateTableAny>),
    #[holder(use_place_holder)]
    PercentageLaminateDefinition(Box<PercentageLaminateDefinition>),
    #[holder(use_place_holder)]
    PercentagePlyDefinition(Box<PercentagePlyDefinition>),
    #[holder(use_place_holder)]
    PlyLaminateDefinition(Box<PlyLaminateDefinition>),
    #[holder(use_place_holder)]
    PlyLaminateSequenceDefinition(Box<PlyLaminateSequenceDefinition>),
    #[holder(use_place_holder)]
    ProductDefinitionWithAssociatedDocuments(Box<ProductDefinitionWithAssociatedDocuments>),
    #[holder(use_place_holder)]
    RuleSoftwareDefinition(Box<RuleSoftwareDefinitionAny>),
    #[holder(use_place_holder)]
    SpecificationDefinition(Box<SpecificationDefinition>),
    #[holder(use_place_holder)]
    ThicknessLaminateDefinition(Box<ThicknessLaminateDefinition>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = product_definition_context)]
#[holder(generate_deserialize)]
pub struct ProductDefinitionContext {
    #[holder(use_place_holder)]
    #[holder(supertype = "application_context_element")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "application_context_element")]
    pub frame_of_reference: ApplicationContext,
    #[holder(use_place_holder)]
    pub life_cycle_stage: Label,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ProductDefinitionContextAny {
    #[holder(use_place_holder)]
    ProductDefinitionContext(Box<ProductDefinitionContext>),
    #[holder(use_place_holder)]
    DesignContext(Box<DesignContext>),
    #[holder(use_place_holder)]
    InstanceUsageContextAssignment(Box<InstanceUsageContextAssignment>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = product_definition_context_association)]
#[holder(generate_deserialize)]
pub struct ProductDefinitionContextAssociation {
    #[holder(use_place_holder)]
    pub definition: ProductDefinitionAny,
    #[holder(use_place_holder)]
    pub frame_of_reference: ProductDefinitionContextAny,
    #[holder(use_place_holder)]
    pub role: ProductDefinitionContextRole,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = product_definition_context_role)]
#[holder(generate_deserialize)]
pub struct ProductDefinitionContextRole {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = product_definition_effectivity)]
#[holder(generate_deserialize)]
pub struct ProductDefinitionEffectivity {
    #[holder(use_place_holder)]
    #[holder(supertype = "effectivity")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    pub usage: ProductDefinitionRelationshipAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ProductDefinitionEffectivityAny {
    #[holder(use_place_holder)]
    ProductDefinitionEffectivity(Box<ProductDefinitionEffectivity>),
    #[holder(use_place_holder)]
    ConfigurationEffectivity(Box<ConfigurationEffectivity>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = product_definition_element_relationship)]
#[holder(generate_deserialize)]
pub struct ProductDefinitionElementRelationship {
    #[holder(use_place_holder)]
    #[holder(supertype = "group")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "group")]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ProductDefinitionElementRelationshipAny {
    #[holder(use_place_holder)]
    ProductDefinitionElementRelationship(Box<ProductDefinitionElementRelationship>),
    #[holder(use_place_holder)]
    BreakdownElementRealization(Box<BreakdownElementRealization>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = product_definition_formation)]
#[holder(generate_deserialize)]
pub struct ProductDefinitionFormation {
    #[holder(use_place_holder)]
    pub id: Identifier,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub of_product: Product,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ProductDefinitionFormationAny {
    #[holder(use_place_holder)]
    ProductDefinitionFormation(Box<ProductDefinitionFormation>),
    #[holder(use_place_holder)]
    ProductDefinitionFormationWithSpecifiedSource(
        Box<ProductDefinitionFormationWithSpecifiedSource>,
    ),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = product_definition_formation_relationship)]
#[holder(generate_deserialize)]
pub struct ProductDefinitionFormationRelationship {
    #[holder(use_place_holder)]
    pub id: Identifier,
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub relating_product_definition_formation: ProductDefinitionFormationAny,
    #[holder(use_place_holder)]
    pub related_product_definition_formation: ProductDefinitionFormationAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = product_definition_formation_with_specified_source)]
#[holder(generate_deserialize)]
pub struct ProductDefinitionFormationWithSpecifiedSource {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_formation")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_formation")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_formation")]
    pub of_product: Product,
    pub make_or_buy: Source,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = product_definition_group_assignment)]
#[holder(generate_deserialize)]
pub struct ProductDefinitionGroupAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "group_assignment")]
    pub assigned_group: GroupAny,
    #[holder(use_place_holder)]
    pub items: Vec<ProductDefinitionOrProductDefinitionRelationship>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = product_definition_occurrence_relationship)]
#[holder(generate_deserialize)]
pub struct ProductDefinitionOccurrenceRelationship {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub occurrence: ProductDefinitionAny,
    #[holder(use_place_holder)]
    pub occurrence_usage: AssemblyComponentUsageAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = product_definition_relationship)]
#[holder(generate_deserialize)]
pub struct ProductDefinitionRelationship {
    #[holder(use_place_holder)]
    pub id: Identifier,
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub relating_product_definition: ProductDefinitionAny,
    #[holder(use_place_holder)]
    pub related_product_definition: ProductDefinitionAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ProductDefinitionRelationshipAny {
    #[holder(use_place_holder)]
    ProductDefinitionRelationship(Box<ProductDefinitionRelationship>),
    #[holder(use_place_holder)]
    BreakdownContext(Box<BreakdownContextAny>),
    #[holder(use_place_holder)]
    BreakdownElementUsage(Box<BreakdownElementUsageAny>),
    #[holder(use_place_holder)]
    BreakdownOf(Box<BreakdownOf>),
    #[holder(use_place_holder)]
    DesignMakeFromRelationship(Box<DesignMakeFromRelationship>),
    #[holder(use_place_holder)]
    ProductDefinitionUsage(Box<ProductDefinitionUsageAny>),
    #[holder(use_place_holder)]
    ProductMaterialCompositionRelationship(Box<ProductMaterialCompositionRelationship>),
    #[holder(use_place_holder)]
    RequirementViewDefinitionRelationship(Box<RequirementViewDefinitionRelationship>),
    #[holder(use_place_holder)]
    SuppliedPartRelationship(Box<SuppliedPartRelationship>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = product_definition_shape)]
#[holder(generate_deserialize)]
pub struct ProductDefinitionShape {
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition")]
    pub definition: CharacterizedDefinition,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = product_definition_substitute)]
#[holder(generate_deserialize)]
pub struct ProductDefinitionSubstitute {
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub context_relationship: ProductDefinitionRelationshipAny,
    #[holder(use_place_holder)]
    pub substitute_definition: ProductDefinitionAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = product_definition_usage)]
#[holder(generate_deserialize)]
pub struct ProductDefinitionUsage {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub relating_product_definition: ProductDefinitionAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub related_product_definition: ProductDefinitionAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ProductDefinitionUsageAny {
    #[holder(use_place_holder)]
    ProductDefinitionUsage(Box<ProductDefinitionUsage>),
    #[holder(use_place_holder)]
    AssemblyComponentUsage(Box<AssemblyComponentUsageAny>),
    #[holder(use_place_holder)]
    MakeFromUsageOption(Box<MakeFromUsageOption>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = product_definition_with_associated_documents)]
#[holder(generate_deserialize)]
pub struct ProductDefinitionWithAssociatedDocuments {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub formation: ProductDefinitionFormationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub frame_of_reference: ProductDefinitionContextAny,
    #[holder(use_place_holder)]
    pub documentation_ids: Vec<DocumentAny>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = product_identification)]
#[holder(generate_deserialize)]
pub struct ProductIdentification {
    #[holder(use_place_holder)]
    #[holder(supertype = "configuration_item")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "configuration_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "configuration_item")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "configuration_item")]
    pub item_concept: ProductConceptAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "configuration_item")]
    pub purpose: Option<Label>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ProductIdentificationAny {
    #[holder(use_place_holder)]
    ProductIdentification(Box<ProductIdentification>),
    #[holder(use_place_holder)]
    ProductSpecification(Box<ProductSpecification>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = product_material_composition_relationship)]
#[holder(generate_deserialize)]
pub struct ProductMaterialCompositionRelationship {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub relating_product_definition: ProductDefinitionAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub related_product_definition: ProductDefinitionAny,
    #[holder(use_place_holder)]
    pub class: Label,
    #[holder(use_place_holder)]
    pub constituent_amount: Vec<CharacterizedProductCompositionValue>,
    #[holder(use_place_holder)]
    pub composition_basis: Label,
    #[holder(use_place_holder)]
    pub determination_method: Text,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = product_related_product_category)]
#[holder(generate_deserialize)]
pub struct ProductRelatedProductCategory {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_category")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_category")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub products: Vec<Product>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = product_specification)]
#[holder(generate_deserialize)]
pub struct ProductSpecification {
    #[holder(use_place_holder)]
    #[holder(supertype = "configuration_item")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "configuration_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "configuration_item")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "configuration_item")]
    pub item_concept: ProductConceptAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "configuration_item")]
    pub purpose: Option<Label>,
    #[holder(use_place_holder)]
    #[holder(supertype = "configurable_item")]
    pub item_concept_feature: Vec<ProductConceptFeatureAssociation>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = projected_zone_definition)]
#[holder(generate_deserialize)]
pub struct ProjectedZoneDefinition {
    #[holder(use_place_holder)]
    #[holder(supertype = "tolerance_zone_definition")]
    pub zone: ToleranceZone,
    #[holder(use_place_holder)]
    #[holder(supertype = "tolerance_zone_definition")]
    pub boundaries: Vec<ShapeAspectAny>,
    #[holder(use_place_holder)]
    pub projection_end: ShapeAspectAny,
    #[holder(use_place_holder)]
    pub projected_length: MeasureWithUnitAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = projection_curve)]
#[holder(generate_deserialize)]
pub struct ProjectionCurve {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "styled_item")]
    pub styles: Vec<PresentationStyleAssignmentAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "styled_item")]
    pub item: RepresentationItemAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = projection_directed_callout)]
#[holder(generate_deserialize)]
pub struct ProjectionDirectedCallout {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "draughting_callout")]
    pub contents: Vec<DraughtingCalloutElement>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ProjectionDirectedCalloutAny {
    #[holder(use_place_holder)]
    ProjectionDirectedCallout(Box<ProjectionDirectedCallout>),
    #[holder(use_place_holder)]
    OrdinateDimension(Box<OrdinateDimension>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = promissory_usage_occurrence)]
#[holder(generate_deserialize)]
pub struct PromissoryUsageOccurrence {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub relating_product_definition: ProductDefinitionAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub related_product_definition: ProductDefinitionAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "assembly_component_usage")]
    pub reference_designator: Option<Identifier>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = property_definition)]
#[holder(generate_deserialize)]
pub struct PropertyDefinition {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub definition: CharacterizedDefinition,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PropertyDefinitionAny {
    #[holder(use_place_holder)]
    PropertyDefinition(Box<PropertyDefinition>),
    #[holder(use_place_holder)]
    AbstractVariable(Box<AbstractVariableAny>),
    #[holder(use_place_holder)]
    BackChainingRuleBody(Box<BackChainingRuleBody>),
    #[holder(use_place_holder)]
    FactType(Box<FactTypeAny>),
    #[holder(use_place_holder)]
    ForwardChainingRulePremise(Box<ForwardChainingRulePremise>),
    #[holder(use_place_holder)]
    MaterialProperty(Box<MaterialProperty>),
    #[holder(use_place_holder)]
    ProductDefinitionShape(Box<ProductDefinitionShape>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = property_definition_relationship)]
#[holder(generate_deserialize)]
pub struct PropertyDefinitionRelationship {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Text,
    #[holder(use_place_holder)]
    pub relating_property_definition: PropertyDefinitionAny,
    #[holder(use_place_holder)]
    pub related_property_definition: PropertyDefinitionAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = property_definition_representation)]
#[holder(generate_deserialize)]
pub struct PropertyDefinitionRepresentation {
    #[holder(use_place_holder)]
    pub definition: RepresentedDefinition,
    #[holder(use_place_holder)]
    pub used_representation: RepresentationAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum PropertyDefinitionRepresentationAny {
    #[holder(use_place_holder)]
    PropertyDefinitionRepresentation(Box<PropertyDefinitionRepresentation>),
    #[holder(use_place_holder)]
    AbstractVariable(Box<AbstractVariableAny>),
    #[holder(use_place_holder)]
    AttributeAssertion(Box<AttributeAssertion>),
    #[holder(use_place_holder)]
    BackChainingRuleBody(Box<BackChainingRuleBody>),
    #[holder(use_place_holder)]
    ForwardChainingRulePremise(Box<ForwardChainingRulePremise>),
    #[holder(use_place_holder)]
    MaterialPropertyRepresentation(Box<MaterialPropertyRepresentation>),
    #[holder(use_place_holder)]
    ShapeDefinitionRepresentation(Box<ShapeDefinitionRepresentation>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = qualified_representation_item)]
#[holder(generate_deserialize)]
pub struct QualifiedRepresentationItem {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub qualifiers: Vec<ValueQualifier>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = qualitative_uncertainty)]
#[holder(generate_deserialize)]
pub struct QualitativeUncertainty {
    #[holder(use_place_holder)]
    #[holder(supertype = "uncertainty_qualifier")]
    pub measure_name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "uncertainty_qualifier")]
    pub description: Text,
    #[holder(use_place_holder)]
    pub uncertainty_value: Text,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = quantified_assembly_component_usage)]
#[holder(generate_deserialize)]
pub struct QuantifiedAssemblyComponentUsage {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub relating_product_definition: ProductDefinitionAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub related_product_definition: ProductDefinitionAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "assembly_component_usage")]
    pub reference_designator: Option<Identifier>,
    #[holder(use_place_holder)]
    pub quantity: MeasureWithUnitAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = quasi_uniform_curve)]
#[holder(generate_deserialize)]
pub struct QuasiUniformCurve {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(supertype = "b_spline_curve")]
    pub degree: i64,
    #[holder(use_place_holder)]
    #[holder(supertype = "b_spline_curve")]
    pub control_points_list: Vec<CartesianPoint>,
    #[holder(supertype = "b_spline_curve")]
    pub curve_form: BSplineCurveForm,
    #[holder(supertype = "b_spline_curve")]
    pub closed_curve: Logical,
    #[holder(supertype = "b_spline_curve")]
    pub self_intersect: Logical,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = quasi_uniform_surface)]
#[holder(generate_deserialize)]
pub struct QuasiUniformSurface {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(supertype = "b_spline_surface")]
    pub u_degree: i64,
    #[holder(supertype = "b_spline_surface")]
    pub v_degree: i64,
    #[holder(use_place_holder)]
    #[holder(supertype = "b_spline_surface")]
    pub control_points_list: Vec<Vec<CartesianPoint>>,
    #[holder(supertype = "b_spline_surface")]
    pub surface_form: BSplineSurfaceForm,
    #[holder(supertype = "b_spline_surface")]
    pub u_closed: Logical,
    #[holder(supertype = "b_spline_surface")]
    pub v_closed: Logical,
    #[holder(supertype = "b_spline_surface")]
    pub self_intersect: Logical,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = radioactivity_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct RadioactivityMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = radioactivity_unit)]
#[holder(generate_deserialize)]
pub struct RadioactivityUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum RadioactivityUnitAny {
    #[holder(use_place_holder)]
    RadioactivityUnit(Box<RadioactivityUnit>),
    #[holder(use_place_holder)]
    SiRadioactivityUnit(Box<SiRadioactivityUnit>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = radius_dimension)]
#[holder(generate_deserialize)]
pub struct RadiusDimension {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "draughting_callout")]
    pub contents: Vec<DraughtingCalloutElement>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = range_characteristic)]
#[holder(generate_deserialize)]
pub struct RangeCharacteristic {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "descriptive_representation_item")]
    pub description: Text,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = ratio_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct RatioMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum RatioMeasureWithUnitAny {
    #[holder(use_place_holder)]
    RatioMeasureWithUnit(Box<RatioMeasureWithUnit>),
    #[holder(use_place_holder)]
    DielectricConstantMeasureWithUnit(Box<DielectricConstantMeasureWithUnit>),
    #[holder(use_place_holder)]
    LossTangentMeasureWithUnit(Box<LossTangentMeasureWithUnit>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = ratio_unit)]
#[holder(generate_deserialize)]
pub struct RatioUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "named_unit")]
    pub dimensions: DimensionalExponents,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = rational_b_spline_curve)]
#[holder(generate_deserialize)]
pub struct RationalBSplineCurve {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(supertype = "b_spline_curve")]
    pub degree: i64,
    #[holder(use_place_holder)]
    #[holder(supertype = "b_spline_curve")]
    pub control_points_list: Vec<CartesianPoint>,
    #[holder(supertype = "b_spline_curve")]
    pub curve_form: BSplineCurveForm,
    #[holder(supertype = "b_spline_curve")]
    pub closed_curve: Logical,
    #[holder(supertype = "b_spline_curve")]
    pub self_intersect: Logical,
    pub weights_data: Vec<f64>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = rational_b_spline_surface)]
#[holder(generate_deserialize)]
pub struct RationalBSplineSurface {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(supertype = "b_spline_surface")]
    pub u_degree: i64,
    #[holder(supertype = "b_spline_surface")]
    pub v_degree: i64,
    #[holder(use_place_holder)]
    #[holder(supertype = "b_spline_surface")]
    pub control_points_list: Vec<Vec<CartesianPoint>>,
    #[holder(supertype = "b_spline_surface")]
    pub surface_form: BSplineSurfaceForm,
    #[holder(supertype = "b_spline_surface")]
    pub u_closed: Logical,
    #[holder(supertype = "b_spline_surface")]
    pub v_closed: Logical,
    #[holder(supertype = "b_spline_surface")]
    pub self_intersect: Logical,
    pub weights_data: Vec<Vec<f64>>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = rational_representation_item)]
#[holder(generate_deserialize)]
pub struct RationalRepresentationItem {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "binary_generic_expression")]
    pub operands: Vec<GenericExpressionAny>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = real_literal)]
#[holder(generate_deserialize)]
pub struct RealLiteral {
    #[holder(supertype = "literal_number")]
    pub the_value: f64,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum RealLiteralAny {
    #[holder(use_place_holder)]
    RealLiteral(Box<RealLiteral>),
    #[holder(use_place_holder)]
    RealRepresentationItem(Box<RealRepresentationItem>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = real_representation_item)]
#[holder(generate_deserialize)]
pub struct RealRepresentationItem {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(supertype = "literal_number")]
    pub the_value: f64,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = rectangular_composite_surface)]
#[holder(generate_deserialize)]
pub struct RectangularCompositeSurface {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub segments: Vec<Vec<SurfacePatch>>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = rectangular_trimmed_surface)]
#[holder(generate_deserialize)]
pub struct RectangularTrimmedSurface {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub basis_surface: SurfaceAny,
    #[holder(use_place_holder)]
    pub u1: ParameterValue,
    #[holder(use_place_holder)]
    pub u2: ParameterValue,
    #[holder(use_place_holder)]
    pub v1: ParameterValue,
    #[holder(use_place_holder)]
    pub v2: ParameterValue,
    pub usense: bool,
    pub vsense: bool,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = referenced_modified_datum)]
#[holder(generate_deserialize)]
pub struct ReferencedModifiedDatum {
    #[holder(supertype = "datum_reference")]
    pub precedence: i64,
    #[holder(use_place_holder)]
    #[holder(supertype = "datum_reference")]
    pub referenced_datum: DatumAny,
    pub modifier: LimitCondition,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = relative_event_occurrence)]
#[holder(generate_deserialize)]
pub struct RelativeEventOccurrence {
    #[holder(use_place_holder)]
    #[holder(supertype = "event_occurrence")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "event_occurrence")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "event_occurrence")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub base_event: EventOccurrenceAny,
    #[holder(use_place_holder)]
    pub offset: TimeMeasureWithUnit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = rep_item_group)]
#[holder(generate_deserialize)]
pub struct RepItemGroup {
    #[holder(use_place_holder)]
    #[holder(supertype = "group")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "group")]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = reparametrised_composite_curve_segment)]
#[holder(generate_deserialize)]
pub struct ReparametrisedCompositeCurveSegment {
    #[holder(supertype = "composite_curve_segment")]
    pub transition: TransitionCode,
    #[holder(supertype = "composite_curve_segment")]
    pub same_sense: bool,
    #[holder(use_place_holder)]
    #[holder(supertype = "composite_curve_segment")]
    pub parent_curve: CurveAny,
    #[holder(use_place_holder)]
    pub param_length: ParameterValue,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = representation)]
#[holder(generate_deserialize)]
pub struct Representation {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum RepresentationAny {
    #[holder(use_place_holder)]
    Representation(Box<Representation>),
    #[holder(use_place_holder)]
    AbstractVariable(Box<AbstractVariableAny>),
    #[holder(use_place_holder)]
    AttributeAssertion(Box<AttributeAssertion>),
    #[holder(use_place_holder)]
    BackChainingRuleBody(Box<BackChainingRuleBody>),
    #[holder(use_place_holder)]
    ConstructiveGeometryRepresentation(Box<ConstructiveGeometryRepresentation>),
    #[holder(use_place_holder)]
    ContactRatioRepresentation(Box<ContactRatioRepresentation>),
    #[holder(use_place_holder)]
    DefaultToleranceTable(Box<DefaultToleranceTable>),
    #[holder(use_place_holder)]
    DefinitionalRepresentation(Box<DefinitionalRepresentation>),
    #[holder(use_place_holder)]
    DraughtingModel(Box<DraughtingModel>),
    #[holder(use_place_holder)]
    EvaluatedCharacteristic(Box<EvaluatedCharacteristic>),
    #[holder(use_place_holder)]
    ForwardChainingRulePremise(Box<ForwardChainingRulePremise>),
    #[holder(use_place_holder)]
    HardnessRepresentation(Box<HardnessRepresentation>),
    #[holder(use_place_holder)]
    MechanicalDesignGeometricPresentationRepresentation(
        Box<MechanicalDesignGeometricPresentationRepresentation>,
    ),
    #[holder(use_place_holder)]
    MechanicalDesignPresentationRepresentationWithDraughting(
        Box<MechanicalDesignPresentationRepresentationWithDraughting>,
    ),
    #[holder(use_place_holder)]
    MechanicalDesignShadedPresentationRepresentation(
        Box<MechanicalDesignShadedPresentationRepresentation>,
    ),
    #[holder(use_place_holder)]
    MomentsOfInertiaRepresentation(Box<MomentsOfInertiaRepresentation>),
    #[holder(use_place_holder)]
    PresentationRepresentation(Box<PresentationRepresentationAny>),
    #[holder(use_place_holder)]
    ProceduralRepresentation(Box<ProceduralRepresentationAny>),
    #[holder(use_place_holder)]
    RangeCharacteristic(Box<RangeCharacteristic>),
    #[holder(use_place_holder)]
    ShapeRepresentation(Box<ShapeRepresentationAny>),
    #[holder(use_place_holder)]
    StructuredTextRepresentation(Box<StructuredTextRepresentation>),
    #[holder(use_place_holder)]
    SurfaceTextureRepresentation(Box<SurfaceTextureRepresentation>),
    #[holder(use_place_holder)]
    SymbolRepresentation(Box<SymbolRepresentationAny>),
    #[holder(use_place_holder)]
    TactileAppearanceRepresentation(Box<TactileAppearanceRepresentation>),
    #[holder(use_place_holder)]
    TextStringRepresentation(Box<TextStringRepresentation>),
    #[holder(use_place_holder)]
    UncertaintyAssignedRepresentation(Box<UncertaintyAssignedRepresentation>),
    #[holder(use_place_holder)]
    VisualAppearanceRepresentation(Box<VisualAppearanceRepresentation>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = representation_context)]
#[holder(generate_deserialize)]
pub struct RepresentationContext {
    #[holder(use_place_holder)]
    pub context_identifier: Identifier,
    #[holder(use_place_holder)]
    pub context_type: Text,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum RepresentationContextAny {
    #[holder(use_place_holder)]
    RepresentationContext(Box<RepresentationContext>),
    #[holder(use_place_holder)]
    GeometricRepresentationContext(Box<GeometricRepresentationContext>),
    #[holder(use_place_holder)]
    GlobalUncertaintyAssignedContext(Box<GlobalUncertaintyAssignedContext>),
    #[holder(use_place_holder)]
    GlobalUnitAssignedContext(Box<GlobalUnitAssignedContext>),
    #[holder(use_place_holder)]
    ParametricRepresentationContext(Box<ParametricRepresentationContext>),
    #[holder(use_place_holder)]
    TaggedTextFormat(Box<TaggedTextFormat>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = representation_item)]
#[holder(generate_deserialize)]
pub struct RepresentationItem {
    #[holder(use_place_holder)]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum RepresentationItemAny {
    #[holder(use_place_holder)]
    RepresentationItem(Box<RepresentationItem>),
    #[holder(use_place_holder)]
    AbstractVariable(Box<AbstractVariableAny>),
    #[holder(use_place_holder)]
    BinaryRepresentationItem(Box<BinaryRepresentationItemAny>),
    #[holder(use_place_holder)]
    BooleanRepresentationItem(Box<BooleanRepresentationItem>),
    #[holder(use_place_holder)]
    CompoundRepresentationItem(Box<CompoundRepresentationItemAny>),
    #[holder(use_place_holder)]
    DateRepresentationItem(Box<DateRepresentationItem>),
    #[holder(use_place_holder)]
    DateTimeRepresentationItem(Box<DateTimeRepresentationItem>),
    #[holder(use_place_holder)]
    DescriptiveRepresentationItem(Box<DescriptiveRepresentationItemAny>),
    #[holder(use_place_holder)]
    ExternallyDefinedRepresentationItem(Box<ExternallyDefinedRepresentationItemAny>),
    #[holder(use_place_holder)]
    GeometricRepresentationItem(Box<GeometricRepresentationItemAny>),
    #[holder(use_place_holder)]
    IntegerRepresentationItem(Box<IntegerRepresentationItem>),
    #[holder(use_place_holder)]
    LogicalRepresentationItem(Box<LogicalRepresentationItem>),
    #[holder(use_place_holder)]
    MappedItem(Box<MappedItemAny>),
    #[holder(use_place_holder)]
    MeasureRepresentationItem(Box<MeasureRepresentationItem>),
    #[holder(use_place_holder)]
    NullRepresentationItem(Box<NullRepresentationItem>),
    #[holder(use_place_holder)]
    ProceduralRepresentationSequence(Box<ProceduralRepresentationSequenceAny>),
    #[holder(use_place_holder)]
    QualifiedRepresentationItem(Box<QualifiedRepresentationItem>),
    #[holder(use_place_holder)]
    RationalRepresentationItem(Box<RationalRepresentationItem>),
    #[holder(use_place_holder)]
    RealRepresentationItem(Box<RealRepresentationItem>),
    #[holder(use_place_holder)]
    RepItemGroup(Box<RepItemGroup>),
    #[holder(use_place_holder)]
    StyledItem(Box<StyledItemAny>),
    #[holder(use_place_holder)]
    Symbol(Box<Symbol>),
    #[holder(use_place_holder)]
    TopologicalRepresentationItem(Box<TopologicalRepresentationItemAny>),
    #[holder(use_place_holder)]
    UserSelectedElements(Box<UserSelectedElementsAny>),
    #[holder(use_place_holder)]
    ValueRepresentationItem(Box<ValueRepresentationItem>),
    #[holder(use_place_holder)]
    VariationalRepresentationItem(Box<VariationalRepresentationItemAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = representation_item_relationship)]
#[holder(generate_deserialize)]
pub struct RepresentationItemRelationship {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub relating_representation_item: RepresentationItemAny,
    #[holder(use_place_holder)]
    pub related_representation_item: RepresentationItemAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum RepresentationItemRelationshipAny {
    #[holder(use_place_holder)]
    RepresentationItemRelationship(Box<RepresentationItemRelationship>),
    #[holder(use_place_holder)]
    AngleDirectionReference(Box<AngleDirectionReference>),
    #[holder(use_place_holder)]
    ExplicitProceduralRepresentationItemRelationship(
        Box<ExplicitProceduralRepresentationItemRelationshipAny>,
    ),
    #[holder(use_place_holder)]
    GeometricModelElementRelationship(Box<GeometricModelElementRelationship>),
    #[holder(use_place_holder)]
    GlobalAssignment(Box<GlobalAssignment>),
    #[holder(use_place_holder)]
    MinAndMajorPlyOrientationBasis(Box<MinAndMajorPlyOrientationBasis>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = representation_map)]
#[holder(generate_deserialize)]
pub struct RepresentationMap {
    #[holder(use_place_holder)]
    pub mapping_origin: RepresentationItemAny,
    #[holder(use_place_holder)]
    pub mapped_representation: RepresentationAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum RepresentationMapAny {
    #[holder(use_place_holder)]
    RepresentationMap(Box<RepresentationMap>),
    #[holder(use_place_holder)]
    CameraUsage(Box<CameraUsage>),
    #[holder(use_place_holder)]
    SymbolRepresentationMap(Box<SymbolRepresentationMap>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = representation_relationship)]
#[holder(generate_deserialize)]
pub struct RepresentationRelationship {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub rep_1: RepresentationAny,
    #[holder(use_place_holder)]
    pub rep_2: RepresentationAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum RepresentationRelationshipAny {
    #[holder(use_place_holder)]
    RepresentationRelationship(Box<RepresentationRelationship>),
    #[holder(use_place_holder)]
    ConstructiveGeometryRepresentationRelationship(
        Box<ConstructiveGeometryRepresentationRelationship>,
    ),
    #[holder(use_place_holder)]
    DefinitionalRepresentationRelationship(Box<DefinitionalRepresentationRelationshipAny>),
    #[holder(use_place_holder)]
    DrawingSheetRevisionSequence(Box<DrawingSheetRevisionSequence>),
    #[holder(use_place_holder)]
    EvaluatedCharacteristic(Box<EvaluatedCharacteristic>),
    #[holder(use_place_holder)]
    ExplicitProceduralRepresentationRelationship(
        Box<ExplicitProceduralRepresentationRelationshipAny>,
    ),
    #[holder(use_place_holder)]
    RepresentationRelationshipWithTransformation(Box<RepresentationRelationshipWithTransformation>),
    #[holder(use_place_holder)]
    ShapeRepresentationRelationship(Box<ShapeRepresentationRelationshipAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = representation_relationship_with_transformation)]
#[holder(generate_deserialize)]
pub struct RepresentationRelationshipWithTransformation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub rep_1: RepresentationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub rep_2: RepresentationAny,
    #[holder(use_place_holder)]
    pub transformation_operator: Transformation,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = requirement_assigned_object)]
#[holder(generate_deserialize)]
pub struct RequirementAssignedObject {
    #[holder(use_place_holder)]
    #[holder(supertype = "group_assignment")]
    pub assigned_group: GroupAny,
    #[holder(use_place_holder)]
    pub items: Vec<RequirementAssignedItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = requirement_assignment)]
#[holder(generate_deserialize)]
pub struct RequirementAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "characterized_object")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "characterized_object")]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = requirement_source)]
#[holder(generate_deserialize)]
pub struct RequirementSource {
    #[holder(use_place_holder)]
    #[holder(supertype = "group")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "group")]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = requirement_view_definition_relationship)]
#[holder(generate_deserialize)]
pub struct RequirementViewDefinitionRelationship {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub relating_product_definition: ProductDefinitionAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub related_product_definition: ProductDefinitionAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = resistance_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct ResistanceMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = resistance_unit)]
#[holder(generate_deserialize)]
pub struct ResistanceUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ResistanceUnitAny {
    #[holder(use_place_holder)]
    ResistanceUnit(Box<ResistanceUnit>),
    #[holder(use_place_holder)]
    SiResistanceUnit(Box<SiResistanceUnit>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = revolved_area_solid)]
#[holder(generate_deserialize)]
pub struct RevolvedAreaSolid {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "swept_area_solid")]
    pub swept_area: CurveBoundedSurface,
    #[holder(use_place_holder)]
    pub axis: Axis1Placement,
    #[holder(use_place_holder)]
    pub angle: PlaneAngleMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = revolved_face_solid)]
#[holder(generate_deserialize)]
pub struct RevolvedFaceSolid {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "swept_face_solid")]
    pub swept_face: FaceSurfaceAny,
    #[holder(use_place_holder)]
    pub axis: Axis1Placement,
    #[holder(use_place_holder)]
    pub angle: PlaneAngleMeasure,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum RevolvedFaceSolidAny {
    #[holder(use_place_holder)]
    RevolvedFaceSolid(Box<RevolvedFaceSolid>),
    #[holder(use_place_holder)]
    RevolvedFaceSolidWithTrimConditions(Box<RevolvedFaceSolidWithTrimConditions>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = revolved_face_solid_with_trim_conditions)]
#[holder(generate_deserialize)]
pub struct RevolvedFaceSolidWithTrimConditions {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "swept_face_solid")]
    pub swept_face: FaceSurfaceAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "revolved_face_solid")]
    pub axis: Axis1Placement,
    #[holder(use_place_holder)]
    #[holder(supertype = "revolved_face_solid")]
    pub angle: PlaneAngleMeasure,
    #[holder(use_place_holder)]
    pub first_trim_condition: TrimConditionSelect,
    #[holder(use_place_holder)]
    pub second_trim_condition: TrimConditionSelect,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = right_angular_wedge)]
#[holder(generate_deserialize)]
pub struct RightAngularWedge {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub position: Axis2Placement3D,
    #[holder(use_place_holder)]
    pub x: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    pub y: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    pub z: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    pub ltx: LengthMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = right_circular_cone)]
#[holder(generate_deserialize)]
pub struct RightCircularCone {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub position: Axis1Placement,
    #[holder(use_place_holder)]
    pub height: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    pub radius: LengthMeasure,
    #[holder(use_place_holder)]
    pub semi_angle: PlaneAngleMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = right_circular_cylinder)]
#[holder(generate_deserialize)]
pub struct RightCircularCylinder {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub position: Axis1Placement,
    #[holder(use_place_holder)]
    pub height: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    pub radius: PositiveLengthMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = right_to_usage_association)]
#[holder(generate_deserialize)]
pub struct RightToUsageAssociation {
    #[holder(use_place_holder)]
    #[holder(supertype = "action_method_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "action_method_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "action_method_relationship")]
    pub relating_method: ActionMethodAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "action_method_relationship")]
    pub related_method: ActionMethodAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = role_association)]
#[holder(generate_deserialize)]
pub struct RoleAssociation {
    #[holder(use_place_holder)]
    pub role: ObjectRole,
    #[holder(use_place_holder)]
    pub item_with_role: RoleSelect,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = roundness_tolerance)]
#[holder(generate_deserialize)]
pub struct RoundnessTolerance {
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub description: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub magnitude: MeasureWithUnitAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub toleranced_shape_aspect: ShapeAspectAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = row_representation_item)]
#[holder(generate_deserialize)]
pub struct RowRepresentationItem {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "compound_representation_item")]
    pub item_element: CompoundItemDefinition,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = row_value)]
#[holder(generate_deserialize)]
pub struct RowValue {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "compound_representation_item")]
    pub item_element: CompoundItemDefinition,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = row_variable)]
#[holder(generate_deserialize)]
pub struct RowVariable {
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition")]
    pub definition: CharacterizedDefinition,
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition_representation")]
    pub used_representation: RepresentationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = rule_action)]
#[holder(generate_deserialize)]
pub struct RuleAction {
    #[holder(use_place_holder)]
    #[holder(supertype = "action")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "action")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "action")]
    pub chosen_method: ActionMethodAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum RuleActionAny {
    #[holder(use_place_holder)]
    RuleAction(Box<RuleAction>),
    #[holder(use_place_holder)]
    RuleSupersedence(Box<RuleSupersedence>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = rule_condition)]
#[holder(generate_deserialize)]
pub struct RuleCondition {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "compound_representation_item")]
    pub item_element: CompoundItemDefinition,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = rule_definition)]
#[holder(generate_deserialize)]
pub struct RuleDefinition {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub formation: ProductDefinitionFormationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub frame_of_reference: ProductDefinitionContextAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum RuleDefinitionAny {
    #[holder(use_place_holder)]
    RuleDefinition(Box<RuleDefinition>),
    #[holder(use_place_holder)]
    BackChainingRule(Box<BackChainingRule>),
    #[holder(use_place_holder)]
    ForwardChainingRule(Box<ForwardChainingRule>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = rule_set)]
#[holder(generate_deserialize)]
pub struct RuleSet {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub formation: ProductDefinitionFormationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub frame_of_reference: ProductDefinitionContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = rule_set_group)]
#[holder(generate_deserialize)]
pub struct RuleSetGroup {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub formation: ProductDefinitionFormationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub frame_of_reference: ProductDefinitionContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = rule_software_definition)]
#[holder(generate_deserialize)]
pub struct RuleSoftwareDefinition {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub formation: ProductDefinitionFormationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub frame_of_reference: ProductDefinitionContextAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum RuleSoftwareDefinitionAny {
    #[holder(use_place_holder)]
    RuleSoftwareDefinition(Box<RuleSoftwareDefinition>),
    #[holder(use_place_holder)]
    RuleDefinition(Box<RuleDefinitionAny>),
    #[holder(use_place_holder)]
    RuleSet(Box<RuleSet>),
    #[holder(use_place_holder)]
    RuleSetGroup(Box<RuleSetGroup>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = rule_superseded_assignment)]
#[holder(generate_deserialize)]
pub struct RuleSupersededAssignment {
    #[holder(use_place_holder)]
    #[holder(supertype = "action_assignment")]
    pub assigned_action: ActionAny,
    #[holder(use_place_holder)]
    pub items: Vec<RuleSupersededItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = rule_supersedence)]
#[holder(generate_deserialize)]
pub struct RuleSupersedence {
    #[holder(use_place_holder)]
    #[holder(supertype = "action")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "action")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "action")]
    pub chosen_method: ActionMethodAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = ruled_surface_swept_area_solid)]
#[holder(generate_deserialize)]
pub struct RuledSurfaceSweptAreaSolid {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "swept_area_solid")]
    pub swept_area: CurveBoundedSurface,
    #[holder(use_place_holder)]
    #[holder(supertype = "surface_curve_swept_area_solid")]
    pub directrix: CurveAny,
    #[holder(supertype = "surface_curve_swept_area_solid")]
    pub start_param: f64,
    #[holder(supertype = "surface_curve_swept_area_solid")]
    pub end_param: f64,
    #[holder(use_place_holder)]
    #[holder(supertype = "surface_curve_swept_area_solid")]
    pub reference_surface: SurfaceAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = runout_zone_definition)]
#[holder(generate_deserialize)]
pub struct RunoutZoneDefinition {
    #[holder(use_place_holder)]
    #[holder(supertype = "tolerance_zone_definition")]
    pub zone: ToleranceZone,
    #[holder(use_place_holder)]
    #[holder(supertype = "tolerance_zone_definition")]
    pub boundaries: Vec<ShapeAspectAny>,
    #[holder(use_place_holder)]
    pub orientation: RunoutZoneOrientationAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = runout_zone_orientation)]
#[holder(generate_deserialize)]
pub struct RunoutZoneOrientation {
    #[holder(use_place_holder)]
    pub angle: MeasureWithUnitAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum RunoutZoneOrientationAny {
    #[holder(use_place_holder)]
    RunoutZoneOrientation(Box<RunoutZoneOrientation>),
    #[holder(use_place_holder)]
    RunoutZoneOrientationReferenceDirection(Box<RunoutZoneOrientationReferenceDirection>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = runout_zone_orientation_reference_direction)]
#[holder(generate_deserialize)]
pub struct RunoutZoneOrientationReferenceDirection {
    #[holder(use_place_holder)]
    #[holder(supertype = "runout_zone_orientation")]
    pub angle: MeasureWithUnitAny,
    #[holder(use_place_holder)]
    pub orientation_defining_relationship: ShapeAspectRelationshipAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = satisfied_requirement)]
#[holder(generate_deserialize)]
pub struct SatisfiedRequirement {
    #[holder(use_place_holder)]
    #[holder(supertype = "group_assignment")]
    pub assigned_group: GroupAny,
    #[holder(use_place_holder)]
    pub items: Vec<ProductDefinitionAny>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = satisfies_requirement)]
#[holder(generate_deserialize)]
pub struct SatisfiesRequirement {
    #[holder(use_place_holder)]
    #[holder(supertype = "group")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "group")]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = satisfying_item)]
#[holder(generate_deserialize)]
pub struct SatisfyingItem {
    #[holder(use_place_holder)]
    #[holder(supertype = "group_assignment")]
    pub assigned_group: GroupAny,
    #[holder(use_place_holder)]
    pub items: Vec<RequirementSatisfactionItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = scalar_variable)]
#[holder(generate_deserialize)]
pub struct ScalarVariable {
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition")]
    pub definition: CharacterizedDefinition,
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition_representation")]
    pub used_representation: RepresentationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = scattering_parameter)]
#[holder(generate_deserialize)]
pub struct ScatteringParameter {
    #[holder(supertype = "polar_complex_number_literal")]
    pub radius: f64,
    #[holder(supertype = "polar_complex_number_literal")]
    pub angle: f64,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = sculptured_solid)]
#[holder(generate_deserialize)]
pub struct SculpturedSolid {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    pub sculpturing_element: GeneralizedSurfaceSelect,
    pub positive_side: bool,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = seam_curve)]
#[holder(generate_deserialize)]
pub struct SeamCurve {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "surface_curve")]
    pub curve_3d: CurveAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "surface_curve")]
    pub associated_geometry: Vec<PcurveOrSurface>,
    #[holder(supertype = "surface_curve")]
    pub master_representation: PreferredSurfaceCurveRepresentation,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = security_classification)]
#[holder(generate_deserialize)]
pub struct SecurityClassification {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub purpose: Text,
    #[holder(use_place_holder)]
    pub security_level: SecurityClassificationLevel,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = security_classification_assignment)]
#[holder(generate_deserialize)]
pub struct SecurityClassificationAssignment {
    #[holder(use_place_holder)]
    pub assigned_security_classification: SecurityClassification,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum SecurityClassificationAssignmentAny {
    #[holder(use_place_holder)]
    SecurityClassificationAssignment(Box<SecurityClassificationAssignment>),
    #[holder(use_place_holder)]
    AppliedSecurityClassificationAssignment(Box<AppliedSecurityClassificationAssignment>),
    #[holder(use_place_holder)]
    CcDesignSecurityClassification(Box<CcDesignSecurityClassification>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = security_classification_level)]
#[holder(generate_deserialize)]
pub struct SecurityClassificationLevel {
    #[holder(use_place_holder)]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = serial_numbered_effectivity)]
#[holder(generate_deserialize)]
pub struct SerialNumberedEffectivity {
    #[holder(use_place_holder)]
    #[holder(supertype = "effectivity")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    pub effectivity_start_id: Identifier,
    #[holder(use_place_holder)]
    pub effectivity_end_id: Option<Identifier>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = shape_aspect)]
#[holder(generate_deserialize)]
pub struct ShapeAspect {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub of_shape: ProductDefinitionShape,
    pub product_definitional: Logical,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ShapeAspectAny {
    #[holder(use_place_holder)]
    ShapeAspect(Box<ShapeAspect>),
    #[holder(use_place_holder)]
    CompositeShapeAspect(Box<CompositeShapeAspectAny>),
    #[holder(use_place_holder)]
    Datum(Box<DatumAny>),
    #[holder(use_place_holder)]
    DatumFeature(Box<DatumFeature>),
    #[holder(use_place_holder)]
    DatumTarget(Box<DatumTargetAny>),
    #[holder(use_place_holder)]
    DerivedShapeAspect(Box<DerivedShapeAspectAny>),
    #[holder(use_place_holder)]
    InstancedFeature(Box<InstancedFeature>),
    #[holder(use_place_holder)]
    PlacedFeature(Box<PlacedFeature>),
    #[holder(use_place_holder)]
    SymmetricShapeAspect(Box<SymmetricShapeAspect>),
    #[holder(use_place_holder)]
    ToleranceZone(Box<ToleranceZone>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = shape_aspect_associativity)]
#[holder(generate_deserialize)]
pub struct ShapeAspectAssociativity {
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect_relationship")]
    pub relating_shape_aspect: ShapeAspectAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect_relationship")]
    pub related_shape_aspect: ShapeAspectAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = shape_aspect_deriving_relationship)]
#[holder(generate_deserialize)]
pub struct ShapeAspectDerivingRelationship {
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect_relationship")]
    pub relating_shape_aspect: ShapeAspectAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect_relationship")]
    pub related_shape_aspect: ShapeAspectAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = shape_aspect_relationship)]
#[holder(generate_deserialize)]
pub struct ShapeAspectRelationship {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub relating_shape_aspect: ShapeAspectAny,
    #[holder(use_place_holder)]
    pub related_shape_aspect: ShapeAspectAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ShapeAspectRelationshipAny {
    #[holder(use_place_holder)]
    ShapeAspectRelationship(Box<ShapeAspectRelationship>),
    #[holder(use_place_holder)]
    DimensionalLocation(Box<DimensionalLocationAny>),
    #[holder(use_place_holder)]
    ShapeAspectAssociativity(Box<ShapeAspectAssociativity>),
    #[holder(use_place_holder)]
    ShapeAspectDerivingRelationship(Box<ShapeAspectDerivingRelationship>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = shape_definition_representation)]
#[holder(generate_deserialize)]
pub struct ShapeDefinitionRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition_representation")]
    pub definition: RepresentedDefinition,
    #[holder(use_place_holder)]
    #[holder(supertype = "property_definition_representation")]
    pub used_representation: RepresentationAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = shape_dimension_representation)]
#[holder(generate_deserialize)]
pub struct ShapeDimensionRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = shape_feature_definition)]
#[holder(generate_deserialize)]
pub struct ShapeFeatureDefinition {
    #[holder(use_place_holder)]
    #[holder(supertype = "characterized_object")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "characterized_object")]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ShapeFeatureDefinitionAny {
    #[holder(use_place_holder)]
    ShapeFeatureDefinition(Box<ShapeFeatureDefinition>),
    #[holder(use_place_holder)]
    InstancedFeature(Box<InstancedFeature>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = shape_representation)]
#[holder(generate_deserialize)]
pub struct ShapeRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ShapeRepresentationAny {
    #[holder(use_place_holder)]
    ShapeRepresentation(Box<ShapeRepresentation>),
    #[holder(use_place_holder)]
    AdvancedBrepShapeRepresentation(Box<AdvancedBrepShapeRepresentation>),
    #[holder(use_place_holder)]
    BeveledSheetRepresentation(Box<BeveledSheetRepresentation>),
    #[holder(use_place_holder)]
    CompositeSheetRepresentation(Box<CompositeSheetRepresentation>),
    #[holder(use_place_holder)]
    CompoundShapeRepresentation(Box<CompoundShapeRepresentation>),
    #[holder(use_place_holder)]
    CsgShapeRepresentation(Box<CsgShapeRepresentation>),
    #[holder(use_place_holder)]
    CurveSweptSolidShapeRepresentation(Box<CurveSweptSolidShapeRepresentation>),
    #[holder(use_place_holder)]
    EdgeBasedWireframeShapeRepresentation(Box<EdgeBasedWireframeShapeRepresentation>),
    #[holder(use_place_holder)]
    ElementaryBrepShapeRepresentation(Box<ElementaryBrepShapeRepresentation>),
    #[holder(use_place_holder)]
    FacetedBrepShapeRepresentation(Box<FacetedBrepShapeRepresentation>),
    #[holder(use_place_holder)]
    GeometricallyBounded2DWireframeRepresentation(
        Box<GeometricallyBounded2DWireframeRepresentation>,
    ),
    #[holder(use_place_holder)]
    GeometricallyBoundedSurfaceShapeRepresentation(
        Box<GeometricallyBoundedSurfaceShapeRepresentation>,
    ),
    #[holder(use_place_holder)]
    GeometricallyBoundedWireframeShapeRepresentation(
        Box<GeometricallyBoundedWireframeShapeRepresentation>,
    ),
    #[holder(use_place_holder)]
    ManifoldSubsurfaceShapeRepresentation(Box<ManifoldSubsurfaceShapeRepresentation>),
    #[holder(use_place_holder)]
    ManifoldSurfaceShapeRepresentation(Box<ManifoldSurfaceShapeRepresentation>),
    #[holder(use_place_holder)]
    NonManifoldSurfaceShapeRepresentation(Box<NonManifoldSurfaceShapeRepresentation>),
    #[holder(use_place_holder)]
    ProceduralShapeRepresentation(Box<ProceduralShapeRepresentation>),
    #[holder(use_place_holder)]
    ShapeDimensionRepresentation(Box<ShapeDimensionRepresentation>),
    #[holder(use_place_holder)]
    ShapeRepresentationWithParameters(Box<ShapeRepresentationWithParameters>),
    #[holder(use_place_holder)]
    ShellBasedWireframeShapeRepresentation(Box<ShellBasedWireframeShapeRepresentation>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = shape_representation_relationship)]
#[holder(generate_deserialize)]
pub struct ShapeRepresentationRelationship {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub rep_1: RepresentationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_relationship")]
    pub rep_2: RepresentationAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ShapeRepresentationRelationshipAny {
    #[holder(use_place_holder)]
    ShapeRepresentationRelationship(Box<ShapeRepresentationRelationship>),
    #[holder(use_place_holder)]
    FlatPatternPlyRepresentationRelationship(Box<FlatPatternPlyRepresentationRelationship>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = shape_representation_with_parameters)]
#[holder(generate_deserialize)]
pub struct ShapeRepresentationWithParameters {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = shell_based_surface_model)]
#[holder(generate_deserialize)]
pub struct ShellBasedSurfaceModel {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub sbsm_boundary: Vec<Shell>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = shell_based_wireframe_model)]
#[holder(generate_deserialize)]
pub struct ShellBasedWireframeModel {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub sbwm_boundary: Vec<Shell>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = shell_based_wireframe_shape_representation)]
#[holder(generate_deserialize)]
pub struct ShellBasedWireframeShapeRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = shelled_solid)]
#[holder(generate_deserialize)]
pub struct ShelledSolid {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    pub deleted_face_set: Vec<FaceSurfaceAny>,
    #[holder(use_place_holder)]
    pub thickness: LengthMeasure,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ShelledSolidAny {
    #[holder(use_place_holder)]
    ShelledSolid(Box<ShelledSolid>),
    #[holder(use_place_holder)]
    ComplexShelledSolid(Box<ComplexShelledSolid>),
    #[holder(use_place_holder)]
    DoubleOffsetShelledSolid(Box<DoubleOffsetShelledSolid>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = si_absorbed_dose_unit)]
#[holder(generate_deserialize)]
pub struct SiAbsorbedDoseUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
    #[holder(use_place_holder)]
    #[holder(supertype = "named_unit")]
    pub dimensions: DimensionalExponents,
    #[holder(supertype = "si_unit")]
    pub prefix: Option<SiPrefix>,
    #[holder(supertype = "si_unit")]
    pub name: SiUnitName,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = si_capacitance_unit)]
#[holder(generate_deserialize)]
pub struct SiCapacitanceUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
    #[holder(use_place_holder)]
    #[holder(supertype = "named_unit")]
    pub dimensions: DimensionalExponents,
    #[holder(supertype = "si_unit")]
    pub prefix: Option<SiPrefix>,
    #[holder(supertype = "si_unit")]
    pub name: SiUnitName,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = si_conductance_unit)]
#[holder(generate_deserialize)]
pub struct SiConductanceUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
    #[holder(use_place_holder)]
    #[holder(supertype = "named_unit")]
    pub dimensions: DimensionalExponents,
    #[holder(supertype = "si_unit")]
    pub prefix: Option<SiPrefix>,
    #[holder(supertype = "si_unit")]
    pub name: SiUnitName,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = si_dose_equivalent_unit)]
#[holder(generate_deserialize)]
pub struct SiDoseEquivalentUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
    #[holder(use_place_holder)]
    #[holder(supertype = "named_unit")]
    pub dimensions: DimensionalExponents,
    #[holder(supertype = "si_unit")]
    pub prefix: Option<SiPrefix>,
    #[holder(supertype = "si_unit")]
    pub name: SiUnitName,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = si_electric_charge_unit)]
#[holder(generate_deserialize)]
pub struct SiElectricChargeUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
    #[holder(use_place_holder)]
    #[holder(supertype = "named_unit")]
    pub dimensions: DimensionalExponents,
    #[holder(supertype = "si_unit")]
    pub prefix: Option<SiPrefix>,
    #[holder(supertype = "si_unit")]
    pub name: SiUnitName,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = si_electric_potential_unit)]
#[holder(generate_deserialize)]
pub struct SiElectricPotentialUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
    #[holder(use_place_holder)]
    #[holder(supertype = "named_unit")]
    pub dimensions: DimensionalExponents,
    #[holder(supertype = "si_unit")]
    pub prefix: Option<SiPrefix>,
    #[holder(supertype = "si_unit")]
    pub name: SiUnitName,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = si_energy_unit)]
#[holder(generate_deserialize)]
pub struct SiEnergyUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
    #[holder(use_place_holder)]
    #[holder(supertype = "named_unit")]
    pub dimensions: DimensionalExponents,
    #[holder(supertype = "si_unit")]
    pub prefix: Option<SiPrefix>,
    #[holder(supertype = "si_unit")]
    pub name: SiUnitName,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = si_force_unit)]
#[holder(generate_deserialize)]
pub struct SiForceUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
    #[holder(use_place_holder)]
    #[holder(supertype = "named_unit")]
    pub dimensions: DimensionalExponents,
    #[holder(supertype = "si_unit")]
    pub prefix: Option<SiPrefix>,
    #[holder(supertype = "si_unit")]
    pub name: SiUnitName,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = si_frequency_unit)]
#[holder(generate_deserialize)]
pub struct SiFrequencyUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
    #[holder(use_place_holder)]
    #[holder(supertype = "named_unit")]
    pub dimensions: DimensionalExponents,
    #[holder(supertype = "si_unit")]
    pub prefix: Option<SiPrefix>,
    #[holder(supertype = "si_unit")]
    pub name: SiUnitName,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = si_illuminance_unit)]
#[holder(generate_deserialize)]
pub struct SiIlluminanceUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
    #[holder(use_place_holder)]
    #[holder(supertype = "named_unit")]
    pub dimensions: DimensionalExponents,
    #[holder(supertype = "si_unit")]
    pub prefix: Option<SiPrefix>,
    #[holder(supertype = "si_unit")]
    pub name: SiUnitName,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = si_inductance_unit)]
#[holder(generate_deserialize)]
pub struct SiInductanceUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
    #[holder(use_place_holder)]
    #[holder(supertype = "named_unit")]
    pub dimensions: DimensionalExponents,
    #[holder(supertype = "si_unit")]
    pub prefix: Option<SiPrefix>,
    #[holder(supertype = "si_unit")]
    pub name: SiUnitName,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = si_magnetic_flux_density_unit)]
#[holder(generate_deserialize)]
pub struct SiMagneticFluxDensityUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
    #[holder(use_place_holder)]
    #[holder(supertype = "named_unit")]
    pub dimensions: DimensionalExponents,
    #[holder(supertype = "si_unit")]
    pub prefix: Option<SiPrefix>,
    #[holder(supertype = "si_unit")]
    pub name: SiUnitName,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = si_magnetic_flux_unit)]
#[holder(generate_deserialize)]
pub struct SiMagneticFluxUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
    #[holder(use_place_holder)]
    #[holder(supertype = "named_unit")]
    pub dimensions: DimensionalExponents,
    #[holder(supertype = "si_unit")]
    pub prefix: Option<SiPrefix>,
    #[holder(supertype = "si_unit")]
    pub name: SiUnitName,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = si_power_unit)]
#[holder(generate_deserialize)]
pub struct SiPowerUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
    #[holder(use_place_holder)]
    #[holder(supertype = "named_unit")]
    pub dimensions: DimensionalExponents,
    #[holder(supertype = "si_unit")]
    pub prefix: Option<SiPrefix>,
    #[holder(supertype = "si_unit")]
    pub name: SiUnitName,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = si_pressure_unit)]
#[holder(generate_deserialize)]
pub struct SiPressureUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
    #[holder(use_place_holder)]
    #[holder(supertype = "named_unit")]
    pub dimensions: DimensionalExponents,
    #[holder(supertype = "si_unit")]
    pub prefix: Option<SiPrefix>,
    #[holder(supertype = "si_unit")]
    pub name: SiUnitName,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = si_radioactivity_unit)]
#[holder(generate_deserialize)]
pub struct SiRadioactivityUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
    #[holder(use_place_holder)]
    #[holder(supertype = "named_unit")]
    pub dimensions: DimensionalExponents,
    #[holder(supertype = "si_unit")]
    pub prefix: Option<SiPrefix>,
    #[holder(supertype = "si_unit")]
    pub name: SiUnitName,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = si_resistance_unit)]
#[holder(generate_deserialize)]
pub struct SiResistanceUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
    #[holder(use_place_holder)]
    #[holder(supertype = "named_unit")]
    pub dimensions: DimensionalExponents,
    #[holder(supertype = "si_unit")]
    pub prefix: Option<SiPrefix>,
    #[holder(supertype = "si_unit")]
    pub name: SiUnitName,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = si_unit)]
#[holder(generate_deserialize)]
pub struct SiUnit {
    #[holder(derived)]
    #[holder(supertype = "named_unit")]
    pub dimensions: Derived<DimensionalExponents>,
    pub prefix: Option<SiPrefix>,
    pub name: SiUnitName,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum SiUnitAny {
    #[holder(use_place_holder)]
    SiUnit(Box<SiUnit>),
    #[holder(use_place_holder)]
    SiAbsorbedDoseUnit(Box<SiAbsorbedDoseUnit>),
    #[holder(use_place_holder)]
    SiCapacitanceUnit(Box<SiCapacitanceUnit>),
    #[holder(use_place_holder)]
    SiConductanceUnit(Box<SiConductanceUnit>),
    #[holder(use_place_holder)]
    SiDoseEquivalentUnit(Box<SiDoseEquivalentUnit>),
    #[holder(use_place_holder)]
    SiElectricChargeUnit(Box<SiElectricChargeUnit>),
    #[holder(use_place_holder)]
    SiElectricPotentialUnit(Box<SiElectricPotentialUnit>),
    #[holder(use_place_holder)]
    SiEnergyUnit(Box<SiEnergyUnit>),
    #[holder(use_place_holder)]
    SiForceUnit(Box<SiForceUnit>),
    #[holder(use_place_holder)]
    SiFrequencyUnit(Box<SiFrequencyUnit>),
    #[holder(use_place_holder)]
    SiIlluminanceUnit(Box<SiIlluminanceUnit>),
    #[holder(use_place_holder)]
    SiInductanceUnit(Box<SiInductanceUnit>),
    #[holder(use_place_holder)]
    SiMagneticFluxDensityUnit(Box<SiMagneticFluxDensityUnit>),
    #[holder(use_place_holder)]
    SiMagneticFluxUnit(Box<SiMagneticFluxUnit>),
    #[holder(use_place_holder)]
    SiPowerUnit(Box<SiPowerUnit>),
    #[holder(use_place_holder)]
    SiPressureUnit(Box<SiPressureUnit>),
    #[holder(use_place_holder)]
    SiRadioactivityUnit(Box<SiRadioactivityUnit>),
    #[holder(use_place_holder)]
    SiResistanceUnit(Box<SiResistanceUnit>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = simple_boolean_expression)]
#[holder(generate_deserialize)]
pub struct SimpleBooleanExpression {}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum SimpleBooleanExpressionAny {
    #[holder(use_place_holder)]
    SimpleBooleanExpression(Box<SimpleBooleanExpression>),
    #[holder(use_place_holder)]
    BooleanLiteral(Box<BooleanLiteralAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = simple_clause)]
#[holder(generate_deserialize)]
pub struct SimpleClause {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "compound_representation_item")]
    pub item_element: CompoundItemDefinition,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum SimpleClauseAny {
    #[holder(use_place_holder)]
    SimpleClause(Box<SimpleClause>),
    #[holder(use_place_holder)]
    LiteralConjunction(Box<LiteralConjunction>),
    #[holder(use_place_holder)]
    LiteralDisjunction(Box<LiteralDisjunction>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = simple_generic_expression)]
#[holder(generate_deserialize)]
pub struct SimpleGenericExpression {}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum SimpleGenericExpressionAny {
    #[holder(use_place_holder)]
    SimpleGenericExpression(Box<SimpleGenericExpression>),
    #[holder(use_place_holder)]
    GenericLiteral(Box<GenericLiteralAny>),
    #[holder(use_place_holder)]
    GenericVariable(Box<GenericVariable>),
    #[holder(use_place_holder)]
    SimpleBooleanExpression(Box<SimpleBooleanExpressionAny>),
    #[holder(use_place_holder)]
    SimpleNumericExpression(Box<SimpleNumericExpressionAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = simple_numeric_expression)]
#[holder(generate_deserialize)]
pub struct SimpleNumericExpression {}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum SimpleNumericExpressionAny {
    #[holder(use_place_holder)]
    SimpleNumericExpression(Box<SimpleNumericExpression>),
    #[holder(use_place_holder)]
    LiteralNumber(Box<LiteralNumberAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = slash_expression)]
#[holder(generate_deserialize)]
pub struct SlashExpression {
    #[holder(use_place_holder)]
    #[holder(supertype = "binary_generic_expression")]
    pub operands: Vec<GenericExpressionAny>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum SlashExpressionAny {
    #[holder(use_place_holder)]
    SlashExpression(Box<SlashExpression>),
    #[holder(use_place_holder)]
    RationalRepresentationItem(Box<RationalRepresentationItem>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = smeared_material_definition)]
#[holder(generate_deserialize)]
pub struct SmearedMaterialDefinition {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub formation: ProductDefinitionFormationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub frame_of_reference: ProductDefinitionContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_angle_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct SolidAngleMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_angle_unit)]
#[holder(generate_deserialize)]
pub struct SolidAngleUnit {
    #[holder(derived)]
    #[holder(supertype = "named_unit")]
    pub dimensions: Derived<DimensionalExponents>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_curve_font)]
#[holder(generate_deserialize)]
pub struct SolidCurveFont {
    #[holder(use_place_holder)]
    #[holder(supertype = "pre_defined_item")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_model)]
#[holder(generate_deserialize)]
pub struct SolidModel {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum SolidModelAny {
    #[holder(use_place_holder)]
    SolidModel(Box<SolidModel>),
    #[holder(use_place_holder)]
    CsgSolid(Box<CsgSolid>),
    #[holder(use_place_holder)]
    ManifoldSolidBrep(Box<ManifoldSolidBrepAny>),
    #[holder(use_place_holder)]
    ModifiedSolid(Box<ModifiedSolidAny>),
    #[holder(use_place_holder)]
    SolidReplica(Box<SolidReplica>),
    #[holder(use_place_holder)]
    SweptAreaSolid(Box<SweptAreaSolidAny>),
    #[holder(use_place_holder)]
    SweptDiskSolid(Box<SweptDiskSolid>),
    #[holder(use_place_holder)]
    SweptFaceSolid(Box<SweptFaceSolidAny>),
    #[holder(use_place_holder)]
    ThickenedFaceSolid(Box<ThickenedFaceSolid>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_replica)]
#[holder(generate_deserialize)]
pub struct SolidReplica {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub parent_solid: SolidModelAny,
    #[holder(use_place_holder)]
    pub transformation: CartesianTransformationOperator3D,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_with_angle_based_chamfer)]
#[holder(generate_deserialize)]
pub struct SolidWithAngleBasedChamfer {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "edge_blended_solid")]
    pub blended_edges: Vec<EdgeCurve>,
    #[holder(use_place_holder)]
    pub offset_distance: PositiveLengthMeasure,
    pub left_offset: bool,
    #[holder(use_place_holder)]
    pub offset_angle: PositivePlaneAngleMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_with_chamfered_edges)]
#[holder(generate_deserialize)]
pub struct SolidWithChamferedEdges {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "edge_blended_solid")]
    pub blended_edges: Vec<EdgeCurve>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum SolidWithChamferedEdgesAny {
    #[holder(use_place_holder)]
    SolidWithChamferedEdges(Box<SolidWithChamferedEdges>),
    #[holder(use_place_holder)]
    SolidWithAngleBasedChamfer(Box<SolidWithAngleBasedChamfer>),
    #[holder(use_place_holder)]
    SolidWithDoubleOffsetChamfer(Box<SolidWithDoubleOffsetChamfer>),
    #[holder(use_place_holder)]
    SolidWithSingleOffsetChamfer(Box<SolidWithSingleOffsetChamfer>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_with_circular_pattern)]
#[holder(generate_deserialize)]
pub struct SolidWithCircularPattern {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid_with_placed_configuration")]
    pub placing: Axis2Placement3D,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_shape_element_pattern")]
    pub replicated_element: ModifiedSolidWithPlacedConfigurationAny,
    #[holder(use_place_holder)]
    pub replicate_count: PositiveInteger,
    #[holder(use_place_holder)]
    pub angular_spacing: PlaneAngleMeasure,
    pub radial_alignment: bool,
    #[holder(use_place_holder)]
    pub reference_point: PointAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum SolidWithCircularPatternAny {
    #[holder(use_place_holder)]
    SolidWithCircularPattern(Box<SolidWithCircularPattern>),
    #[holder(use_place_holder)]
    SolidWithIncompleteCircularPattern(Box<SolidWithIncompleteCircularPattern>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_with_circular_pocket)]
#[holder(generate_deserialize)]
pub struct SolidWithCircularPocket {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid_with_placed_configuration")]
    pub placing: Axis2Placement3D,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_depression")]
    pub depth: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_pocket")]
    pub floor_blend_radius: NonNegativeLengthMeasure,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_pocket")]
    pub draft_angle: PlaneAngleMeasure,
    #[holder(use_place_holder)]
    pub pocket_radius: PositiveLengthMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_with_circular_protrusion)]
#[holder(generate_deserialize)]
pub struct SolidWithCircularProtrusion {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid_with_placed_configuration")]
    pub placing: Axis2Placement3D,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_protrusion")]
    pub protrusion_height: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_protrusion")]
    pub protrusion_draft_angle: PlaneAngleMeasure,
    #[holder(use_place_holder)]
    pub protrusion_radius: PositiveLengthMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_with_conical_bottom_round_hole)]
#[holder(generate_deserialize)]
pub struct SolidWithConicalBottomRoundHole {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid_with_placed_configuration")]
    pub placing: Axis2Placement3D,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_depression")]
    pub depth: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_stepped_round_hole")]
    pub segments: PositiveInteger,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_stepped_round_hole")]
    pub segment_radii: Vec<PositiveLengthMeasure>,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_stepped_round_hole")]
    pub segment_depths: Vec<PositiveLengthMeasure>,
    #[holder(use_place_holder)]
    pub semi_apex_angle: PositivePlaneAngleMeasure,
    #[holder(use_place_holder)]
    pub tip_radius: NonNegativeLengthMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_with_constant_radius_edge_blend)]
#[holder(generate_deserialize)]
pub struct SolidWithConstantRadiusEdgeBlend {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "edge_blended_solid")]
    pub blended_edges: Vec<EdgeCurve>,
    #[holder(use_place_holder)]
    pub radius: PositiveLengthMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_with_curved_slot)]
#[holder(generate_deserialize)]
pub struct SolidWithCurvedSlot {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid_with_placed_configuration")]
    pub placing: Axis2Placement3D,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_depression")]
    pub depth: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_slot")]
    pub slot_width: PositiveLengthMeasure,
    #[holder(supertype = "solid_with_slot")]
    pub closed_ends: Vec<Logical>,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_slot")]
    pub end_exit_faces: Vec<Vec<FaceSurfaceAny>>,
    #[holder(use_place_holder)]
    pub slot_centreline: BoundedCurveAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_with_depression)]
#[holder(generate_deserialize)]
pub struct SolidWithDepression {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid_with_placed_configuration")]
    pub placing: Axis2Placement3D,
    #[holder(use_place_holder)]
    pub depth: PositiveLengthMeasure,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum SolidWithDepressionAny {
    #[holder(use_place_holder)]
    SolidWithDepression(Box<SolidWithDepression>),
    #[holder(use_place_holder)]
    SolidWithGroove(Box<SolidWithGroove>),
    #[holder(use_place_holder)]
    SolidWithHole(Box<SolidWithHoleAny>),
    #[holder(use_place_holder)]
    SolidWithPocket(Box<SolidWithPocketAny>),
    #[holder(use_place_holder)]
    SolidWithSlot(Box<SolidWithSlotAny>),
    #[holder(use_place_holder)]
    SolidWithThroughDepression(Box<SolidWithThroughDepression>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_with_double_offset_chamfer)]
#[holder(generate_deserialize)]
pub struct SolidWithDoubleOffsetChamfer {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "edge_blended_solid")]
    pub blended_edges: Vec<EdgeCurve>,
    #[holder(use_place_holder)]
    pub left_offset_distance: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    pub right_offset_distance: PositiveLengthMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_with_flat_bottom_round_hole)]
#[holder(generate_deserialize)]
pub struct SolidWithFlatBottomRoundHole {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid_with_placed_configuration")]
    pub placing: Axis2Placement3D,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_depression")]
    pub depth: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_stepped_round_hole")]
    pub segments: PositiveInteger,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_stepped_round_hole")]
    pub segment_radii: Vec<PositiveLengthMeasure>,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_stepped_round_hole")]
    pub segment_depths: Vec<PositiveLengthMeasure>,
    #[holder(use_place_holder)]
    pub fillet_radius: NonNegativeLengthMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_with_general_pocket)]
#[holder(generate_deserialize)]
pub struct SolidWithGeneralPocket {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid_with_placed_configuration")]
    pub placing: Axis2Placement3D,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_depression")]
    pub depth: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_pocket")]
    pub floor_blend_radius: NonNegativeLengthMeasure,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_pocket")]
    pub draft_angle: PlaneAngleMeasure,
    #[holder(use_place_holder)]
    pub profile: PositionedSketch,
    #[holder(use_place_holder)]
    pub reference_point: PointAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_with_general_protrusion)]
#[holder(generate_deserialize)]
pub struct SolidWithGeneralProtrusion {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid_with_placed_configuration")]
    pub placing: Axis2Placement3D,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_protrusion")]
    pub protrusion_height: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_protrusion")]
    pub protrusion_draft_angle: PlaneAngleMeasure,
    #[holder(use_place_holder)]
    pub profile: PositionedSketch,
    #[holder(use_place_holder)]
    pub reference_point: PointAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_with_groove)]
#[holder(generate_deserialize)]
pub struct SolidWithGroove {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid_with_placed_configuration")]
    pub placing: Axis2Placement3D,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_depression")]
    pub depth: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    pub groove_radius: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    pub groove_width: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    pub draft_angle: PlaneAngleMeasure,
    #[holder(use_place_holder)]
    pub floor_fillet_radius: NonNegativeLengthMeasure,
    pub external_groove: bool,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_with_hole)]
#[holder(generate_deserialize)]
pub struct SolidWithHole {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid_with_placed_configuration")]
    pub placing: Axis2Placement3D,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_depression")]
    pub depth: PositiveLengthMeasure,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum SolidWithHoleAny {
    #[holder(use_place_holder)]
    SolidWithHole(Box<SolidWithHole>),
    #[holder(use_place_holder)]
    SolidWithSteppedRoundHole(Box<SolidWithSteppedRoundHoleAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_with_incomplete_circular_pattern)]
#[holder(generate_deserialize)]
pub struct SolidWithIncompleteCircularPattern {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid_with_placed_configuration")]
    pub placing: Axis2Placement3D,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_shape_element_pattern")]
    pub replicated_element: ModifiedSolidWithPlacedConfigurationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_circular_pattern")]
    pub replicate_count: PositiveInteger,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_circular_pattern")]
    pub angular_spacing: PlaneAngleMeasure,
    #[holder(supertype = "solid_with_circular_pattern")]
    pub radial_alignment: bool,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_circular_pattern")]
    pub reference_point: PointAny,
    #[holder(use_place_holder)]
    pub omitted_instances: Vec<PositiveInteger>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_with_incomplete_rectangular_pattern)]
#[holder(generate_deserialize)]
pub struct SolidWithIncompleteRectangularPattern {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid_with_placed_configuration")]
    pub placing: Axis2Placement3D,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_shape_element_pattern")]
    pub replicated_element: ModifiedSolidWithPlacedConfigurationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_rectangular_pattern")]
    pub row_count: PositiveInteger,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_rectangular_pattern")]
    pub column_count: PositiveInteger,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_rectangular_pattern")]
    pub row_spacing: LengthMeasure,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_rectangular_pattern")]
    pub column_spacing: LengthMeasure,
    #[holder(use_place_holder)]
    pub omitted_instances: Vec<Vec<PositiveInteger>>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_with_pocket)]
#[holder(generate_deserialize)]
pub struct SolidWithPocket {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid_with_placed_configuration")]
    pub placing: Axis2Placement3D,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_depression")]
    pub depth: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    pub floor_blend_radius: NonNegativeLengthMeasure,
    #[holder(use_place_holder)]
    pub draft_angle: PlaneAngleMeasure,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum SolidWithPocketAny {
    #[holder(use_place_holder)]
    SolidWithPocket(Box<SolidWithPocket>),
    #[holder(use_place_holder)]
    SolidWithCircularPocket(Box<SolidWithCircularPocket>),
    #[holder(use_place_holder)]
    SolidWithGeneralPocket(Box<SolidWithGeneralPocket>),
    #[holder(use_place_holder)]
    SolidWithRectangularPocket(Box<SolidWithRectangularPocket>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_with_protrusion)]
#[holder(generate_deserialize)]
pub struct SolidWithProtrusion {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid_with_placed_configuration")]
    pub placing: Axis2Placement3D,
    #[holder(use_place_holder)]
    pub protrusion_height: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    pub protrusion_draft_angle: PlaneAngleMeasure,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum SolidWithProtrusionAny {
    #[holder(use_place_holder)]
    SolidWithProtrusion(Box<SolidWithProtrusion>),
    #[holder(use_place_holder)]
    SolidWithCircularProtrusion(Box<SolidWithCircularProtrusion>),
    #[holder(use_place_holder)]
    SolidWithGeneralProtrusion(Box<SolidWithGeneralProtrusion>),
    #[holder(use_place_holder)]
    SolidWithRectangularProtrusion(Box<SolidWithRectangularProtrusion>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_with_rectangular_pattern)]
#[holder(generate_deserialize)]
pub struct SolidWithRectangularPattern {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid_with_placed_configuration")]
    pub placing: Axis2Placement3D,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_shape_element_pattern")]
    pub replicated_element: ModifiedSolidWithPlacedConfigurationAny,
    #[holder(use_place_holder)]
    pub row_count: PositiveInteger,
    #[holder(use_place_holder)]
    pub column_count: PositiveInteger,
    #[holder(use_place_holder)]
    pub row_spacing: LengthMeasure,
    #[holder(use_place_holder)]
    pub column_spacing: LengthMeasure,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum SolidWithRectangularPatternAny {
    #[holder(use_place_holder)]
    SolidWithRectangularPattern(Box<SolidWithRectangularPattern>),
    #[holder(use_place_holder)]
    SolidWithIncompleteRectangularPattern(Box<SolidWithIncompleteRectangularPattern>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_with_rectangular_pocket)]
#[holder(generate_deserialize)]
pub struct SolidWithRectangularPocket {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid_with_placed_configuration")]
    pub placing: Axis2Placement3D,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_depression")]
    pub depth: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_pocket")]
    pub floor_blend_radius: NonNegativeLengthMeasure,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_pocket")]
    pub draft_angle: PlaneAngleMeasure,
    #[holder(use_place_holder)]
    pub pocket_length: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    pub pocket_width: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    pub corner_radius: NonNegativeLengthMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_with_rectangular_protrusion)]
#[holder(generate_deserialize)]
pub struct SolidWithRectangularProtrusion {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid_with_placed_configuration")]
    pub placing: Axis2Placement3D,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_protrusion")]
    pub protrusion_height: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_protrusion")]
    pub protrusion_draft_angle: PlaneAngleMeasure,
    #[holder(use_place_holder)]
    pub protrusion_length: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    pub protrusion_width: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    pub protrusion_corner_radius: NonNegativeLengthMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_with_shape_element_pattern)]
#[holder(generate_deserialize)]
pub struct SolidWithShapeElementPattern {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid_with_placed_configuration")]
    pub placing: Axis2Placement3D,
    #[holder(use_place_holder)]
    pub replicated_element: ModifiedSolidWithPlacedConfigurationAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum SolidWithShapeElementPatternAny {
    #[holder(use_place_holder)]
    SolidWithShapeElementPattern(Box<SolidWithShapeElementPattern>),
    #[holder(use_place_holder)]
    SolidWithCircularPattern(Box<SolidWithCircularPatternAny>),
    #[holder(use_place_holder)]
    SolidWithRectangularPattern(Box<SolidWithRectangularPatternAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_with_single_offset_chamfer)]
#[holder(generate_deserialize)]
pub struct SolidWithSingleOffsetChamfer {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "edge_blended_solid")]
    pub blended_edges: Vec<EdgeCurve>,
    #[holder(use_place_holder)]
    pub offset_distance: PositiveLengthMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_with_slot)]
#[holder(generate_deserialize)]
pub struct SolidWithSlot {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid_with_placed_configuration")]
    pub placing: Axis2Placement3D,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_depression")]
    pub depth: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    pub slot_width: PositiveLengthMeasure,
    pub closed_ends: Vec<Logical>,
    #[holder(use_place_holder)]
    pub end_exit_faces: Vec<Vec<FaceSurfaceAny>>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum SolidWithSlotAny {
    #[holder(use_place_holder)]
    SolidWithSlot(Box<SolidWithSlot>),
    #[holder(use_place_holder)]
    SolidWithCurvedSlot(Box<SolidWithCurvedSlot>),
    #[holder(use_place_holder)]
    SolidWithStraightSlot(Box<SolidWithStraightSlot>),
    #[holder(use_place_holder)]
    SolidWithTeeSectionSlot(Box<SolidWithTeeSectionSlot>),
    #[holder(use_place_holder)]
    SolidWithTrapezoidalSectionSlot(Box<SolidWithTrapezoidalSectionSlot>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_with_spherical_bottom_round_hole)]
#[holder(generate_deserialize)]
pub struct SolidWithSphericalBottomRoundHole {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid_with_placed_configuration")]
    pub placing: Axis2Placement3D,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_depression")]
    pub depth: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_stepped_round_hole")]
    pub segments: PositiveInteger,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_stepped_round_hole")]
    pub segment_radii: Vec<PositiveLengthMeasure>,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_stepped_round_hole")]
    pub segment_depths: Vec<PositiveLengthMeasure>,
    #[holder(use_place_holder)]
    pub sphere_radius: PositiveLengthMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_with_stepped_round_hole)]
#[holder(generate_deserialize)]
pub struct SolidWithSteppedRoundHole {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid_with_placed_configuration")]
    pub placing: Axis2Placement3D,
    #[holder(derived)]
    #[holder(supertype = "solid_with_depression")]
    pub depth: Derived<PositiveLengthMeasure>,
    #[holder(use_place_holder)]
    pub segments: PositiveInteger,
    #[holder(use_place_holder)]
    pub segment_radii: Vec<PositiveLengthMeasure>,
    #[holder(use_place_holder)]
    pub segment_depths: Vec<PositiveLengthMeasure>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum SolidWithSteppedRoundHoleAny {
    #[holder(use_place_holder)]
    SolidWithSteppedRoundHole(Box<SolidWithSteppedRoundHole>),
    #[holder(use_place_holder)]
    SolidWithConicalBottomRoundHole(Box<SolidWithConicalBottomRoundHole>),
    #[holder(use_place_holder)]
    SolidWithFlatBottomRoundHole(Box<SolidWithFlatBottomRoundHole>),
    #[holder(use_place_holder)]
    SolidWithSphericalBottomRoundHole(Box<SolidWithSphericalBottomRoundHole>),
    #[holder(use_place_holder)]
    SolidWithSteppedRoundHoleAndConicalTransitions(
        Box<SolidWithSteppedRoundHoleAndConicalTransitions>,
    ),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_with_stepped_round_hole_and_conical_transitions)]
#[holder(generate_deserialize)]
pub struct SolidWithSteppedRoundHoleAndConicalTransitions {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid_with_placed_configuration")]
    pub placing: Axis2Placement3D,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_depression")]
    pub depth: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_stepped_round_hole")]
    pub segments: PositiveInteger,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_stepped_round_hole")]
    pub segment_radii: Vec<PositiveLengthMeasure>,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_stepped_round_hole")]
    pub segment_depths: Vec<PositiveLengthMeasure>,
    #[holder(use_place_holder)]
    pub conical_transitions: Vec<ConicalSteppedHoleTransition>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_with_straight_slot)]
#[holder(generate_deserialize)]
pub struct SolidWithStraightSlot {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid_with_placed_configuration")]
    pub placing: Axis2Placement3D,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_depression")]
    pub depth: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_slot")]
    pub slot_width: PositiveLengthMeasure,
    #[holder(supertype = "solid_with_slot")]
    pub closed_ends: Vec<Logical>,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_slot")]
    pub end_exit_faces: Vec<Vec<FaceSurfaceAny>>,
    #[holder(use_place_holder)]
    pub slot_length: PositiveLengthMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_with_tee_section_slot)]
#[holder(generate_deserialize)]
pub struct SolidWithTeeSectionSlot {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid_with_placed_configuration")]
    pub placing: Axis2Placement3D,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_depression")]
    pub depth: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_slot")]
    pub slot_width: PositiveLengthMeasure,
    #[holder(supertype = "solid_with_slot")]
    pub closed_ends: Vec<Logical>,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_slot")]
    pub end_exit_faces: Vec<Vec<FaceSurfaceAny>>,
    #[holder(use_place_holder)]
    pub tee_section_width: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    pub collar_depth: PositiveLengthMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_with_through_depression)]
#[holder(generate_deserialize)]
pub struct SolidWithThroughDepression {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid_with_placed_configuration")]
    pub placing: Axis2Placement3D,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_depression")]
    pub depth: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    pub exit_faces: Vec<FaceSurfaceAny>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_with_trapezoidal_section_slot)]
#[holder(generate_deserialize)]
pub struct SolidWithTrapezoidalSectionSlot {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid_with_placed_configuration")]
    pub placing: Axis2Placement3D,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_depression")]
    pub depth: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_slot")]
    pub slot_width: PositiveLengthMeasure,
    #[holder(supertype = "solid_with_slot")]
    pub closed_ends: Vec<Logical>,
    #[holder(use_place_holder)]
    #[holder(supertype = "solid_with_slot")]
    pub end_exit_faces: Vec<Vec<FaceSurfaceAny>>,
    #[holder(use_place_holder)]
    pub draft_angle: PlaneAngleMeasure,
    #[holder(use_place_holder)]
    pub floor_fillet_radius: NonNegativeLengthMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = solid_with_variable_radius_edge_blend)]
#[holder(generate_deserialize)]
pub struct SolidWithVariableRadiusEdgeBlend {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "edge_blended_solid")]
    pub blended_edges: Vec<EdgeCurve>,
    #[holder(use_place_holder)]
    pub point_list: Vec<PointAny>,
    #[holder(use_place_holder)]
    pub radius_list: Vec<PositiveLengthMeasure>,
    pub edge_function_list: Vec<BlendRadiusVariationType>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = source_for_requirement)]
#[holder(generate_deserialize)]
pub struct SourceForRequirement {
    #[holder(use_place_holder)]
    #[holder(supertype = "group_assignment")]
    pub assigned_group: GroupAny,
    #[holder(use_place_holder)]
    pub items: Vec<RequirementSourceItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = sourced_requirement)]
#[holder(generate_deserialize)]
pub struct SourcedRequirement {
    #[holder(use_place_holder)]
    #[holder(supertype = "group_assignment")]
    pub assigned_group: GroupAny,
    #[holder(use_place_holder)]
    pub items: Vec<ProductDefinitionAny>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = specification_definition)]
#[holder(generate_deserialize)]
pub struct SpecificationDefinition {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub formation: ProductDefinitionFormationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub frame_of_reference: ProductDefinitionContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = specified_higher_usage_occurrence)]
#[holder(generate_deserialize)]
pub struct SpecifiedHigherUsageOccurrence {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub relating_product_definition: ProductDefinitionAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub related_product_definition: ProductDefinitionAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "assembly_component_usage")]
    pub reference_designator: Option<Identifier>,
    #[holder(use_place_holder)]
    pub upper_usage: AssemblyComponentUsageAny,
    #[holder(use_place_holder)]
    pub next_usage: NextAssemblyUsageOccurrence,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = sphere)]
#[holder(generate_deserialize)]
pub struct Sphere {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub radius: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    pub centre: PointAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = spherical_surface)]
#[holder(generate_deserialize)]
pub struct SphericalSurface {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "elementary_surface")]
    pub position: Axis2Placement3D,
    #[holder(use_place_holder)]
    pub radius: PositiveLengthMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = standard_uncertainty)]
#[holder(generate_deserialize)]
pub struct StandardUncertainty {
    #[holder(use_place_holder)]
    #[holder(supertype = "uncertainty_qualifier")]
    pub measure_name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "uncertainty_qualifier")]
    pub description: Text,
    pub uncertainty_value: f64,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum StandardUncertaintyAny {
    #[holder(use_place_holder)]
    StandardUncertainty(Box<StandardUncertainty>),
    #[holder(use_place_holder)]
    ExpandedUncertainty(Box<ExpandedUncertainty>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = start_request)]
#[holder(generate_deserialize)]
pub struct StartRequest {
    #[holder(use_place_holder)]
    #[holder(supertype = "action_request_assignment")]
    pub assigned_action_request: VersionedActionRequest,
    #[holder(use_place_holder)]
    pub items: Vec<StartRequestItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = start_work)]
#[holder(generate_deserialize)]
pub struct StartWork {
    #[holder(use_place_holder)]
    #[holder(supertype = "action_assignment")]
    pub assigned_action: ActionAny,
    #[holder(use_place_holder)]
    pub items: Vec<WorkItem>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = straightness_tolerance)]
#[holder(generate_deserialize)]
pub struct StraightnessTolerance {
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub description: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub magnitude: MeasureWithUnitAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub toleranced_shape_aspect: ShapeAspectAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = structured_dimension_callout)]
#[holder(generate_deserialize)]
pub struct StructuredDimensionCallout {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "draughting_callout")]
    pub contents: Vec<DraughtingCalloutElement>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = structured_text_composition)]
#[holder(generate_deserialize)]
pub struct StructuredTextComposition {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "compound_representation_item")]
    pub item_element: CompoundItemDefinition,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = structured_text_representation)]
#[holder(generate_deserialize)]
pub struct StructuredTextRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = styled_item)]
#[holder(generate_deserialize)]
pub struct StyledItem {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub styles: Vec<PresentationStyleAssignmentAny>,
    #[holder(use_place_holder)]
    pub item: RepresentationItemAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum StyledItemAny {
    #[holder(use_place_holder)]
    StyledItem(Box<StyledItem>),
    #[holder(use_place_holder)]
    AnnotationOccurrence(Box<AnnotationOccurrenceAny>),
    #[holder(use_place_holder)]
    OverRidingStyledItem(Box<OverRidingStyledItemAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = subedge)]
#[holder(generate_deserialize)]
pub struct Subedge {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "edge")]
    pub edge_start: VertexAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "edge")]
    pub edge_end: VertexAny,
    #[holder(use_place_holder)]
    pub parent_edge: EdgeAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = subface)]
#[holder(generate_deserialize)]
pub struct Subface {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "face")]
    pub bounds: Vec<FaceBoundAny>,
    #[holder(use_place_holder)]
    pub parent_face: FaceAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = supplied_part_relationship)]
#[holder(generate_deserialize)]
pub struct SuppliedPartRelationship {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub relating_product_definition: ProductDefinitionAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition_relationship")]
    pub related_product_definition: ProductDefinitionAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = surface)]
#[holder(generate_deserialize)]
pub struct Surface {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum SurfaceAny {
    #[holder(use_place_holder)]
    Surface(Box<Surface>),
    #[holder(use_place_holder)]
    BoundedSurface(Box<BoundedSurfaceAny>),
    #[holder(use_place_holder)]
    ElementarySurface(Box<ElementarySurfaceAny>),
    #[holder(use_place_holder)]
    OffsetSurface(Box<OffsetSurface>),
    #[holder(use_place_holder)]
    OrientedSurface(Box<OrientedSurface>),
    #[holder(use_place_holder)]
    SurfaceReplica(Box<SurfaceReplica>),
    #[holder(use_place_holder)]
    SweptSurface(Box<SweptSurfaceAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = surface_condition_callout)]
#[holder(generate_deserialize)]
pub struct SurfaceConditionCallout {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "draughting_callout")]
    pub contents: Vec<DraughtingCalloutElement>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = surface_curve)]
#[holder(generate_deserialize)]
pub struct SurfaceCurve {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub curve_3d: CurveAny,
    #[holder(use_place_holder)]
    pub associated_geometry: Vec<PcurveOrSurface>,
    pub master_representation: PreferredSurfaceCurveRepresentation,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum SurfaceCurveAny {
    #[holder(use_place_holder)]
    SurfaceCurve(Box<SurfaceCurve>),
    #[holder(use_place_holder)]
    BoundedSurfaceCurve(Box<BoundedSurfaceCurve>),
    #[holder(use_place_holder)]
    IntersectionCurve(Box<IntersectionCurve>),
    #[holder(use_place_holder)]
    SeamCurve(Box<SeamCurve>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = surface_curve_swept_area_solid)]
#[holder(generate_deserialize)]
pub struct SurfaceCurveSweptAreaSolid {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "swept_area_solid")]
    pub swept_area: CurveBoundedSurface,
    #[holder(use_place_holder)]
    pub directrix: CurveAny,
    pub start_param: f64,
    pub end_param: f64,
    #[holder(use_place_holder)]
    pub reference_surface: SurfaceAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum SurfaceCurveSweptAreaSolidAny {
    #[holder(use_place_holder)]
    SurfaceCurveSweptAreaSolid(Box<SurfaceCurveSweptAreaSolid>),
    #[holder(use_place_holder)]
    RuledSurfaceSweptAreaSolid(Box<RuledSurfaceSweptAreaSolid>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = surface_of_linear_extrusion)]
#[holder(generate_deserialize)]
pub struct SurfaceOfLinearExtrusion {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "swept_surface")]
    pub swept_curve: CurveAny,
    #[holder(use_place_holder)]
    pub extrusion_axis: Vector,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = surface_of_revolution)]
#[holder(generate_deserialize)]
pub struct SurfaceOfRevolution {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "swept_surface")]
    pub swept_curve: CurveAny,
    #[holder(use_place_holder)]
    pub axis_position: Axis1Placement,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = surface_patch)]
#[holder(generate_deserialize)]
pub struct SurfacePatch {
    #[holder(use_place_holder)]
    pub parent_surface: BoundedSurfaceAny,
    pub u_transition: TransitionCode,
    pub v_transition: TransitionCode,
    pub u_sense: bool,
    pub v_sense: bool,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = surface_profile_tolerance)]
#[holder(generate_deserialize)]
pub struct SurfaceProfileTolerance {
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub description: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub magnitude: MeasureWithUnitAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub toleranced_shape_aspect: ShapeAspectAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = surface_rendering_properties)]
#[holder(generate_deserialize)]
pub struct SurfaceRenderingProperties {
    #[holder(use_place_holder)]
    pub rendered_colour: ColourAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = surface_replica)]
#[holder(generate_deserialize)]
pub struct SurfaceReplica {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub parent_surface: SurfaceAny,
    #[holder(use_place_holder)]
    pub transformation: CartesianTransformationOperator3D,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = surface_side_style)]
#[holder(generate_deserialize)]
pub struct SurfaceSideStyle {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub styles: Vec<SurfaceStyleElementSelect>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = surface_style_boundary)]
#[holder(generate_deserialize)]
pub struct SurfaceStyleBoundary {
    #[holder(use_place_holder)]
    pub style_of_boundary: CurveOrRender,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = surface_style_control_grid)]
#[holder(generate_deserialize)]
pub struct SurfaceStyleControlGrid {
    #[holder(use_place_holder)]
    pub style_of_control_grid: CurveOrRender,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = surface_style_fill_area)]
#[holder(generate_deserialize)]
pub struct SurfaceStyleFillArea {
    #[holder(use_place_holder)]
    pub fill_area: FillAreaStyle,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = surface_style_parameter_line)]
#[holder(generate_deserialize)]
pub struct SurfaceStyleParameterLine {
    #[holder(use_place_holder)]
    pub style_of_parameter_lines: CurveOrRender,
    #[holder(use_place_holder)]
    pub direction_counts: Vec<DirectionCountSelect>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = surface_style_reflectance_ambient)]
#[holder(generate_deserialize)]
pub struct SurfaceStyleReflectanceAmbient {
    pub ambient_reflectance: f64,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum SurfaceStyleReflectanceAmbientAny {
    #[holder(use_place_holder)]
    SurfaceStyleReflectanceAmbient(Box<SurfaceStyleReflectanceAmbient>),
    #[holder(use_place_holder)]
    SurfaceStyleReflectanceAmbientDiffuse(Box<SurfaceStyleReflectanceAmbientDiffuseAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = surface_style_reflectance_ambient_diffuse)]
#[holder(generate_deserialize)]
pub struct SurfaceStyleReflectanceAmbientDiffuse {
    #[holder(supertype = "surface_style_reflectance_ambient")]
    pub ambient_reflectance: f64,
    pub diffuse_reflectance: f64,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum SurfaceStyleReflectanceAmbientDiffuseAny {
    #[holder(use_place_holder)]
    SurfaceStyleReflectanceAmbientDiffuse(Box<SurfaceStyleReflectanceAmbientDiffuse>),
    #[holder(use_place_holder)]
    SurfaceStyleReflectanceAmbientDiffuseSpecular(
        Box<SurfaceStyleReflectanceAmbientDiffuseSpecular>,
    ),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = surface_style_reflectance_ambient_diffuse_specular)]
#[holder(generate_deserialize)]
pub struct SurfaceStyleReflectanceAmbientDiffuseSpecular {
    #[holder(supertype = "surface_style_reflectance_ambient")]
    pub ambient_reflectance: f64,
    #[holder(supertype = "surface_style_reflectance_ambient_diffuse")]
    pub diffuse_reflectance: f64,
    pub specular_reflectance: f64,
    pub specular_exponent: f64,
    #[holder(use_place_holder)]
    pub specular_colour: ColourAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = surface_style_rendering)]
#[holder(generate_deserialize)]
pub struct SurfaceStyleRendering {
    pub rendering_method: ShadingSurfaceMethod,
    #[holder(use_place_holder)]
    pub surface_colour: ColourAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum SurfaceStyleRenderingAny {
    #[holder(use_place_holder)]
    SurfaceStyleRendering(Box<SurfaceStyleRendering>),
    #[holder(use_place_holder)]
    SurfaceStyleRenderingWithProperties(Box<SurfaceStyleRenderingWithProperties>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = surface_style_rendering_with_properties)]
#[holder(generate_deserialize)]
pub struct SurfaceStyleRenderingWithProperties {
    #[holder(supertype = "surface_style_rendering")]
    pub rendering_method: ShadingSurfaceMethod,
    #[holder(use_place_holder)]
    #[holder(supertype = "surface_style_rendering")]
    pub surface_colour: ColourAny,
    #[holder(use_place_holder)]
    pub properties: Vec<RenderingPropertiesSelect>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = surface_style_segmentation_curve)]
#[holder(generate_deserialize)]
pub struct SurfaceStyleSegmentationCurve {
    #[holder(use_place_holder)]
    pub style_of_segmentation_curve: CurveOrRender,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = surface_style_silhouette)]
#[holder(generate_deserialize)]
pub struct SurfaceStyleSilhouette {
    #[holder(use_place_holder)]
    pub style_of_silhouette: CurveOrRender,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = surface_style_transparent)]
#[holder(generate_deserialize)]
pub struct SurfaceStyleTransparent {
    pub transparency: f64,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = surface_style_usage)]
#[holder(generate_deserialize)]
pub struct SurfaceStyleUsage {
    pub side: SurfaceSide,
    #[holder(use_place_holder)]
    pub style: SurfaceSideStyleSelect,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = surface_texture_representation)]
#[holder(generate_deserialize)]
pub struct SurfaceTextureRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = surfaced_open_shell)]
#[holder(generate_deserialize)]
pub struct SurfacedOpenShell {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "connected_face_set")]
    pub cfs_faces: Vec<FaceAny>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = swept_area_solid)]
#[holder(generate_deserialize)]
pub struct SweptAreaSolid {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub swept_area: CurveBoundedSurface,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum SweptAreaSolidAny {
    #[holder(use_place_holder)]
    SweptAreaSolid(Box<SweptAreaSolid>),
    #[holder(use_place_holder)]
    ExtrudedAreaSolid(Box<ExtrudedAreaSolid>),
    #[holder(use_place_holder)]
    RevolvedAreaSolid(Box<RevolvedAreaSolid>),
    #[holder(use_place_holder)]
    SurfaceCurveSweptAreaSolid(Box<SurfaceCurveSweptAreaSolidAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = swept_disk_solid)]
#[holder(generate_deserialize)]
pub struct SweptDiskSolid {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub directrix: CurveAny,
    #[holder(use_place_holder)]
    pub radius: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    pub inner_radius: Option<PositiveLengthMeasure>,
    pub start_param: f64,
    pub end_param: f64,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = swept_face_solid)]
#[holder(generate_deserialize)]
pub struct SweptFaceSolid {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub swept_face: FaceSurfaceAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum SweptFaceSolidAny {
    #[holder(use_place_holder)]
    SweptFaceSolid(Box<SweptFaceSolid>),
    #[holder(use_place_holder)]
    ExtrudedFaceSolid(Box<ExtrudedFaceSolidAny>),
    #[holder(use_place_holder)]
    RevolvedFaceSolid(Box<RevolvedFaceSolidAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = swept_surface)]
#[holder(generate_deserialize)]
pub struct SweptSurface {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub swept_curve: CurveAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum SweptSurfaceAny {
    #[holder(use_place_holder)]
    SweptSurface(Box<SweptSurface>),
    #[holder(use_place_holder)]
    SurfaceOfLinearExtrusion(Box<SurfaceOfLinearExtrusion>),
    #[holder(use_place_holder)]
    SurfaceOfRevolution(Box<SurfaceOfRevolution>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = symbol)]
#[holder(generate_deserialize)]
pub struct Symbol {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = symbol_colour)]
#[holder(generate_deserialize)]
pub struct SymbolColour {
    #[holder(use_place_holder)]
    pub colour_of_symbol: ColourAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = symbol_representation)]
#[holder(generate_deserialize)]
pub struct SymbolRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum SymbolRepresentationAny {
    #[holder(use_place_holder)]
    SymbolRepresentation(Box<SymbolRepresentation>),
    #[holder(use_place_holder)]
    DraughtingSubfigureRepresentation(Box<DraughtingSubfigureRepresentation>),
    #[holder(use_place_holder)]
    DraughtingSymbolRepresentation(Box<DraughtingSymbolRepresentation>),
    #[holder(use_place_holder)]
    GenericCharacterGlyphSymbol(Box<GenericCharacterGlyphSymbolAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = symbol_representation_map)]
#[holder(generate_deserialize)]
pub struct SymbolRepresentationMap {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_map")]
    pub mapping_origin: RepresentationItemAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_map")]
    pub mapped_representation: RepresentationAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = symbol_style)]
#[holder(generate_deserialize)]
pub struct SymbolStyle {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub style_of_symbol: SymbolStyleSelect,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = symbol_target)]
#[holder(generate_deserialize)]
pub struct SymbolTarget {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub placement: Axis2Placement,
    #[holder(use_place_holder)]
    pub x_scale: PositiveRatioMeasure,
    #[holder(use_place_holder)]
    pub y_scale: PositiveRatioMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = symmetric_shape_aspect)]
#[holder(generate_deserialize)]
pub struct SymmetricShapeAspect {
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub of_shape: ProductDefinitionShape,
    #[holder(supertype = "shape_aspect")]
    pub product_definitional: Logical,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = symmetry_tolerance)]
#[holder(generate_deserialize)]
pub struct SymmetryTolerance {
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub description: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub magnitude: MeasureWithUnitAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub toleranced_shape_aspect: ShapeAspectAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance_with_datum_reference")]
    pub datum_system: Vec<DatumReferenceAny>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = table_representation_item)]
#[holder(generate_deserialize)]
pub struct TableRepresentationItem {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "compound_representation_item")]
    pub item_element: CompoundItemDefinition,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = tactile_appearance_representation)]
#[holder(generate_deserialize)]
pub struct TactileAppearanceRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = tagged_text_format)]
#[holder(generate_deserialize)]
pub struct TaggedTextFormat {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_context")]
    pub context_identifier: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_context")]
    pub context_type: Text,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = tagged_text_item)]
#[holder(generate_deserialize)]
pub struct TaggedTextItem {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "descriptive_representation_item")]
    pub description: Text,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = tangent)]
#[holder(generate_deserialize)]
pub struct Tangent {
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub of_shape: ProductDefinitionShape,
    #[holder(supertype = "shape_aspect")]
    pub product_definitional: Logical,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = terminator_symbol)]
#[holder(generate_deserialize)]
pub struct TerminatorSymbol {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "styled_item")]
    pub styles: Vec<PresentationStyleAssignmentAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "styled_item")]
    pub item: RepresentationItemAny,
    #[holder(use_place_holder)]
    pub annotated_curve: AnnotationCurveOccurrenceAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum TerminatorSymbolAny {
    #[holder(use_place_holder)]
    TerminatorSymbol(Box<TerminatorSymbol>),
    #[holder(use_place_holder)]
    DimensionCurveTerminator(Box<DimensionCurveTerminator>),
    #[holder(use_place_holder)]
    LeaderTerminator(Box<LeaderTerminator>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = text_font)]
#[holder(generate_deserialize)]
pub struct TextFont {
    #[holder(use_place_holder)]
    pub id: Identifier,
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Text,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = text_font_family)]
#[holder(generate_deserialize)]
pub struct TextFontFamily {
    #[holder(use_place_holder)]
    pub id: Identifier,
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Text,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = text_font_in_family)]
#[holder(generate_deserialize)]
pub struct TextFontInFamily {
    #[holder(use_place_holder)]
    pub font: TextFont,
    #[holder(use_place_holder)]
    pub family: TextFontFamily,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = text_literal)]
#[holder(generate_deserialize)]
pub struct TextLiteral {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub literal: PresentableText,
    #[holder(use_place_holder)]
    pub placement: Axis2Placement,
    #[holder(use_place_holder)]
    pub alignment: TextAlignment,
    pub path: TextPath,
    #[holder(use_place_holder)]
    pub font: FontSelect,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum TextLiteralAny {
    #[holder(use_place_holder)]
    TextLiteral(Box<TextLiteral>),
    #[holder(use_place_holder)]
    DimensionTextAssociativity(Box<DimensionTextAssociativity>),
    #[holder(use_place_holder)]
    TextLiteralWithAssociatedCurves(Box<TextLiteralWithAssociatedCurves>),
    #[holder(use_place_holder)]
    TextLiteralWithBlankingBox(Box<TextLiteralWithBlankingBox>),
    #[holder(use_place_holder)]
    TextLiteralWithDelineation(Box<TextLiteralWithDelineationAny>),
    #[holder(use_place_holder)]
    TextLiteralWithExtent(Box<TextLiteralWithExtent>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = text_literal_with_associated_curves)]
#[holder(generate_deserialize)]
pub struct TextLiteralWithAssociatedCurves {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "text_literal")]
    pub literal: PresentableText,
    #[holder(use_place_holder)]
    #[holder(supertype = "text_literal")]
    pub placement: Axis2Placement,
    #[holder(use_place_holder)]
    #[holder(supertype = "text_literal")]
    pub alignment: TextAlignment,
    #[holder(supertype = "text_literal")]
    pub path: TextPath,
    #[holder(use_place_holder)]
    #[holder(supertype = "text_literal")]
    pub font: FontSelect,
    #[holder(use_place_holder)]
    pub associated_curves: Vec<CurveAny>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = text_literal_with_blanking_box)]
#[holder(generate_deserialize)]
pub struct TextLiteralWithBlankingBox {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "text_literal")]
    pub literal: PresentableText,
    #[holder(use_place_holder)]
    #[holder(supertype = "text_literal")]
    pub placement: Axis2Placement,
    #[holder(use_place_holder)]
    #[holder(supertype = "text_literal")]
    pub alignment: TextAlignment,
    #[holder(supertype = "text_literal")]
    pub path: TextPath,
    #[holder(use_place_holder)]
    #[holder(supertype = "text_literal")]
    pub font: FontSelect,
    #[holder(use_place_holder)]
    pub blanking: PlanarBox,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = text_literal_with_delineation)]
#[holder(generate_deserialize)]
pub struct TextLiteralWithDelineation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "text_literal")]
    pub literal: PresentableText,
    #[holder(use_place_holder)]
    #[holder(supertype = "text_literal")]
    pub placement: Axis2Placement,
    #[holder(use_place_holder)]
    #[holder(supertype = "text_literal")]
    pub alignment: TextAlignment,
    #[holder(supertype = "text_literal")]
    pub path: TextPath,
    #[holder(use_place_holder)]
    #[holder(supertype = "text_literal")]
    pub font: FontSelect,
    #[holder(use_place_holder)]
    pub delineation: TextDelineation,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum TextLiteralWithDelineationAny {
    #[holder(use_place_holder)]
    TextLiteralWithDelineation(Box<TextLiteralWithDelineation>),
    #[holder(use_place_holder)]
    DraughtingTextLiteralWithDelineation(Box<DraughtingTextLiteralWithDelineation>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = text_literal_with_extent)]
#[holder(generate_deserialize)]
pub struct TextLiteralWithExtent {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "text_literal")]
    pub literal: PresentableText,
    #[holder(use_place_holder)]
    #[holder(supertype = "text_literal")]
    pub placement: Axis2Placement,
    #[holder(use_place_holder)]
    #[holder(supertype = "text_literal")]
    pub alignment: TextAlignment,
    #[holder(supertype = "text_literal")]
    pub path: TextPath,
    #[holder(use_place_holder)]
    #[holder(supertype = "text_literal")]
    pub font: FontSelect,
    #[holder(use_place_holder)]
    pub extent: PlanarExtentAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = text_string_representation)]
#[holder(generate_deserialize)]
pub struct TextStringRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = text_style)]
#[holder(generate_deserialize)]
pub struct TextStyle {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub character_appearance: CharacterStyleSelect,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum TextStyleAny {
    #[holder(use_place_holder)]
    TextStyle(Box<TextStyle>),
    #[holder(use_place_holder)]
    TextStyleWithBoxCharacteristics(Box<TextStyleWithBoxCharacteristics>),
    #[holder(use_place_holder)]
    TextStyleWithMirror(Box<TextStyleWithMirror>),
    #[holder(use_place_holder)]
    TextStyleWithSpacing(Box<TextStyleWithSpacing>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = text_style_for_defined_font)]
#[holder(generate_deserialize)]
pub struct TextStyleForDefinedFont {
    #[holder(use_place_holder)]
    pub text_colour: ColourAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = text_style_with_box_characteristics)]
#[holder(generate_deserialize)]
pub struct TextStyleWithBoxCharacteristics {
    #[holder(use_place_holder)]
    #[holder(supertype = "text_style")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "text_style")]
    pub character_appearance: CharacterStyleSelect,
    #[holder(use_place_holder)]
    pub characteristics: Vec<BoxCharacteristicSelect>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = text_style_with_mirror)]
#[holder(generate_deserialize)]
pub struct TextStyleWithMirror {
    #[holder(use_place_holder)]
    #[holder(supertype = "text_style")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "text_style")]
    pub character_appearance: CharacterStyleSelect,
    #[holder(use_place_holder)]
    pub mirror_placement: Axis2Placement,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = text_style_with_spacing)]
#[holder(generate_deserialize)]
pub struct TextStyleWithSpacing {
    #[holder(use_place_holder)]
    #[holder(supertype = "text_style")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "text_style")]
    pub character_appearance: CharacterStyleSelect,
    #[holder(use_place_holder)]
    pub character_spacing: CharacterSpacingSelect,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = thermal_resistance_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct ThermalResistanceMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = thermal_resistance_unit)]
#[holder(generate_deserialize)]
pub struct ThermalResistanceUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = thermodynamic_temperature_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct ThermodynamicTemperatureMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = thermodynamic_temperature_unit)]
#[holder(generate_deserialize)]
pub struct ThermodynamicTemperatureUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "named_unit")]
    pub dimensions: DimensionalExponents,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = thickened_face_solid)]
#[holder(generate_deserialize)]
pub struct ThickenedFaceSolid {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub base_element: GeneralizedSurfaceSelect,
    #[holder(use_place_holder)]
    pub offset1: LengthMeasure,
    #[holder(use_place_holder)]
    pub offset2: LengthMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = thickness_laminate_definition)]
#[holder(generate_deserialize)]
pub struct ThicknessLaminateDefinition {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub formation: ProductDefinitionFormationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub frame_of_reference: ProductDefinitionContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = thickness_laminate_table)]
#[holder(generate_deserialize)]
pub struct ThicknessLaminateTable {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub formation: ProductDefinitionFormationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub frame_of_reference: ProductDefinitionContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = time_interval)]
#[holder(generate_deserialize)]
pub struct TimeInterval {
    #[holder(use_place_holder)]
    pub id: Identifier,
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum TimeIntervalAny {
    #[holder(use_place_holder)]
    TimeInterval(Box<TimeInterval>),
    #[holder(use_place_holder)]
    TimeIntervalWithBounds(Box<TimeIntervalWithBounds>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = time_interval_assignment)]
#[holder(generate_deserialize)]
pub struct TimeIntervalAssignment {
    #[holder(use_place_holder)]
    pub assigned_time_interval: TimeIntervalAny,
    #[holder(use_place_holder)]
    pub role: TimeIntervalRole,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum TimeIntervalAssignmentAny {
    #[holder(use_place_holder)]
    TimeIntervalAssignment(Box<TimeIntervalAssignment>),
    #[holder(use_place_holder)]
    AppliedTimeIntervalAssignment(Box<AppliedTimeIntervalAssignment>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = time_interval_based_effectivity)]
#[holder(generate_deserialize)]
pub struct TimeIntervalBasedEffectivity {
    #[holder(use_place_holder)]
    #[holder(supertype = "effectivity")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    pub effectivity_period: TimeIntervalAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = time_interval_relationship)]
#[holder(generate_deserialize)]
pub struct TimeIntervalRelationship {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub relating_time_interval: TimeIntervalAny,
    #[holder(use_place_holder)]
    pub related_time_interval: TimeIntervalAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = time_interval_role)]
#[holder(generate_deserialize)]
pub struct TimeIntervalRole {
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = time_interval_with_bounds)]
#[holder(generate_deserialize)]
pub struct TimeIntervalWithBounds {
    #[holder(use_place_holder)]
    #[holder(supertype = "time_interval")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "time_interval")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "time_interval")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    pub primary_bound: Option<DateTimeOrEventOccurrence>,
    #[holder(use_place_holder)]
    pub secondary_bound: Option<DateTimeOrEventOccurrence>,
    #[holder(use_place_holder)]
    pub duration: Option<TimeMeasureWithUnit>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = time_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct TimeMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = time_unit)]
#[holder(generate_deserialize)]
pub struct TimeUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "named_unit")]
    pub dimensions: DimensionalExponents,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = tolerance_value)]
#[holder(generate_deserialize)]
pub struct ToleranceValue {
    #[holder(use_place_holder)]
    pub lower_bound: MeasureWithUnitAny,
    #[holder(use_place_holder)]
    pub upper_bound: MeasureWithUnitAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = tolerance_zone)]
#[holder(generate_deserialize)]
pub struct ToleranceZone {
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "shape_aspect")]
    pub of_shape: ProductDefinitionShape,
    #[holder(supertype = "shape_aspect")]
    pub product_definitional: Logical,
    #[holder(use_place_holder)]
    pub defining_tolerance: Vec<GeometricToleranceAny>,
    #[holder(use_place_holder)]
    pub form: ToleranceZoneForm,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = tolerance_zone_definition)]
#[holder(generate_deserialize)]
pub struct ToleranceZoneDefinition {
    #[holder(use_place_holder)]
    pub zone: ToleranceZone,
    #[holder(use_place_holder)]
    pub boundaries: Vec<ShapeAspectAny>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ToleranceZoneDefinitionAny {
    #[holder(use_place_holder)]
    ToleranceZoneDefinition(Box<ToleranceZoneDefinition>),
    #[holder(use_place_holder)]
    ProjectedZoneDefinition(Box<ProjectedZoneDefinition>),
    #[holder(use_place_holder)]
    RunoutZoneDefinition(Box<RunoutZoneDefinition>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = tolerance_zone_form)]
#[holder(generate_deserialize)]
pub struct ToleranceZoneForm {
    #[holder(use_place_holder)]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = topological_representation_item)]
#[holder(generate_deserialize)]
pub struct TopologicalRepresentationItem {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum TopologicalRepresentationItemAny {
    #[holder(use_place_holder)]
    TopologicalRepresentationItem(Box<TopologicalRepresentationItem>),
    #[holder(use_place_holder)]
    ConnectedEdgeSet(Box<ConnectedEdgeSet>),
    #[holder(use_place_holder)]
    ConnectedFaceSet(Box<ConnectedFaceSetAny>),
    #[holder(use_place_holder)]
    Edge(Box<EdgeAny>),
    #[holder(use_place_holder)]
    Face(Box<FaceAny>),
    #[holder(use_place_holder)]
    FaceBound(Box<FaceBoundAny>),
    #[holder(use_place_holder)]
    Loop(Box<LoopAny>),
    #[holder(use_place_holder)]
    Path(Box<PathAny>),
    #[holder(use_place_holder)]
    Vertex(Box<VertexAny>),
    #[holder(use_place_holder)]
    VertexShell(Box<VertexShell>),
    #[holder(use_place_holder)]
    WireShell(Box<WireShell>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = toroidal_surface)]
#[holder(generate_deserialize)]
pub struct ToroidalSurface {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "elementary_surface")]
    pub position: Axis2Placement3D,
    #[holder(use_place_holder)]
    pub major_radius: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    pub minor_radius: PositiveLengthMeasure,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ToroidalSurfaceAny {
    #[holder(use_place_holder)]
    ToroidalSurface(Box<ToroidalSurface>),
    #[holder(use_place_holder)]
    DegenerateToroidalSurface(Box<DegenerateToroidalSurface>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = torus)]
#[holder(generate_deserialize)]
pub struct Torus {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub position: Axis1Placement,
    #[holder(use_place_holder)]
    pub major_radius: PositiveLengthMeasure,
    #[holder(use_place_holder)]
    pub minor_radius: PositiveLengthMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = total_runout_tolerance)]
#[holder(generate_deserialize)]
pub struct TotalRunoutTolerance {
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub description: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub magnitude: MeasureWithUnitAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance")]
    pub toleranced_shape_aspect: ShapeAspectAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "geometric_tolerance_with_datum_reference")]
    pub datum_system: Vec<DatumReferenceAny>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = track_blended_solid)]
#[holder(generate_deserialize)]
pub struct TrackBlendedSolid {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "edge_blended_solid")]
    pub blended_edges: Vec<EdgeCurve>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum TrackBlendedSolidAny {
    #[holder(use_place_holder)]
    TrackBlendedSolid(Box<TrackBlendedSolid>),
    #[holder(use_place_holder)]
    SolidWithVariableRadiusEdgeBlend(Box<SolidWithVariableRadiusEdgeBlend>),
    #[holder(use_place_holder)]
    TrackBlendedSolidWithEndConditions(Box<TrackBlendedSolidWithEndConditions>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = track_blended_solid_with_end_conditions)]
#[holder(generate_deserialize)]
pub struct TrackBlendedSolidWithEndConditions {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub rationale: Text,
    #[holder(use_place_holder)]
    #[holder(supertype = "modified_solid")]
    pub base_solid: BaseSolidSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "edge_blended_solid")]
    pub blended_edges: Vec<EdgeCurve>,
    #[holder(use_place_holder)]
    pub end_conditions: Vec<BlendEndConditionSelect>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = transformation_with_derived_angle)]
#[holder(generate_deserialize)]
pub struct TransformationWithDerivedAngle {
    #[holder(use_place_holder)]
    #[holder(supertype = "item_defined_transformation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "item_defined_transformation")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "item_defined_transformation")]
    pub transform_item_1: RepresentationItemAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "item_defined_transformation")]
    pub transform_item_2: RepresentationItemAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum TransformationWithDerivedAngleAny {
    #[holder(use_place_holder)]
    TransformationWithDerivedAngle(Box<TransformationWithDerivedAngle>),
    #[holder(use_place_holder)]
    DrapedDefinedTransformation(Box<DrapedDefinedTransformation>),
    #[holder(use_place_holder)]
    LaidDefinedTransformation(Box<LaidDefinedTransformation>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = trimmed_curve)]
#[holder(generate_deserialize)]
pub struct TrimmedCurve {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub basis_curve: CurveAny,
    #[holder(use_place_holder)]
    pub trim_1: Vec<TrimmingSelect>,
    #[holder(use_place_holder)]
    pub trim_2: Vec<TrimmingSelect>,
    pub sense_agreement: bool,
    pub master_representation: TrimmingPreference,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = two_direction_repeat_factor)]
#[holder(generate_deserialize)]
pub struct TwoDirectionRepeatFactor {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "one_direction_repeat_factor")]
    pub repeat_factor: Vector,
    #[holder(use_place_holder)]
    pub second_repeat_factor: Vector,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = type_qualifier)]
#[holder(generate_deserialize)]
pub struct TypeQualifier {
    #[holder(use_place_holder)]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = unary_generic_expression)]
#[holder(generate_deserialize)]
pub struct UnaryGenericExpression {
    #[holder(use_place_holder)]
    pub operand: GenericExpressionAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum UnaryGenericExpressionAny {
    #[holder(use_place_holder)]
    UnaryGenericExpression(Box<UnaryGenericExpression>),
    #[holder(use_place_holder)]
    UnaryNumericExpression(Box<UnaryNumericExpression>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = unary_numeric_expression)]
#[holder(generate_deserialize)]
pub struct UnaryNumericExpression {
    #[holder(use_place_holder)]
    #[holder(supertype = "unary_generic_expression")]
    pub operand: GenericExpressionAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = uncertainty_assigned_representation)]
#[holder(generate_deserialize)]
pub struct UncertaintyAssignedRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
    #[holder(use_place_holder)]
    pub uncertainty: Vec<UncertaintyMeasureWithUnit>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = uncertainty_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct UncertaintyMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
    #[holder(use_place_holder)]
    pub name: Label,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = uncertainty_qualifier)]
#[holder(generate_deserialize)]
pub struct UncertaintyQualifier {
    #[holder(use_place_holder)]
    pub measure_name: Label,
    #[holder(use_place_holder)]
    pub description: Text,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum UncertaintyQualifierAny {
    #[holder(use_place_holder)]
    UncertaintyQualifier(Box<UncertaintyQualifier>),
    #[holder(use_place_holder)]
    QualitativeUncertainty(Box<QualitativeUncertainty>),
    #[holder(use_place_holder)]
    StandardUncertainty(Box<StandardUncertaintyAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = uniform_curve)]
#[holder(generate_deserialize)]
pub struct UniformCurve {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(supertype = "b_spline_curve")]
    pub degree: i64,
    #[holder(use_place_holder)]
    #[holder(supertype = "b_spline_curve")]
    pub control_points_list: Vec<CartesianPoint>,
    #[holder(supertype = "b_spline_curve")]
    pub curve_form: BSplineCurveForm,
    #[holder(supertype = "b_spline_curve")]
    pub closed_curve: Logical,
    #[holder(supertype = "b_spline_curve")]
    pub self_intersect: Logical,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = uniform_resource_identifier)]
#[holder(generate_deserialize)]
pub struct UniformResourceIdentifier {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "descriptive_representation_item")]
    pub description: Text,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = uniform_surface)]
#[holder(generate_deserialize)]
pub struct UniformSurface {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(supertype = "b_spline_surface")]
    pub u_degree: i64,
    #[holder(supertype = "b_spline_surface")]
    pub v_degree: i64,
    #[holder(use_place_holder)]
    #[holder(supertype = "b_spline_surface")]
    pub control_points_list: Vec<Vec<CartesianPoint>>,
    #[holder(supertype = "b_spline_surface")]
    pub surface_form: BSplineSurfaceForm,
    #[holder(supertype = "b_spline_surface")]
    pub u_closed: Logical,
    #[holder(supertype = "b_spline_surface")]
    pub v_closed: Logical,
    #[holder(supertype = "b_spline_surface")]
    pub self_intersect: Logical,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = usage_association)]
#[holder(generate_deserialize)]
pub struct UsageAssociation {
    #[holder(use_place_holder)]
    #[holder(supertype = "action_method_relationship")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "action_method_relationship")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "action_method_relationship")]
    pub relating_method: ActionMethodAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "action_method_relationship")]
    pub related_method: ActionMethodAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = user_defined_curve_font)]
#[holder(generate_deserialize)]
pub struct UserDefinedCurveFont {
    #[holder(use_place_holder)]
    #[holder(supertype = "curve_style_font")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "curve_style_font")]
    pub pattern_list: Vec<CurveStyleFontPattern>,
    #[holder(use_place_holder)]
    #[holder(supertype = "mapped_item")]
    pub mapping_source: RepresentationMapAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "mapped_item")]
    pub mapping_target: RepresentationItemAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = user_defined_marker)]
#[holder(generate_deserialize)]
pub struct UserDefinedMarker {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "mapped_item")]
    pub mapping_source: RepresentationMapAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "mapped_item")]
    pub mapping_target: RepresentationItemAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = user_defined_terminator_symbol)]
#[holder(generate_deserialize)]
pub struct UserDefinedTerminatorSymbol {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "mapped_item")]
    pub mapping_source: RepresentationMapAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "mapped_item")]
    pub mapping_target: RepresentationItemAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = user_selected_elements)]
#[holder(generate_deserialize)]
pub struct UserSelectedElements {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub picked_items: Vec<RepresentationItemAny>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum UserSelectedElementsAny {
    #[holder(use_place_holder)]
    UserSelectedElements(Box<UserSelectedElements>),
    #[holder(use_place_holder)]
    IndirectlySelectedElements(Box<IndirectlySelectedElementsAny>),
    #[holder(use_place_holder)]
    UserSelectedShapeElements(Box<UserSelectedShapeElementsAny>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = user_selected_shape_elements)]
#[holder(generate_deserialize)]
pub struct UserSelectedShapeElements {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "user_selected_elements")]
    pub picked_items: Vec<RepresentationItemAny>,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum UserSelectedShapeElementsAny {
    #[holder(use_place_holder)]
    UserSelectedShapeElements(Box<UserSelectedShapeElements>),
    #[holder(use_place_holder)]
    IndirectlySelectedShapeElements(Box<IndirectlySelectedShapeElements>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = value_range)]
#[holder(generate_deserialize)]
pub struct ValueRange {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "compound_representation_item")]
    pub item_element: CompoundItemDefinition,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = value_representation_item)]
#[holder(generate_deserialize)]
pub struct ValueRepresentationItem {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub value_component: MeasureValue,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = variable_semantics)]
#[holder(generate_deserialize)]
pub struct VariableSemantics {}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum VariableSemanticsAny {
    #[holder(use_place_holder)]
    VariableSemantics(Box<VariableSemantics>),
    #[holder(use_place_holder)]
    ExpressionConversionBasedUnit(Box<ExpressionConversionBasedUnit>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = variational_representation_item)]
#[holder(generate_deserialize)]
pub struct VariationalRepresentationItem {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum VariationalRepresentationItemAny {
    #[holder(use_place_holder)]
    VariationalRepresentationItem(Box<VariationalRepresentationItem>),
    #[holder(use_place_holder)]
    AuxiliaryGeometricRepresentationItem(Box<AuxiliaryGeometricRepresentationItem>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = vector)]
#[holder(generate_deserialize)]
pub struct Vector {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub orientation: Direction,
    #[holder(use_place_holder)]
    pub magnitude: LengthMeasure,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = vector_style)]
#[holder(generate_deserialize)]
pub struct VectorStyle {
    #[holder(use_place_holder)]
    #[holder(supertype = "curve_style")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "curve_style")]
    pub curve_font: CurveFontOrScaledCurveFontSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "curve_style")]
    pub curve_width: SizeSelect,
    #[holder(use_place_holder)]
    #[holder(supertype = "curve_style")]
    pub curve_colour: ColourAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = velocity_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct VelocityMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = velocity_unit)]
#[holder(generate_deserialize)]
pub struct VelocityUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = versioned_action_request)]
#[holder(generate_deserialize)]
pub struct VersionedActionRequest {
    #[holder(use_place_holder)]
    pub id: Identifier,
    #[holder(use_place_holder)]
    pub version: Label,
    #[holder(use_place_holder)]
    pub purpose: Text,
    #[holder(use_place_holder)]
    pub description: Option<Text>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = vertex)]
#[holder(generate_deserialize)]
pub struct Vertex {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum VertexAny {
    #[holder(use_place_holder)]
    Vertex(Box<Vertex>),
    #[holder(use_place_holder)]
    VertexPoint(Box<VertexPoint>),
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = vertex_loop)]
#[holder(generate_deserialize)]
pub struct VertexLoop {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub loop_vertex: VertexAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = vertex_point)]
#[holder(generate_deserialize)]
pub struct VertexPoint {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub vertex_geometry: PointAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = vertex_shell)]
#[holder(generate_deserialize)]
pub struct VertexShell {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub vertex_shell_extent: VertexLoop,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = view_volume)]
#[holder(generate_deserialize)]
pub struct ViewVolume {
    pub projection_type: CentralOrParallel,
    #[holder(use_place_holder)]
    pub projection_point: CartesianPoint,
    #[holder(use_place_holder)]
    pub view_plane_distance: LengthMeasure,
    #[holder(use_place_holder)]
    pub front_plane_distance: LengthMeasure,
    pub front_plane_clipping: bool,
    #[holder(use_place_holder)]
    pub back_plane_distance: LengthMeasure,
    pub back_plane_clipping: bool,
    pub view_volume_sides_clipping: bool,
    #[holder(use_place_holder)]
    pub view_window: PlanarBox,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = visual_appearance_representation)]
#[holder(generate_deserialize)]
pub struct VisualAppearanceRepresentation {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub name: Label,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub items: Vec<RepresentationItemAny>,
    #[holder(use_place_holder)]
    #[holder(supertype = "representation")]
    pub context_of_items: RepresentationContextAny,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = volume_measure_with_unit)]
#[holder(generate_deserialize)]
pub struct VolumeMeasureWithUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub value_component: MeasureValue,
    #[holder(use_place_holder)]
    #[holder(supertype = "measure_with_unit")]
    pub unit_component: Unit,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = volume_unit)]
#[holder(generate_deserialize)]
pub struct VolumeUnit {
    #[holder(use_place_holder)]
    #[holder(supertype = "derived_unit")]
    pub elements: Vec<DerivedUnitElement>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = week_of_year_and_day_date)]
#[holder(generate_deserialize)]
pub struct WeekOfYearAndDayDate {
    #[holder(use_place_holder)]
    #[holder(supertype = "date")]
    pub year_component: YearNumber,
    #[holder(use_place_holder)]
    pub week_component: WeekInYearNumber,
    #[holder(use_place_holder)]
    pub day_component: Option<DayInWeekNumber>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = wire_shell)]
#[holder(generate_deserialize)]
pub struct WireShell {
    #[holder(use_place_holder)]
    #[holder(supertype = "representation_item")]
    pub name: Label,
    #[holder(use_place_holder)]
    pub wire_shell_extent: Vec<LoopAny>,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = year_month)]
#[holder(generate_deserialize)]
pub struct YearMonth {
    #[holder(use_place_holder)]
    #[holder(supertype = "date")]
    pub year_component: YearNumber,
    #[holder(use_place_holder)]
    pub month_component: MonthInYearNumber,
}
#[derive(Debug, Clone, PartialEq, :: derive_new :: new, Holder)]
# [holder (table = Tables)]
# [holder (field = zone_structural_makeup)]
#[holder(generate_deserialize)]
pub struct ZoneStructuralMakeup {
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub id: Identifier,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub description: Option<Text>,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub formation: ProductDefinitionFormationAny,
    #[holder(use_place_holder)]
    #[holder(supertype = "product_definition")]
    pub frame_of_reference: ProductDefinitionContextAny,
}
#[derive(Debug, Clone, PartialEq, Holder)]
# [holder (table = Tables)]
#[holder(generate_deserialize)]
pub enum ZoneStructuralMakeupAny {
    #[holder(use_place_holder)]
    ZoneStructuralMakeup(Box<ZoneStructuralMakeup>),
    #[holder(use_place_holder)]
    PercentageLaminateTable(Box<PercentageLaminateTable>),
    #[holder(use_place_holder)]
    SmearedMaterialDefinition(Box<SmearedMaterialDefinition>),
    #[holder(use_place_holder)]
    ThicknessLaminateTable(Box<ThicknessLaminateTable>),
}
